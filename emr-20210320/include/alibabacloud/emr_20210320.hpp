// This file is auto-generated, don't edit it. Thanks.

#ifndef ALIBABACLOUD_EMR20210320_H_
#define ALIBABACLOUD_EMR20210320_H_

#include <alibabacloud/open_api.hpp>
#include <darabonba/core.hpp>
#include <darabonba/util.hpp>
#include <iostream>
#include <map>
#include <vector>

using namespace std;

namespace Alibabacloud_Emr20210320 {
class Tag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  Tag() {}

  explicit Tag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~Tag() = default;
};
class Toleration : public Darabonba::Model {
public:
  shared_ptr<string> effect{};
  shared_ptr<string> key{};
  shared_ptr<string> operator_{};
  shared_ptr<string> value{};

  Toleration() {}

  explicit Toleration(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (effect) {
      res["Effect"] = boost::any(*effect);
    }
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (operator_) {
      res["Operator"] = boost::any(*operator_);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Effect") != m.end() && !m["Effect"].empty()) {
      effect = make_shared<string>(boost::any_cast<string>(m["Effect"]));
    }
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Operator") != m.end() && !m["Operator"].empty()) {
      operator_ = make_shared<string>(boost::any_cast<string>(m["Operator"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~Toleration() = default;
};
class AckConfig : public Darabonba::Model {
public:
  shared_ptr<string> ackInstanceId{};
  shared_ptr<vector<Tag>> customAnnotations{};
  shared_ptr<vector<Tag>> customLabels{};
  shared_ptr<long> dataDiskSize{};
  shared_ptr<string> dataDiskStorageClass{};
  shared_ptr<double> limitCpu{};
  shared_ptr<double> limitMemory{};
  shared_ptr<bool> mountHostCgroup{};
  shared_ptr<string> namespace_{};
  shared_ptr<vector<Tag>> nodeSelectors{};
  shared_ptr<double> requestCpu{};
  shared_ptr<double> requestMemory{};
  shared_ptr<vector<Toleration>> tolerations{};

  AckConfig() {}

  explicit AckConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ackInstanceId) {
      res["AckInstanceId"] = boost::any(*ackInstanceId);
    }
    if (customAnnotations) {
      vector<boost::any> temp1;
      for(auto item1:*customAnnotations){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CustomAnnotations"] = boost::any(temp1);
    }
    if (customLabels) {
      vector<boost::any> temp1;
      for(auto item1:*customLabels){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CustomLabels"] = boost::any(temp1);
    }
    if (dataDiskSize) {
      res["DataDiskSize"] = boost::any(*dataDiskSize);
    }
    if (dataDiskStorageClass) {
      res["DataDiskStorageClass"] = boost::any(*dataDiskStorageClass);
    }
    if (limitCpu) {
      res["LimitCpu"] = boost::any(*limitCpu);
    }
    if (limitMemory) {
      res["LimitMemory"] = boost::any(*limitMemory);
    }
    if (mountHostCgroup) {
      res["MountHostCgroup"] = boost::any(*mountHostCgroup);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (nodeSelectors) {
      vector<boost::any> temp1;
      for(auto item1:*nodeSelectors){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NodeSelectors"] = boost::any(temp1);
    }
    if (requestCpu) {
      res["RequestCpu"] = boost::any(*requestCpu);
    }
    if (requestMemory) {
      res["RequestMemory"] = boost::any(*requestMemory);
    }
    if (tolerations) {
      vector<boost::any> temp1;
      for(auto item1:*tolerations){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tolerations"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AckInstanceId") != m.end() && !m["AckInstanceId"].empty()) {
      ackInstanceId = make_shared<string>(boost::any_cast<string>(m["AckInstanceId"]));
    }
    if (m.find("CustomAnnotations") != m.end() && !m["CustomAnnotations"].empty()) {
      if (typeid(vector<boost::any>) == m["CustomAnnotations"].type()) {
        vector<Tag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CustomAnnotations"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            Tag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        customAnnotations = make_shared<vector<Tag>>(expect1);
      }
    }
    if (m.find("CustomLabels") != m.end() && !m["CustomLabels"].empty()) {
      if (typeid(vector<boost::any>) == m["CustomLabels"].type()) {
        vector<Tag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CustomLabels"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            Tag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        customLabels = make_shared<vector<Tag>>(expect1);
      }
    }
    if (m.find("DataDiskSize") != m.end() && !m["DataDiskSize"].empty()) {
      dataDiskSize = make_shared<long>(boost::any_cast<long>(m["DataDiskSize"]));
    }
    if (m.find("DataDiskStorageClass") != m.end() && !m["DataDiskStorageClass"].empty()) {
      dataDiskStorageClass = make_shared<string>(boost::any_cast<string>(m["DataDiskStorageClass"]));
    }
    if (m.find("LimitCpu") != m.end() && !m["LimitCpu"].empty()) {
      limitCpu = make_shared<double>(boost::any_cast<double>(m["LimitCpu"]));
    }
    if (m.find("LimitMemory") != m.end() && !m["LimitMemory"].empty()) {
      limitMemory = make_shared<double>(boost::any_cast<double>(m["LimitMemory"]));
    }
    if (m.find("MountHostCgroup") != m.end() && !m["MountHostCgroup"].empty()) {
      mountHostCgroup = make_shared<bool>(boost::any_cast<bool>(m["MountHostCgroup"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("NodeSelectors") != m.end() && !m["NodeSelectors"].empty()) {
      if (typeid(vector<boost::any>) == m["NodeSelectors"].type()) {
        vector<Tag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NodeSelectors"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            Tag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        nodeSelectors = make_shared<vector<Tag>>(expect1);
      }
    }
    if (m.find("RequestCpu") != m.end() && !m["RequestCpu"].empty()) {
      requestCpu = make_shared<double>(boost::any_cast<double>(m["RequestCpu"]));
    }
    if (m.find("RequestMemory") != m.end() && !m["RequestMemory"].empty()) {
      requestMemory = make_shared<double>(boost::any_cast<double>(m["RequestMemory"]));
    }
    if (m.find("Tolerations") != m.end() && !m["Tolerations"].empty()) {
      if (typeid(vector<boost::any>) == m["Tolerations"].type()) {
        vector<Toleration> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tolerations"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            Toleration model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tolerations = make_shared<vector<Toleration>>(expect1);
      }
    }
  }


  virtual ~AckConfig() = default;
};
class AckNodeSelectorLabels : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  AckNodeSelectorLabels() {}

  explicit AckNodeSelectorLabels(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~AckNodeSelectorLabels() = default;
};
class AckNodeSelectorTaints : public Darabonba::Model {
public:
  shared_ptr<string> effect{};
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  AckNodeSelectorTaints() {}

  explicit AckNodeSelectorTaints(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (effect) {
      res["Effect"] = boost::any(*effect);
    }
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Effect") != m.end() && !m["Effect"].empty()) {
      effect = make_shared<string>(boost::any_cast<string>(m["Effect"]));
    }
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~AckNodeSelectorTaints() = default;
};
class AckNodeSelector : public Darabonba::Model {
public:
  shared_ptr<vector<AckNodeSelectorLabels>> labels{};
  shared_ptr<vector<AckNodeSelectorTaints>> taints{};

  AckNodeSelector() {}

  explicit AckNodeSelector(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (labels) {
      vector<boost::any> temp1;
      for(auto item1:*labels){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Labels"] = boost::any(temp1);
    }
    if (taints) {
      vector<boost::any> temp1;
      for(auto item1:*taints){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Taints"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Labels") != m.end() && !m["Labels"].empty()) {
      if (typeid(vector<boost::any>) == m["Labels"].type()) {
        vector<AckNodeSelectorLabels> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Labels"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AckNodeSelectorLabels model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        labels = make_shared<vector<AckNodeSelectorLabels>>(expect1);
      }
    }
    if (m.find("Taints") != m.end() && !m["Taints"].empty()) {
      if (typeid(vector<boost::any>) == m["Taints"].type()) {
        vector<AckNodeSelectorTaints> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Taints"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AckNodeSelectorTaints model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        taints = make_shared<vector<AckNodeSelectorTaints>>(expect1);
      }
    }
  }


  virtual ~AckNodeSelector() = default;
};
class AckNode : public Darabonba::Model {
public:
  shared_ptr<string> nodeId{};
  shared_ptr<AckNodeSelector> nodeSelector{};

  AckNode() {}

  explicit AckNode(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (nodeSelector) {
      res["NodeSelector"] = nodeSelector ? boost::any(nodeSelector->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<string>(boost::any_cast<string>(m["NodeId"]));
    }
    if (m.find("NodeSelector") != m.end() && !m["NodeSelector"].empty()) {
      if (typeid(map<string, boost::any>) == m["NodeSelector"].type()) {
        AckNodeSelector model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NodeSelector"]));
        nodeSelector = make_shared<AckNodeSelector>(model1);
      }
    }
  }


  virtual ~AckNode() = default;
};
class AckNodePool : public Darabonba::Model {
public:
  shared_ptr<string> nodePoolId{};
  shared_ptr<AckNodeSelector> nodeSelector{};

  AckNodePool() {}

  explicit AckNodePool(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nodePoolId) {
      res["NodePoolId"] = boost::any(*nodePoolId);
    }
    if (nodeSelector) {
      res["NodeSelector"] = nodeSelector ? boost::any(nodeSelector->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NodePoolId") != m.end() && !m["NodePoolId"].empty()) {
      nodePoolId = make_shared<string>(boost::any_cast<string>(m["NodePoolId"]));
    }
    if (m.find("NodeSelector") != m.end() && !m["NodeSelector"].empty()) {
      if (typeid(map<string, boost::any>) == m["NodeSelector"].type()) {
        AckNodeSelector model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NodeSelector"]));
        nodeSelector = make_shared<AckNodeSelector>(model1);
      }
    }
  }


  virtual ~AckNodePool() = default;
};
class ApiTemplate : public Darabonba::Model {
public:
  shared_ptr<string> apiName{};
  shared_ptr<string> content{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> status{};
  shared_ptr<string> templateId{};
  shared_ptr<string> templateName{};

  ApiTemplate() {}

  explicit ApiTemplate(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiName) {
      res["ApiName"] = boost::any(*apiName);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (templateName) {
      res["TemplateName"] = boost::any(*templateName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiName") != m.end() && !m["ApiName"].empty()) {
      apiName = make_shared<string>(boost::any_cast<string>(m["ApiName"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("TemplateName") != m.end() && !m["TemplateName"].empty()) {
      templateName = make_shared<string>(boost::any_cast<string>(m["TemplateName"]));
    }
  }


  virtual ~ApiTemplate() = default;
};
class Application : public Darabonba::Model {
public:
  shared_ptr<string> applicationName{};

  Application() {}

  explicit Application(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applicationName) {
      res["ApplicationName"] = boost::any(*applicationName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApplicationName") != m.end() && !m["ApplicationName"].empty()) {
      applicationName = make_shared<string>(boost::any_cast<string>(m["ApplicationName"]));
    }
  }


  virtual ~Application() = default;
};
class ApplicationConfig : public Darabonba::Model {
public:
  shared_ptr<string> applicationName{};
  shared_ptr<string> configFileName{};
  shared_ptr<string> configItemKey{};
  shared_ptr<string> configItemValue{};
  shared_ptr<string> configScope{};
  shared_ptr<string> nodeGroupId{};
  shared_ptr<string> nodeGroupName{};

  ApplicationConfig() {}

  explicit ApplicationConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applicationName) {
      res["ApplicationName"] = boost::any(*applicationName);
    }
    if (configFileName) {
      res["ConfigFileName"] = boost::any(*configFileName);
    }
    if (configItemKey) {
      res["ConfigItemKey"] = boost::any(*configItemKey);
    }
    if (configItemValue) {
      res["ConfigItemValue"] = boost::any(*configItemValue);
    }
    if (configScope) {
      res["ConfigScope"] = boost::any(*configScope);
    }
    if (nodeGroupId) {
      res["NodeGroupId"] = boost::any(*nodeGroupId);
    }
    if (nodeGroupName) {
      res["NodeGroupName"] = boost::any(*nodeGroupName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApplicationName") != m.end() && !m["ApplicationName"].empty()) {
      applicationName = make_shared<string>(boost::any_cast<string>(m["ApplicationName"]));
    }
    if (m.find("ConfigFileName") != m.end() && !m["ConfigFileName"].empty()) {
      configFileName = make_shared<string>(boost::any_cast<string>(m["ConfigFileName"]));
    }
    if (m.find("ConfigItemKey") != m.end() && !m["ConfigItemKey"].empty()) {
      configItemKey = make_shared<string>(boost::any_cast<string>(m["ConfigItemKey"]));
    }
    if (m.find("ConfigItemValue") != m.end() && !m["ConfigItemValue"].empty()) {
      configItemValue = make_shared<string>(boost::any_cast<string>(m["ConfigItemValue"]));
    }
    if (m.find("ConfigScope") != m.end() && !m["ConfigScope"].empty()) {
      configScope = make_shared<string>(boost::any_cast<string>(m["ConfigScope"]));
    }
    if (m.find("NodeGroupId") != m.end() && !m["NodeGroupId"].empty()) {
      nodeGroupId = make_shared<string>(boost::any_cast<string>(m["NodeGroupId"]));
    }
    if (m.find("NodeGroupName") != m.end() && !m["NodeGroupName"].empty()) {
      nodeGroupName = make_shared<string>(boost::any_cast<string>(m["NodeGroupName"]));
    }
  }


  virtual ~ApplicationConfig() = default;
};
class ApplicationConfigFile : public Darabonba::Model {
public:
  shared_ptr<string> applicationName{};
  shared_ptr<string> configFileName{};

  ApplicationConfigFile() {}

  explicit ApplicationConfigFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applicationName) {
      res["ApplicationName"] = boost::any(*applicationName);
    }
    if (configFileName) {
      res["ConfigFileName"] = boost::any(*configFileName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApplicationName") != m.end() && !m["ApplicationName"].empty()) {
      applicationName = make_shared<string>(boost::any_cast<string>(m["ApplicationName"]));
    }
    if (m.find("ConfigFileName") != m.end() && !m["ConfigFileName"].empty()) {
      configFileName = make_shared<string>(boost::any_cast<string>(m["ConfigFileName"]));
    }
  }


  virtual ~ApplicationConfigFile() = default;
};
class ApplicationConfigParam : public Darabonba::Model {
public:
  shared_ptr<string> configAction{};
  shared_ptr<string> configFileName{};
  shared_ptr<string> configItemDescription{};
  shared_ptr<string> configItemKey{};
  shared_ptr<string> configItemValue{};
  shared_ptr<string> configScope{};
  shared_ptr<string> effectiveActions{};
  shared_ptr<string> effectiveType{};
  shared_ptr<string> nodeGroupId{};
  shared_ptr<string> nodeId{};

  ApplicationConfigParam() {}

  explicit ApplicationConfigParam(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configAction) {
      res["ConfigAction"] = boost::any(*configAction);
    }
    if (configFileName) {
      res["ConfigFileName"] = boost::any(*configFileName);
    }
    if (configItemDescription) {
      res["ConfigItemDescription"] = boost::any(*configItemDescription);
    }
    if (configItemKey) {
      res["ConfigItemKey"] = boost::any(*configItemKey);
    }
    if (configItemValue) {
      res["ConfigItemValue"] = boost::any(*configItemValue);
    }
    if (configScope) {
      res["ConfigScope"] = boost::any(*configScope);
    }
    if (effectiveActions) {
      res["EffectiveActions"] = boost::any(*effectiveActions);
    }
    if (effectiveType) {
      res["EffectiveType"] = boost::any(*effectiveType);
    }
    if (nodeGroupId) {
      res["NodeGroupId"] = boost::any(*nodeGroupId);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigAction") != m.end() && !m["ConfigAction"].empty()) {
      configAction = make_shared<string>(boost::any_cast<string>(m["ConfigAction"]));
    }
    if (m.find("ConfigFileName") != m.end() && !m["ConfigFileName"].empty()) {
      configFileName = make_shared<string>(boost::any_cast<string>(m["ConfigFileName"]));
    }
    if (m.find("ConfigItemDescription") != m.end() && !m["ConfigItemDescription"].empty()) {
      configItemDescription = make_shared<string>(boost::any_cast<string>(m["ConfigItemDescription"]));
    }
    if (m.find("ConfigItemKey") != m.end() && !m["ConfigItemKey"].empty()) {
      configItemKey = make_shared<string>(boost::any_cast<string>(m["ConfigItemKey"]));
    }
    if (m.find("ConfigItemValue") != m.end() && !m["ConfigItemValue"].empty()) {
      configItemValue = make_shared<string>(boost::any_cast<string>(m["ConfigItemValue"]));
    }
    if (m.find("ConfigScope") != m.end() && !m["ConfigScope"].empty()) {
      configScope = make_shared<string>(boost::any_cast<string>(m["ConfigScope"]));
    }
    if (m.find("EffectiveActions") != m.end() && !m["EffectiveActions"].empty()) {
      effectiveActions = make_shared<string>(boost::any_cast<string>(m["EffectiveActions"]));
    }
    if (m.find("EffectiveType") != m.end() && !m["EffectiveType"].empty()) {
      effectiveType = make_shared<string>(boost::any_cast<string>(m["EffectiveType"]));
    }
    if (m.find("NodeGroupId") != m.end() && !m["NodeGroupId"].empty()) {
      nodeGroupId = make_shared<string>(boost::any_cast<string>(m["NodeGroupId"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<string>(boost::any_cast<string>(m["NodeId"]));
    }
  }


  virtual ~ApplicationConfigParam() = default;
};
class Attribute : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  Attribute() {}

  explicit Attribute(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~Attribute() = default;
};
class AutoRenewInstance : public Darabonba::Model {
public:
  shared_ptr<bool> autoRenew{};
  shared_ptr<long> autoRenewDuration{};
  shared_ptr<string> autoRenewDurationUnit{};
  shared_ptr<long> emrAutoRenewDuration{};
  shared_ptr<string> emrAutoRenewDurationUnit{};
  shared_ptr<string> instanceId{};

  AutoRenewInstance() {}

  explicit AutoRenewInstance(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoRenew) {
      res["AutoRenew"] = boost::any(*autoRenew);
    }
    if (autoRenewDuration) {
      res["AutoRenewDuration"] = boost::any(*autoRenewDuration);
    }
    if (autoRenewDurationUnit) {
      res["AutoRenewDurationUnit"] = boost::any(*autoRenewDurationUnit);
    }
    if (emrAutoRenewDuration) {
      res["EmrAutoRenewDuration"] = boost::any(*emrAutoRenewDuration);
    }
    if (emrAutoRenewDurationUnit) {
      res["EmrAutoRenewDurationUnit"] = boost::any(*emrAutoRenewDurationUnit);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AutoRenew") != m.end() && !m["AutoRenew"].empty()) {
      autoRenew = make_shared<bool>(boost::any_cast<bool>(m["AutoRenew"]));
    }
    if (m.find("AutoRenewDuration") != m.end() && !m["AutoRenewDuration"].empty()) {
      autoRenewDuration = make_shared<long>(boost::any_cast<long>(m["AutoRenewDuration"]));
    }
    if (m.find("AutoRenewDurationUnit") != m.end() && !m["AutoRenewDurationUnit"].empty()) {
      autoRenewDurationUnit = make_shared<string>(boost::any_cast<string>(m["AutoRenewDurationUnit"]));
    }
    if (m.find("EmrAutoRenewDuration") != m.end() && !m["EmrAutoRenewDuration"].empty()) {
      emrAutoRenewDuration = make_shared<long>(boost::any_cast<long>(m["EmrAutoRenewDuration"]));
    }
    if (m.find("EmrAutoRenewDurationUnit") != m.end() && !m["EmrAutoRenewDurationUnit"].empty()) {
      emrAutoRenewDurationUnit = make_shared<string>(boost::any_cast<string>(m["EmrAutoRenewDurationUnit"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~AutoRenewInstance() = default;
};
class AutoRenewInstanceParam : public Darabonba::Model {
public:
  shared_ptr<string> autoRenew{};
  shared_ptr<string> autoRenewDuration{};
  shared_ptr<string> autoRenewDurationUnit{};
  shared_ptr<string> instanceId{};

  AutoRenewInstanceParam() {}

  explicit AutoRenewInstanceParam(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoRenew) {
      res["AutoRenew"] = boost::any(*autoRenew);
    }
    if (autoRenewDuration) {
      res["AutoRenewDuration"] = boost::any(*autoRenewDuration);
    }
    if (autoRenewDurationUnit) {
      res["AutoRenewDurationUnit"] = boost::any(*autoRenewDurationUnit);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AutoRenew") != m.end() && !m["AutoRenew"].empty()) {
      autoRenew = make_shared<string>(boost::any_cast<string>(m["AutoRenew"]));
    }
    if (m.find("AutoRenewDuration") != m.end() && !m["AutoRenewDuration"].empty()) {
      autoRenewDuration = make_shared<string>(boost::any_cast<string>(m["AutoRenewDuration"]));
    }
    if (m.find("AutoRenewDurationUnit") != m.end() && !m["AutoRenewDurationUnit"].empty()) {
      autoRenewDurationUnit = make_shared<string>(boost::any_cast<string>(m["AutoRenewDurationUnit"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~AutoRenewInstanceParam() = default;
};
class AutoScalingConstraintsSupportMetricTags : public Darabonba::Model {
public:
  shared_ptr<string> metricName{};
  shared_ptr<vector<Tag>> tags{};

  AutoScalingConstraintsSupportMetricTags() {}

  explicit AutoScalingConstraintsSupportMetricTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (metricName) {
      res["MetricName"] = boost::any(*metricName);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MetricName") != m.end() && !m["MetricName"].empty()) {
      metricName = make_shared<string>(boost::any_cast<string>(m["MetricName"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<Tag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            Tag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<Tag>>(expect1);
      }
    }
  }


  virtual ~AutoScalingConstraintsSupportMetricTags() = default;
};
class MetricUnitValue : public Darabonba::Model {
public:
  shared_ptr<string> metricName{};
  shared_ptr<string> metricUnit{};

  MetricUnitValue() {}

  explicit MetricUnitValue(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (metricName) {
      res["MetricName"] = boost::any(*metricName);
    }
    if (metricUnit) {
      res["MetricUnit"] = boost::any(*metricUnit);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MetricName") != m.end() && !m["MetricName"].empty()) {
      metricName = make_shared<string>(boost::any_cast<string>(m["MetricName"]));
    }
    if (m.find("MetricUnit") != m.end() && !m["MetricUnit"].empty()) {
      metricUnit = make_shared<string>(boost::any_cast<string>(m["MetricUnit"]));
    }
  }


  virtual ~MetricUnitValue() = default;
};
class TriggerCondition : public Darabonba::Model {
public:
  shared_ptr<string> comparisonOperator{};
  shared_ptr<string> metricName{};
  shared_ptr<string> statistics{};
  shared_ptr<vector<Tag>> tags{};
  shared_ptr<double> threshold{};

  TriggerCondition() {}

  explicit TriggerCondition(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (comparisonOperator) {
      res["ComparisonOperator"] = boost::any(*comparisonOperator);
    }
    if (metricName) {
      res["MetricName"] = boost::any(*metricName);
    }
    if (statistics) {
      res["Statistics"] = boost::any(*statistics);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    if (threshold) {
      res["Threshold"] = boost::any(*threshold);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ComparisonOperator") != m.end() && !m["ComparisonOperator"].empty()) {
      comparisonOperator = make_shared<string>(boost::any_cast<string>(m["ComparisonOperator"]));
    }
    if (m.find("MetricName") != m.end() && !m["MetricName"].empty()) {
      metricName = make_shared<string>(boost::any_cast<string>(m["MetricName"]));
    }
    if (m.find("Statistics") != m.end() && !m["Statistics"].empty()) {
      statistics = make_shared<string>(boost::any_cast<string>(m["Statistics"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<Tag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            Tag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<Tag>>(expect1);
      }
    }
    if (m.find("Threshold") != m.end() && !m["Threshold"].empty()) {
      threshold = make_shared<double>(boost::any_cast<double>(m["Threshold"]));
    }
  }


  virtual ~TriggerCondition() = default;
};
class TimeConstraint : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<string> startTime{};

  TimeConstraint() {}

  explicit TimeConstraint(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~TimeConstraint() = default;
};
class MetricsTrigger : public Darabonba::Model {
public:
  shared_ptr<string> conditionLogicOperator{};
  shared_ptr<vector<TriggerCondition>> conditions{};
  shared_ptr<long> coolDownInterval{};
  shared_ptr<long> evaluationCount{};
  shared_ptr<vector<TimeConstraint>> timeConstraints{};
  shared_ptr<long> timeWindow{};

  MetricsTrigger() {}

  explicit MetricsTrigger(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (conditionLogicOperator) {
      res["ConditionLogicOperator"] = boost::any(*conditionLogicOperator);
    }
    if (conditions) {
      vector<boost::any> temp1;
      for(auto item1:*conditions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Conditions"] = boost::any(temp1);
    }
    if (coolDownInterval) {
      res["CoolDownInterval"] = boost::any(*coolDownInterval);
    }
    if (evaluationCount) {
      res["EvaluationCount"] = boost::any(*evaluationCount);
    }
    if (timeConstraints) {
      vector<boost::any> temp1;
      for(auto item1:*timeConstraints){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TimeConstraints"] = boost::any(temp1);
    }
    if (timeWindow) {
      res["TimeWindow"] = boost::any(*timeWindow);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConditionLogicOperator") != m.end() && !m["ConditionLogicOperator"].empty()) {
      conditionLogicOperator = make_shared<string>(boost::any_cast<string>(m["ConditionLogicOperator"]));
    }
    if (m.find("Conditions") != m.end() && !m["Conditions"].empty()) {
      if (typeid(vector<boost::any>) == m["Conditions"].type()) {
        vector<TriggerCondition> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Conditions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            TriggerCondition model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        conditions = make_shared<vector<TriggerCondition>>(expect1);
      }
    }
    if (m.find("CoolDownInterval") != m.end() && !m["CoolDownInterval"].empty()) {
      coolDownInterval = make_shared<long>(boost::any_cast<long>(m["CoolDownInterval"]));
    }
    if (m.find("EvaluationCount") != m.end() && !m["EvaluationCount"].empty()) {
      evaluationCount = make_shared<long>(boost::any_cast<long>(m["EvaluationCount"]));
    }
    if (m.find("TimeConstraints") != m.end() && !m["TimeConstraints"].empty()) {
      if (typeid(vector<boost::any>) == m["TimeConstraints"].type()) {
        vector<TimeConstraint> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TimeConstraints"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            TimeConstraint model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        timeConstraints = make_shared<vector<TimeConstraint>>(expect1);
      }
    }
    if (m.find("TimeWindow") != m.end() && !m["TimeWindow"].empty()) {
      timeWindow = make_shared<long>(boost::any_cast<long>(m["TimeWindow"]));
    }
  }


  virtual ~MetricsTrigger() = default;
};
class TimeTrigger : public Darabonba::Model {
public:
  shared_ptr<long> endTime{};
  shared_ptr<long> launchExpirationTime{};
  shared_ptr<string> launchTime{};
  shared_ptr<string> recurrenceType{};
  shared_ptr<string> recurrenceValue{};
  shared_ptr<long> startTime{};

  TimeTrigger() {}

  explicit TimeTrigger(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (launchExpirationTime) {
      res["LaunchExpirationTime"] = boost::any(*launchExpirationTime);
    }
    if (launchTime) {
      res["LaunchTime"] = boost::any(*launchTime);
    }
    if (recurrenceType) {
      res["RecurrenceType"] = boost::any(*recurrenceType);
    }
    if (recurrenceValue) {
      res["RecurrenceValue"] = boost::any(*recurrenceValue);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("LaunchExpirationTime") != m.end() && !m["LaunchExpirationTime"].empty()) {
      launchExpirationTime = make_shared<long>(boost::any_cast<long>(m["LaunchExpirationTime"]));
    }
    if (m.find("LaunchTime") != m.end() && !m["LaunchTime"].empty()) {
      launchTime = make_shared<string>(boost::any_cast<string>(m["LaunchTime"]));
    }
    if (m.find("RecurrenceType") != m.end() && !m["RecurrenceType"].empty()) {
      recurrenceType = make_shared<string>(boost::any_cast<string>(m["RecurrenceType"]));
    }
    if (m.find("RecurrenceValue") != m.end() && !m["RecurrenceValue"].empty()) {
      recurrenceValue = make_shared<string>(boost::any_cast<string>(m["RecurrenceValue"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
  }


  virtual ~TimeTrigger() = default;
};
class ScalingRule : public Darabonba::Model {
public:
  shared_ptr<string> activityType{};
  shared_ptr<long> adjustmentValue{};
  shared_ptr<MetricsTrigger> metricsTrigger{};
  shared_ptr<string> ruleName{};
  shared_ptr<TimeTrigger> timeTrigger{};
  shared_ptr<string> triggerType{};

  ScalingRule() {}

  explicit ScalingRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (activityType) {
      res["ActivityType"] = boost::any(*activityType);
    }
    if (adjustmentValue) {
      res["AdjustmentValue"] = boost::any(*adjustmentValue);
    }
    if (metricsTrigger) {
      res["MetricsTrigger"] = metricsTrigger ? boost::any(metricsTrigger->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    if (timeTrigger) {
      res["TimeTrigger"] = timeTrigger ? boost::any(timeTrigger->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (triggerType) {
      res["TriggerType"] = boost::any(*triggerType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActivityType") != m.end() && !m["ActivityType"].empty()) {
      activityType = make_shared<string>(boost::any_cast<string>(m["ActivityType"]));
    }
    if (m.find("AdjustmentValue") != m.end() && !m["AdjustmentValue"].empty()) {
      adjustmentValue = make_shared<long>(boost::any_cast<long>(m["AdjustmentValue"]));
    }
    if (m.find("MetricsTrigger") != m.end() && !m["MetricsTrigger"].empty()) {
      if (typeid(map<string, boost::any>) == m["MetricsTrigger"].type()) {
        MetricsTrigger model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MetricsTrigger"]));
        metricsTrigger = make_shared<MetricsTrigger>(model1);
      }
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
    if (m.find("TimeTrigger") != m.end() && !m["TimeTrigger"].empty()) {
      if (typeid(map<string, boost::any>) == m["TimeTrigger"].type()) {
        TimeTrigger model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TimeTrigger"]));
        timeTrigger = make_shared<TimeTrigger>(model1);
      }
    }
    if (m.find("TriggerType") != m.end() && !m["TriggerType"].empty()) {
      triggerType = make_shared<string>(boost::any_cast<string>(m["TriggerType"]));
    }
  }


  virtual ~ScalingRule() = default;
};
class AutoScalingConstraints : public Darabonba::Model {
public:
  shared_ptr<vector<MetricUnitValue>> autoScalingMetricUnits{};
  shared_ptr<vector<ScalingRule>> defaultMetricTriggeredRules{};
  shared_ptr<long> maxAdjustmentValue{};
  shared_ptr<long> maxByLoadRuleCount{};
  shared_ptr<long> maxByTimeRuleCount{};
  shared_ptr<vector<AutoScalingConstraintsSupportMetricTags>> supportMetricTags{};
  shared_ptr<vector<string>> supportMetrics{};
  shared_ptr<vector<string>> supportRuleTypes{};

  AutoScalingConstraints() {}

  explicit AutoScalingConstraints(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoScalingMetricUnits) {
      vector<boost::any> temp1;
      for(auto item1:*autoScalingMetricUnits){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AutoScalingMetricUnits"] = boost::any(temp1);
    }
    if (defaultMetricTriggeredRules) {
      vector<boost::any> temp1;
      for(auto item1:*defaultMetricTriggeredRules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DefaultMetricTriggeredRules"] = boost::any(temp1);
    }
    if (maxAdjustmentValue) {
      res["MaxAdjustmentValue"] = boost::any(*maxAdjustmentValue);
    }
    if (maxByLoadRuleCount) {
      res["MaxByLoadRuleCount"] = boost::any(*maxByLoadRuleCount);
    }
    if (maxByTimeRuleCount) {
      res["MaxByTimeRuleCount"] = boost::any(*maxByTimeRuleCount);
    }
    if (supportMetricTags) {
      vector<boost::any> temp1;
      for(auto item1:*supportMetricTags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SupportMetricTags"] = boost::any(temp1);
    }
    if (supportMetrics) {
      res["SupportMetrics"] = boost::any(*supportMetrics);
    }
    if (supportRuleTypes) {
      res["SupportRuleTypes"] = boost::any(*supportRuleTypes);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AutoScalingMetricUnits") != m.end() && !m["AutoScalingMetricUnits"].empty()) {
      if (typeid(vector<boost::any>) == m["AutoScalingMetricUnits"].type()) {
        vector<MetricUnitValue> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AutoScalingMetricUnits"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            MetricUnitValue model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        autoScalingMetricUnits = make_shared<vector<MetricUnitValue>>(expect1);
      }
    }
    if (m.find("DefaultMetricTriggeredRules") != m.end() && !m["DefaultMetricTriggeredRules"].empty()) {
      if (typeid(vector<boost::any>) == m["DefaultMetricTriggeredRules"].type()) {
        vector<ScalingRule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DefaultMetricTriggeredRules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ScalingRule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        defaultMetricTriggeredRules = make_shared<vector<ScalingRule>>(expect1);
      }
    }
    if (m.find("MaxAdjustmentValue") != m.end() && !m["MaxAdjustmentValue"].empty()) {
      maxAdjustmentValue = make_shared<long>(boost::any_cast<long>(m["MaxAdjustmentValue"]));
    }
    if (m.find("MaxByLoadRuleCount") != m.end() && !m["MaxByLoadRuleCount"].empty()) {
      maxByLoadRuleCount = make_shared<long>(boost::any_cast<long>(m["MaxByLoadRuleCount"]));
    }
    if (m.find("MaxByTimeRuleCount") != m.end() && !m["MaxByTimeRuleCount"].empty()) {
      maxByTimeRuleCount = make_shared<long>(boost::any_cast<long>(m["MaxByTimeRuleCount"]));
    }
    if (m.find("SupportMetricTags") != m.end() && !m["SupportMetricTags"].empty()) {
      if (typeid(vector<boost::any>) == m["SupportMetricTags"].type()) {
        vector<AutoScalingConstraintsSupportMetricTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SupportMetricTags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AutoScalingConstraintsSupportMetricTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        supportMetricTags = make_shared<vector<AutoScalingConstraintsSupportMetricTags>>(expect1);
      }
    }
    if (m.find("SupportMetrics") != m.end() && !m["SupportMetrics"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SupportMetrics"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SupportMetrics"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      supportMetrics = make_shared<vector<string>>(toVec1);
    }
    if (m.find("SupportRuleTypes") != m.end() && !m["SupportRuleTypes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SupportRuleTypes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SupportRuleTypes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      supportRuleTypes = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~AutoScalingConstraints() = default;
};
class AutoScalingPolicyConstraints : public Darabonba::Model {
public:
  shared_ptr<long> maxCapacity{};
  shared_ptr<long> minCapacity{};

  AutoScalingPolicyConstraints() {}

  explicit AutoScalingPolicyConstraints(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxCapacity) {
      res["maxCapacity"] = boost::any(*maxCapacity);
    }
    if (minCapacity) {
      res["minCapacity"] = boost::any(*minCapacity);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("maxCapacity") != m.end() && !m["maxCapacity"].empty()) {
      maxCapacity = make_shared<long>(boost::any_cast<long>(m["maxCapacity"]));
    }
    if (m.find("minCapacity") != m.end() && !m["minCapacity"].empty()) {
      minCapacity = make_shared<long>(boost::any_cast<long>(m["minCapacity"]));
    }
  }


  virtual ~AutoScalingPolicyConstraints() = default;
};
class AutoScalingPolicy : public Darabonba::Model {
public:
  shared_ptr<AutoScalingPolicyConstraints> constraints{};
  shared_ptr<vector<ScalingRule>> scalingRules{};

  AutoScalingPolicy() {}

  explicit AutoScalingPolicy(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (constraints) {
      res["constraints"] = constraints ? boost::any(constraints->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (scalingRules) {
      vector<boost::any> temp1;
      for(auto item1:*scalingRules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["scalingRules"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("constraints") != m.end() && !m["constraints"].empty()) {
      if (typeid(map<string, boost::any>) == m["constraints"].type()) {
        AutoScalingPolicyConstraints model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["constraints"]));
        constraints = make_shared<AutoScalingPolicyConstraints>(model1);
      }
    }
    if (m.find("scalingRules") != m.end() && !m["scalingRules"].empty()) {
      if (typeid(vector<boost::any>) == m["scalingRules"].type()) {
        vector<ScalingRule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["scalingRules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ScalingRule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        scalingRules = make_shared<vector<ScalingRule>>(expect1);
      }
    }
  }


  virtual ~AutoScalingPolicy() = default;
};
class ByLoadScalingRule : public Darabonba::Model {
public:
  shared_ptr<string> comparisonOperator{};
  shared_ptr<long> coolDownInterval{};
  shared_ptr<long> evaluationCount{};
  shared_ptr<string> metricName{};
  shared_ptr<string> statistics{};
  shared_ptr<double> threshold{};
  shared_ptr<long> timeWindow{};

  ByLoadScalingRule() {}

  explicit ByLoadScalingRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (comparisonOperator) {
      res["ComparisonOperator"] = boost::any(*comparisonOperator);
    }
    if (coolDownInterval) {
      res["CoolDownInterval"] = boost::any(*coolDownInterval);
    }
    if (evaluationCount) {
      res["EvaluationCount"] = boost::any(*evaluationCount);
    }
    if (metricName) {
      res["MetricName"] = boost::any(*metricName);
    }
    if (statistics) {
      res["Statistics"] = boost::any(*statistics);
    }
    if (threshold) {
      res["Threshold"] = boost::any(*threshold);
    }
    if (timeWindow) {
      res["TimeWindow"] = boost::any(*timeWindow);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ComparisonOperator") != m.end() && !m["ComparisonOperator"].empty()) {
      comparisonOperator = make_shared<string>(boost::any_cast<string>(m["ComparisonOperator"]));
    }
    if (m.find("CoolDownInterval") != m.end() && !m["CoolDownInterval"].empty()) {
      coolDownInterval = make_shared<long>(boost::any_cast<long>(m["CoolDownInterval"]));
    }
    if (m.find("EvaluationCount") != m.end() && !m["EvaluationCount"].empty()) {
      evaluationCount = make_shared<long>(boost::any_cast<long>(m["EvaluationCount"]));
    }
    if (m.find("MetricName") != m.end() && !m["MetricName"].empty()) {
      metricName = make_shared<string>(boost::any_cast<string>(m["MetricName"]));
    }
    if (m.find("Statistics") != m.end() && !m["Statistics"].empty()) {
      statistics = make_shared<string>(boost::any_cast<string>(m["Statistics"]));
    }
    if (m.find("Threshold") != m.end() && !m["Threshold"].empty()) {
      threshold = make_shared<double>(boost::any_cast<double>(m["Threshold"]));
    }
    if (m.find("TimeWindow") != m.end() && !m["TimeWindow"].empty()) {
      timeWindow = make_shared<long>(boost::any_cast<long>(m["TimeWindow"]));
    }
  }


  virtual ~ByLoadScalingRule() = default;
};
class ByLoadScalingRuleSpec : public Darabonba::Model {
public:
  shared_ptr<string> comparisonOperator{};
  shared_ptr<long> evaluationCount{};
  shared_ptr<string> metricName{};
  shared_ptr<string> statistics{};
  shared_ptr<double> threshold{};
  shared_ptr<long> timeWindow{};

  ByLoadScalingRuleSpec() {}

  explicit ByLoadScalingRuleSpec(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (comparisonOperator) {
      res["ComparisonOperator"] = boost::any(*comparisonOperator);
    }
    if (evaluationCount) {
      res["EvaluationCount"] = boost::any(*evaluationCount);
    }
    if (metricName) {
      res["MetricName"] = boost::any(*metricName);
    }
    if (statistics) {
      res["Statistics"] = boost::any(*statistics);
    }
    if (threshold) {
      res["Threshold"] = boost::any(*threshold);
    }
    if (timeWindow) {
      res["TimeWindow"] = boost::any(*timeWindow);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ComparisonOperator") != m.end() && !m["ComparisonOperator"].empty()) {
      comparisonOperator = make_shared<string>(boost::any_cast<string>(m["ComparisonOperator"]));
    }
    if (m.find("EvaluationCount") != m.end() && !m["EvaluationCount"].empty()) {
      evaluationCount = make_shared<long>(boost::any_cast<long>(m["EvaluationCount"]));
    }
    if (m.find("MetricName") != m.end() && !m["MetricName"].empty()) {
      metricName = make_shared<string>(boost::any_cast<string>(m["MetricName"]));
    }
    if (m.find("Statistics") != m.end() && !m["Statistics"].empty()) {
      statistics = make_shared<string>(boost::any_cast<string>(m["Statistics"]));
    }
    if (m.find("Threshold") != m.end() && !m["Threshold"].empty()) {
      threshold = make_shared<double>(boost::any_cast<double>(m["Threshold"]));
    }
    if (m.find("TimeWindow") != m.end() && !m["TimeWindow"].empty()) {
      timeWindow = make_shared<long>(boost::any_cast<long>(m["TimeWindow"]));
    }
  }


  virtual ~ByLoadScalingRuleSpec() = default;
};
class ByTimeScalingRule : public Darabonba::Model {
public:
  shared_ptr<long> endTime{};
  shared_ptr<long> launchExpirationTime{};
  shared_ptr<long> launchTime{};
  shared_ptr<string> recurrenceType{};
  shared_ptr<string> recurrenceValue{};

  ByTimeScalingRule() {}

  explicit ByTimeScalingRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (launchExpirationTime) {
      res["LaunchExpirationTime"] = boost::any(*launchExpirationTime);
    }
    if (launchTime) {
      res["LaunchTime"] = boost::any(*launchTime);
    }
    if (recurrenceType) {
      res["RecurrenceType"] = boost::any(*recurrenceType);
    }
    if (recurrenceValue) {
      res["RecurrenceValue"] = boost::any(*recurrenceValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("LaunchExpirationTime") != m.end() && !m["LaunchExpirationTime"].empty()) {
      launchExpirationTime = make_shared<long>(boost::any_cast<long>(m["LaunchExpirationTime"]));
    }
    if (m.find("LaunchTime") != m.end() && !m["LaunchTime"].empty()) {
      launchTime = make_shared<long>(boost::any_cast<long>(m["LaunchTime"]));
    }
    if (m.find("RecurrenceType") != m.end() && !m["RecurrenceType"].empty()) {
      recurrenceType = make_shared<string>(boost::any_cast<string>(m["RecurrenceType"]));
    }
    if (m.find("RecurrenceValue") != m.end() && !m["RecurrenceValue"].empty()) {
      recurrenceValue = make_shared<string>(boost::any_cast<string>(m["RecurrenceValue"]));
    }
  }


  virtual ~ByTimeScalingRule() = default;
};
class ByTimeScalingRuleSpec : public Darabonba::Model {
public:
  shared_ptr<long> endTime{};
  shared_ptr<long> launchTime{};
  shared_ptr<string> recurrenceType{};
  shared_ptr<string> recurrenceValue{};

  ByTimeScalingRuleSpec() {}

  explicit ByTimeScalingRuleSpec(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (launchTime) {
      res["LaunchTime"] = boost::any(*launchTime);
    }
    if (recurrenceType) {
      res["RecurrenceType"] = boost::any(*recurrenceType);
    }
    if (recurrenceValue) {
      res["RecurrenceValue"] = boost::any(*recurrenceValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("LaunchTime") != m.end() && !m["LaunchTime"].empty()) {
      launchTime = make_shared<long>(boost::any_cast<long>(m["LaunchTime"]));
    }
    if (m.find("RecurrenceType") != m.end() && !m["RecurrenceType"].empty()) {
      recurrenceType = make_shared<string>(boost::any_cast<string>(m["RecurrenceType"]));
    }
    if (m.find("RecurrenceValue") != m.end() && !m["RecurrenceValue"].empty()) {
      recurrenceValue = make_shared<string>(boost::any_cast<string>(m["RecurrenceValue"]));
    }
  }


  virtual ~ByTimeScalingRuleSpec() = default;
};
class ClickhouseConf : public Darabonba::Model {
public:
  shared_ptr<long> initialReplica{};
  shared_ptr<long> initialShard{};
  shared_ptr<long> newNodeCount{};
  shared_ptr<string> resizeType{};

  ClickhouseConf() {}

  explicit ClickhouseConf(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (initialReplica) {
      res["InitialReplica"] = boost::any(*initialReplica);
    }
    if (initialShard) {
      res["InitialShard"] = boost::any(*initialShard);
    }
    if (newNodeCount) {
      res["NewNodeCount"] = boost::any(*newNodeCount);
    }
    if (resizeType) {
      res["ResizeType"] = boost::any(*resizeType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InitialReplica") != m.end() && !m["InitialReplica"].empty()) {
      initialReplica = make_shared<long>(boost::any_cast<long>(m["InitialReplica"]));
    }
    if (m.find("InitialShard") != m.end() && !m["InitialShard"].empty()) {
      initialShard = make_shared<long>(boost::any_cast<long>(m["InitialShard"]));
    }
    if (m.find("NewNodeCount") != m.end() && !m["NewNodeCount"].empty()) {
      newNodeCount = make_shared<long>(boost::any_cast<long>(m["NewNodeCount"]));
    }
    if (m.find("ResizeType") != m.end() && !m["ResizeType"].empty()) {
      resizeType = make_shared<string>(boost::any_cast<string>(m["ResizeType"]));
    }
  }


  virtual ~ClickhouseConf() = default;
};
class NodeAttributes : public Darabonba::Model {
public:
  shared_ptr<string> keyPairName{};
  shared_ptr<string> masterRootPassword{};
  shared_ptr<string> ramRole{};
  shared_ptr<string> securityGroupId{};
  shared_ptr<string> vpcId{};
  shared_ptr<string> zoneId{};

  NodeAttributes() {}

  explicit NodeAttributes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (keyPairName) {
      res["KeyPairName"] = boost::any(*keyPairName);
    }
    if (masterRootPassword) {
      res["MasterRootPassword"] = boost::any(*masterRootPassword);
    }
    if (ramRole) {
      res["RamRole"] = boost::any(*ramRole);
    }
    if (securityGroupId) {
      res["SecurityGroupId"] = boost::any(*securityGroupId);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("KeyPairName") != m.end() && !m["KeyPairName"].empty()) {
      keyPairName = make_shared<string>(boost::any_cast<string>(m["KeyPairName"]));
    }
    if (m.find("MasterRootPassword") != m.end() && !m["MasterRootPassword"].empty()) {
      masterRootPassword = make_shared<string>(boost::any_cast<string>(m["MasterRootPassword"]));
    }
    if (m.find("RamRole") != m.end() && !m["RamRole"].empty()) {
      ramRole = make_shared<string>(boost::any_cast<string>(m["RamRole"]));
    }
    if (m.find("SecurityGroupId") != m.end() && !m["SecurityGroupId"].empty()) {
      securityGroupId = make_shared<string>(boost::any_cast<string>(m["SecurityGroupId"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
  }


  virtual ~NodeAttributes() = default;
};
class ClusterStateChangeReason : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};

  ClusterStateChangeReason() {}

  explicit ClusterStateChangeReason(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
  }


  virtual ~ClusterStateChangeReason() = default;
};
class SubscriptionConfig : public Darabonba::Model {
public:
  shared_ptr<bool> autoRenew{};
  shared_ptr<long> autoRenewDuration{};
  shared_ptr<string> autoRenewDurationUnit{};
  shared_ptr<long> paymentDuration{};
  shared_ptr<string> paymentDurationUnit{};

  SubscriptionConfig() {}

  explicit SubscriptionConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoRenew) {
      res["AutoRenew"] = boost::any(*autoRenew);
    }
    if (autoRenewDuration) {
      res["AutoRenewDuration"] = boost::any(*autoRenewDuration);
    }
    if (autoRenewDurationUnit) {
      res["AutoRenewDurationUnit"] = boost::any(*autoRenewDurationUnit);
    }
    if (paymentDuration) {
      res["PaymentDuration"] = boost::any(*paymentDuration);
    }
    if (paymentDurationUnit) {
      res["PaymentDurationUnit"] = boost::any(*paymentDurationUnit);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AutoRenew") != m.end() && !m["AutoRenew"].empty()) {
      autoRenew = make_shared<bool>(boost::any_cast<bool>(m["AutoRenew"]));
    }
    if (m.find("AutoRenewDuration") != m.end() && !m["AutoRenewDuration"].empty()) {
      autoRenewDuration = make_shared<long>(boost::any_cast<long>(m["AutoRenewDuration"]));
    }
    if (m.find("AutoRenewDurationUnit") != m.end() && !m["AutoRenewDurationUnit"].empty()) {
      autoRenewDurationUnit = make_shared<string>(boost::any_cast<string>(m["AutoRenewDurationUnit"]));
    }
    if (m.find("PaymentDuration") != m.end() && !m["PaymentDuration"].empty()) {
      paymentDuration = make_shared<long>(boost::any_cast<long>(m["PaymentDuration"]));
    }
    if (m.find("PaymentDurationUnit") != m.end() && !m["PaymentDurationUnit"].empty()) {
      paymentDurationUnit = make_shared<string>(boost::any_cast<string>(m["PaymentDurationUnit"]));
    }
  }


  virtual ~SubscriptionConfig() = default;
};
class Cluster : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> clusterName{};
  shared_ptr<string> clusterState{};
  shared_ptr<string> clusterType{};
  shared_ptr<long> createTime{};
  shared_ptr<string> deployMode{};
  shared_ptr<string> emrDefaultRole{};
  shared_ptr<long> endTime{};
  shared_ptr<long> expireTime{};
  shared_ptr<NodeAttributes> nodeAttributes{};
  shared_ptr<string> paymentType{};
  shared_ptr<long> readyTime{};
  shared_ptr<string> regionId{};
  shared_ptr<string> releaseVersion{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> securityMode{};
  shared_ptr<ClusterStateChangeReason> stateChangeReason{};
  shared_ptr<SubscriptionConfig> subscriptionConfig{};
  shared_ptr<vector<Tag>> tags{};

  Cluster() {}

  explicit Cluster(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (clusterName) {
      res["ClusterName"] = boost::any(*clusterName);
    }
    if (clusterState) {
      res["ClusterState"] = boost::any(*clusterState);
    }
    if (clusterType) {
      res["ClusterType"] = boost::any(*clusterType);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (deployMode) {
      res["DeployMode"] = boost::any(*deployMode);
    }
    if (emrDefaultRole) {
      res["EmrDefaultRole"] = boost::any(*emrDefaultRole);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (expireTime) {
      res["ExpireTime"] = boost::any(*expireTime);
    }
    if (nodeAttributes) {
      res["NodeAttributes"] = nodeAttributes ? boost::any(nodeAttributes->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (paymentType) {
      res["PaymentType"] = boost::any(*paymentType);
    }
    if (readyTime) {
      res["ReadyTime"] = boost::any(*readyTime);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (releaseVersion) {
      res["ReleaseVersion"] = boost::any(*releaseVersion);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (securityMode) {
      res["SecurityMode"] = boost::any(*securityMode);
    }
    if (stateChangeReason) {
      res["StateChangeReason"] = stateChangeReason ? boost::any(stateChangeReason->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (subscriptionConfig) {
      res["SubscriptionConfig"] = subscriptionConfig ? boost::any(subscriptionConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("ClusterName") != m.end() && !m["ClusterName"].empty()) {
      clusterName = make_shared<string>(boost::any_cast<string>(m["ClusterName"]));
    }
    if (m.find("ClusterState") != m.end() && !m["ClusterState"].empty()) {
      clusterState = make_shared<string>(boost::any_cast<string>(m["ClusterState"]));
    }
    if (m.find("ClusterType") != m.end() && !m["ClusterType"].empty()) {
      clusterType = make_shared<string>(boost::any_cast<string>(m["ClusterType"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("DeployMode") != m.end() && !m["DeployMode"].empty()) {
      deployMode = make_shared<string>(boost::any_cast<string>(m["DeployMode"]));
    }
    if (m.find("EmrDefaultRole") != m.end() && !m["EmrDefaultRole"].empty()) {
      emrDefaultRole = make_shared<string>(boost::any_cast<string>(m["EmrDefaultRole"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("ExpireTime") != m.end() && !m["ExpireTime"].empty()) {
      expireTime = make_shared<long>(boost::any_cast<long>(m["ExpireTime"]));
    }
    if (m.find("NodeAttributes") != m.end() && !m["NodeAttributes"].empty()) {
      if (typeid(map<string, boost::any>) == m["NodeAttributes"].type()) {
        NodeAttributes model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NodeAttributes"]));
        nodeAttributes = make_shared<NodeAttributes>(model1);
      }
    }
    if (m.find("PaymentType") != m.end() && !m["PaymentType"].empty()) {
      paymentType = make_shared<string>(boost::any_cast<string>(m["PaymentType"]));
    }
    if (m.find("ReadyTime") != m.end() && !m["ReadyTime"].empty()) {
      readyTime = make_shared<long>(boost::any_cast<long>(m["ReadyTime"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ReleaseVersion") != m.end() && !m["ReleaseVersion"].empty()) {
      releaseVersion = make_shared<string>(boost::any_cast<string>(m["ReleaseVersion"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("SecurityMode") != m.end() && !m["SecurityMode"].empty()) {
      securityMode = make_shared<string>(boost::any_cast<string>(m["SecurityMode"]));
    }
    if (m.find("StateChangeReason") != m.end() && !m["StateChangeReason"].empty()) {
      if (typeid(map<string, boost::any>) == m["StateChangeReason"].type()) {
        ClusterStateChangeReason model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["StateChangeReason"]));
        stateChangeReason = make_shared<ClusterStateChangeReason>(model1);
      }
    }
    if (m.find("SubscriptionConfig") != m.end() && !m["SubscriptionConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["SubscriptionConfig"].type()) {
        SubscriptionConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SubscriptionConfig"]));
        subscriptionConfig = make_shared<SubscriptionConfig>(model1);
      }
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<Tag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            Tag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<Tag>>(expect1);
      }
    }
  }


  virtual ~Cluster() = default;
};
class NodeSelector : public Darabonba::Model {
public:
  shared_ptr<string> nodeGroupId{};
  shared_ptr<vector<string>> nodeGroupIds{};
  shared_ptr<string> nodeGroupName{};
  shared_ptr<vector<string>> nodeGroupNames{};
  shared_ptr<vector<string>> nodeGroupTypes{};
  shared_ptr<vector<string>> nodeNames{};
  shared_ptr<string> nodeSelectType{};

  NodeSelector() {}

  explicit NodeSelector(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nodeGroupId) {
      res["NodeGroupId"] = boost::any(*nodeGroupId);
    }
    if (nodeGroupIds) {
      res["NodeGroupIds"] = boost::any(*nodeGroupIds);
    }
    if (nodeGroupName) {
      res["NodeGroupName"] = boost::any(*nodeGroupName);
    }
    if (nodeGroupNames) {
      res["NodeGroupNames"] = boost::any(*nodeGroupNames);
    }
    if (nodeGroupTypes) {
      res["NodeGroupTypes"] = boost::any(*nodeGroupTypes);
    }
    if (nodeNames) {
      res["NodeNames"] = boost::any(*nodeNames);
    }
    if (nodeSelectType) {
      res["NodeSelectType"] = boost::any(*nodeSelectType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NodeGroupId") != m.end() && !m["NodeGroupId"].empty()) {
      nodeGroupId = make_shared<string>(boost::any_cast<string>(m["NodeGroupId"]));
    }
    if (m.find("NodeGroupIds") != m.end() && !m["NodeGroupIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["NodeGroupIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["NodeGroupIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      nodeGroupIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("NodeGroupName") != m.end() && !m["NodeGroupName"].empty()) {
      nodeGroupName = make_shared<string>(boost::any_cast<string>(m["NodeGroupName"]));
    }
    if (m.find("NodeGroupNames") != m.end() && !m["NodeGroupNames"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["NodeGroupNames"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["NodeGroupNames"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      nodeGroupNames = make_shared<vector<string>>(toVec1);
    }
    if (m.find("NodeGroupTypes") != m.end() && !m["NodeGroupTypes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["NodeGroupTypes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["NodeGroupTypes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      nodeGroupTypes = make_shared<vector<string>>(toVec1);
    }
    if (m.find("NodeNames") != m.end() && !m["NodeNames"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["NodeNames"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["NodeNames"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      nodeNames = make_shared<vector<string>>(toVec1);
    }
    if (m.find("NodeSelectType") != m.end() && !m["NodeSelectType"].empty()) {
      nodeSelectType = make_shared<string>(boost::any_cast<string>(m["NodeSelectType"]));
    }
  }


  virtual ~NodeSelector() = default;
};
class ClusterScript : public Darabonba::Model {
public:
  shared_ptr<string> executionFailStrategy{};
  shared_ptr<string> executionMoment{};
  shared_ptr<NodeSelector> nodeSelect{};
  shared_ptr<long> priority{};
  shared_ptr<string> scriptArgs{};
  shared_ptr<string> scriptName{};
  shared_ptr<string> scriptPath{};

  ClusterScript() {}

  explicit ClusterScript(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (executionFailStrategy) {
      res["ExecutionFailStrategy"] = boost::any(*executionFailStrategy);
    }
    if (executionMoment) {
      res["ExecutionMoment"] = boost::any(*executionMoment);
    }
    if (nodeSelect) {
      res["NodeSelect"] = nodeSelect ? boost::any(nodeSelect->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (scriptArgs) {
      res["ScriptArgs"] = boost::any(*scriptArgs);
    }
    if (scriptName) {
      res["ScriptName"] = boost::any(*scriptName);
    }
    if (scriptPath) {
      res["ScriptPath"] = boost::any(*scriptPath);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ExecutionFailStrategy") != m.end() && !m["ExecutionFailStrategy"].empty()) {
      executionFailStrategy = make_shared<string>(boost::any_cast<string>(m["ExecutionFailStrategy"]));
    }
    if (m.find("ExecutionMoment") != m.end() && !m["ExecutionMoment"].empty()) {
      executionMoment = make_shared<string>(boost::any_cast<string>(m["ExecutionMoment"]));
    }
    if (m.find("NodeSelect") != m.end() && !m["NodeSelect"].empty()) {
      if (typeid(map<string, boost::any>) == m["NodeSelect"].type()) {
        NodeSelector model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NodeSelect"]));
        nodeSelect = make_shared<NodeSelector>(model1);
      }
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
    if (m.find("ScriptArgs") != m.end() && !m["ScriptArgs"].empty()) {
      scriptArgs = make_shared<string>(boost::any_cast<string>(m["ScriptArgs"]));
    }
    if (m.find("ScriptName") != m.end() && !m["ScriptName"].empty()) {
      scriptName = make_shared<string>(boost::any_cast<string>(m["ScriptName"]));
    }
    if (m.find("ScriptPath") != m.end() && !m["ScriptPath"].empty()) {
      scriptPath = make_shared<string>(boost::any_cast<string>(m["ScriptPath"]));
    }
  }


  virtual ~ClusterScript() = default;
};
class ClusterSummary : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> clusterName{};
  shared_ptr<string> clusterState{};
  shared_ptr<string> clusterType{};
  shared_ptr<long> createTime{};
  shared_ptr<string> emrDefaultRole{};
  shared_ptr<long> endTime{};
  shared_ptr<long> expireTime{};
  shared_ptr<string> paymentType{};
  shared_ptr<long> readyTime{};
  shared_ptr<string> releaseVersion{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<ClusterStateChangeReason> stateChangeReason{};
  shared_ptr<vector<Tag>> tags{};

  ClusterSummary() {}

  explicit ClusterSummary(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (clusterName) {
      res["ClusterName"] = boost::any(*clusterName);
    }
    if (clusterState) {
      res["ClusterState"] = boost::any(*clusterState);
    }
    if (clusterType) {
      res["ClusterType"] = boost::any(*clusterType);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (emrDefaultRole) {
      res["EmrDefaultRole"] = boost::any(*emrDefaultRole);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (expireTime) {
      res["ExpireTime"] = boost::any(*expireTime);
    }
    if (paymentType) {
      res["PaymentType"] = boost::any(*paymentType);
    }
    if (readyTime) {
      res["ReadyTime"] = boost::any(*readyTime);
    }
    if (releaseVersion) {
      res["ReleaseVersion"] = boost::any(*releaseVersion);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (stateChangeReason) {
      res["StateChangeReason"] = stateChangeReason ? boost::any(stateChangeReason->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("ClusterName") != m.end() && !m["ClusterName"].empty()) {
      clusterName = make_shared<string>(boost::any_cast<string>(m["ClusterName"]));
    }
    if (m.find("ClusterState") != m.end() && !m["ClusterState"].empty()) {
      clusterState = make_shared<string>(boost::any_cast<string>(m["ClusterState"]));
    }
    if (m.find("ClusterType") != m.end() && !m["ClusterType"].empty()) {
      clusterType = make_shared<string>(boost::any_cast<string>(m["ClusterType"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("EmrDefaultRole") != m.end() && !m["EmrDefaultRole"].empty()) {
      emrDefaultRole = make_shared<string>(boost::any_cast<string>(m["EmrDefaultRole"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("ExpireTime") != m.end() && !m["ExpireTime"].empty()) {
      expireTime = make_shared<long>(boost::any_cast<long>(m["ExpireTime"]));
    }
    if (m.find("PaymentType") != m.end() && !m["PaymentType"].empty()) {
      paymentType = make_shared<string>(boost::any_cast<string>(m["PaymentType"]));
    }
    if (m.find("ReadyTime") != m.end() && !m["ReadyTime"].empty()) {
      readyTime = make_shared<long>(boost::any_cast<long>(m["ReadyTime"]));
    }
    if (m.find("ReleaseVersion") != m.end() && !m["ReleaseVersion"].empty()) {
      releaseVersion = make_shared<string>(boost::any_cast<string>(m["ReleaseVersion"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("StateChangeReason") != m.end() && !m["StateChangeReason"].empty()) {
      if (typeid(map<string, boost::any>) == m["StateChangeReason"].type()) {
        ClusterStateChangeReason model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["StateChangeReason"]));
        stateChangeReason = make_shared<ClusterStateChangeReason>(model1);
      }
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<Tag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            Tag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<Tag>>(expect1);
      }
    }
  }


  virtual ~ClusterSummary() = default;
};
class ComponentInstanceSelectorComponentInstances : public Darabonba::Model {
public:
  shared_ptr<string> applicationName{};
  shared_ptr<string> componentName{};
  shared_ptr<string> nodeId{};

  ComponentInstanceSelectorComponentInstances() {}

  explicit ComponentInstanceSelectorComponentInstances(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applicationName) {
      res["ApplicationName"] = boost::any(*applicationName);
    }
    if (componentName) {
      res["ComponentName"] = boost::any(*componentName);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApplicationName") != m.end() && !m["ApplicationName"].empty()) {
      applicationName = make_shared<string>(boost::any_cast<string>(m["ApplicationName"]));
    }
    if (m.find("ComponentName") != m.end() && !m["ComponentName"].empty()) {
      componentName = make_shared<string>(boost::any_cast<string>(m["ComponentName"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<string>(boost::any_cast<string>(m["NodeId"]));
    }
  }


  virtual ~ComponentInstanceSelectorComponentInstances() = default;
};
class ComponentInstanceSelectorComponents : public Darabonba::Model {
public:
  shared_ptr<string> applicationName{};
  shared_ptr<string> componentName{};

  ComponentInstanceSelectorComponents() {}

  explicit ComponentInstanceSelectorComponents(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applicationName) {
      res["ApplicationName"] = boost::any(*applicationName);
    }
    if (componentName) {
      res["ComponentName"] = boost::any(*componentName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApplicationName") != m.end() && !m["ApplicationName"].empty()) {
      applicationName = make_shared<string>(boost::any_cast<string>(m["ApplicationName"]));
    }
    if (m.find("ComponentName") != m.end() && !m["ComponentName"].empty()) {
      componentName = make_shared<string>(boost::any_cast<string>(m["ComponentName"]));
    }
  }


  virtual ~ComponentInstanceSelectorComponents() = default;
};
class ComponentInstanceSelector : public Darabonba::Model {
public:
  shared_ptr<string> actionScope{};
  shared_ptr<string> applicationName{};
  shared_ptr<vector<ComponentInstanceSelectorComponentInstances>> componentInstances{};
  shared_ptr<vector<ComponentInstanceSelectorComponents>> components{};
  shared_ptr<string> runActionScope{};

  ComponentInstanceSelector() {}

  explicit ComponentInstanceSelector(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (actionScope) {
      res["ActionScope"] = boost::any(*actionScope);
    }
    if (applicationName) {
      res["ApplicationName"] = boost::any(*applicationName);
    }
    if (componentInstances) {
      vector<boost::any> temp1;
      for(auto item1:*componentInstances){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ComponentInstances"] = boost::any(temp1);
    }
    if (components) {
      vector<boost::any> temp1;
      for(auto item1:*components){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Components"] = boost::any(temp1);
    }
    if (runActionScope) {
      res["RunActionScope"] = boost::any(*runActionScope);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActionScope") != m.end() && !m["ActionScope"].empty()) {
      actionScope = make_shared<string>(boost::any_cast<string>(m["ActionScope"]));
    }
    if (m.find("ApplicationName") != m.end() && !m["ApplicationName"].empty()) {
      applicationName = make_shared<string>(boost::any_cast<string>(m["ApplicationName"]));
    }
    if (m.find("ComponentInstances") != m.end() && !m["ComponentInstances"].empty()) {
      if (typeid(vector<boost::any>) == m["ComponentInstances"].type()) {
        vector<ComponentInstanceSelectorComponentInstances> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ComponentInstances"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ComponentInstanceSelectorComponentInstances model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        componentInstances = make_shared<vector<ComponentInstanceSelectorComponentInstances>>(expect1);
      }
    }
    if (m.find("Components") != m.end() && !m["Components"].empty()) {
      if (typeid(vector<boost::any>) == m["Components"].type()) {
        vector<ComponentInstanceSelectorComponents> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Components"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ComponentInstanceSelectorComponents model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        components = make_shared<vector<ComponentInstanceSelectorComponents>>(expect1);
      }
    }
    if (m.find("RunActionScope") != m.end() && !m["RunActionScope"].empty()) {
      runActionScope = make_shared<string>(boost::any_cast<string>(m["RunActionScope"]));
    }
  }


  virtual ~ComponentInstanceSelector() = default;
};
class ComponentLayoutNodeSelector : public Darabonba::Model {
public:
  shared_ptr<long> nodeEndIndex{};
  shared_ptr<string> nodeGroupId{};
  shared_ptr<long> nodeGroupIndex{};
  shared_ptr<string> nodeGroupName{};
  shared_ptr<vector<string>> nodeGroupTypes{};
  shared_ptr<vector<string>> nodeNames{};
  shared_ptr<string> nodeSelectType{};
  shared_ptr<long> nodeStartIndex{};

  ComponentLayoutNodeSelector() {}

  explicit ComponentLayoutNodeSelector(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nodeEndIndex) {
      res["NodeEndIndex"] = boost::any(*nodeEndIndex);
    }
    if (nodeGroupId) {
      res["NodeGroupId"] = boost::any(*nodeGroupId);
    }
    if (nodeGroupIndex) {
      res["NodeGroupIndex"] = boost::any(*nodeGroupIndex);
    }
    if (nodeGroupName) {
      res["NodeGroupName"] = boost::any(*nodeGroupName);
    }
    if (nodeGroupTypes) {
      res["NodeGroupTypes"] = boost::any(*nodeGroupTypes);
    }
    if (nodeNames) {
      res["NodeNames"] = boost::any(*nodeNames);
    }
    if (nodeSelectType) {
      res["NodeSelectType"] = boost::any(*nodeSelectType);
    }
    if (nodeStartIndex) {
      res["NodeStartIndex"] = boost::any(*nodeStartIndex);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NodeEndIndex") != m.end() && !m["NodeEndIndex"].empty()) {
      nodeEndIndex = make_shared<long>(boost::any_cast<long>(m["NodeEndIndex"]));
    }
    if (m.find("NodeGroupId") != m.end() && !m["NodeGroupId"].empty()) {
      nodeGroupId = make_shared<string>(boost::any_cast<string>(m["NodeGroupId"]));
    }
    if (m.find("NodeGroupIndex") != m.end() && !m["NodeGroupIndex"].empty()) {
      nodeGroupIndex = make_shared<long>(boost::any_cast<long>(m["NodeGroupIndex"]));
    }
    if (m.find("NodeGroupName") != m.end() && !m["NodeGroupName"].empty()) {
      nodeGroupName = make_shared<string>(boost::any_cast<string>(m["NodeGroupName"]));
    }
    if (m.find("NodeGroupTypes") != m.end() && !m["NodeGroupTypes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["NodeGroupTypes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["NodeGroupTypes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      nodeGroupTypes = make_shared<vector<string>>(toVec1);
    }
    if (m.find("NodeNames") != m.end() && !m["NodeNames"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["NodeNames"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["NodeNames"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      nodeNames = make_shared<vector<string>>(toVec1);
    }
    if (m.find("NodeSelectType") != m.end() && !m["NodeSelectType"].empty()) {
      nodeSelectType = make_shared<string>(boost::any_cast<string>(m["NodeSelectType"]));
    }
    if (m.find("NodeStartIndex") != m.end() && !m["NodeStartIndex"].empty()) {
      nodeStartIndex = make_shared<long>(boost::any_cast<long>(m["NodeStartIndex"]));
    }
  }


  virtual ~ComponentLayoutNodeSelector() = default;
};
class ComponentLayout : public Darabonba::Model {
public:
  shared_ptr<string> applicationName{};
  shared_ptr<string> componentName{};
  shared_ptr<ComponentLayoutNodeSelector> nodeSelector{};

  ComponentLayout() {}

  explicit ComponentLayout(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applicationName) {
      res["ApplicationName"] = boost::any(*applicationName);
    }
    if (componentName) {
      res["ComponentName"] = boost::any(*componentName);
    }
    if (nodeSelector) {
      res["NodeSelector"] = nodeSelector ? boost::any(nodeSelector->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApplicationName") != m.end() && !m["ApplicationName"].empty()) {
      applicationName = make_shared<string>(boost::any_cast<string>(m["ApplicationName"]));
    }
    if (m.find("ComponentName") != m.end() && !m["ComponentName"].empty()) {
      componentName = make_shared<string>(boost::any_cast<string>(m["ComponentName"]));
    }
    if (m.find("NodeSelector") != m.end() && !m["NodeSelector"].empty()) {
      if (typeid(map<string, boost::any>) == m["NodeSelector"].type()) {
        ComponentLayoutNodeSelector model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NodeSelector"]));
        nodeSelector = make_shared<ComponentLayoutNodeSelector>(model1);
      }
    }
  }


  virtual ~ComponentLayout() = default;
};
class ConfigEffectActions : public Darabonba::Model {
public:
  shared_ptr<string> configEffectAction{};
  shared_ptr<vector<string>> configFiles{};

  ConfigEffectActions() {}

  explicit ConfigEffectActions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configEffectAction) {
      res["ConfigEffectAction"] = boost::any(*configEffectAction);
    }
    if (configFiles) {
      res["ConfigFiles"] = boost::any(*configFiles);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigEffectAction") != m.end() && !m["ConfigEffectAction"].empty()) {
      configEffectAction = make_shared<string>(boost::any_cast<string>(m["ConfigEffectAction"]));
    }
    if (m.find("ConfigFiles") != m.end() && !m["ConfigFiles"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ConfigFiles"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ConfigFiles"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      configFiles = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ConfigEffectActions() = default;
};
class ConvertNodeGroup : public Darabonba::Model {
public:
  shared_ptr<string> nodeGroupId{};
  shared_ptr<long> paymentDuration{};
  shared_ptr<string> paymentDurationUnit{};
  shared_ptr<string> paymentType{};

  ConvertNodeGroup() {}

  explicit ConvertNodeGroup(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nodeGroupId) {
      res["NodeGroupId"] = boost::any(*nodeGroupId);
    }
    if (paymentDuration) {
      res["PaymentDuration"] = boost::any(*paymentDuration);
    }
    if (paymentDurationUnit) {
      res["PaymentDurationUnit"] = boost::any(*paymentDurationUnit);
    }
    if (paymentType) {
      res["PaymentType"] = boost::any(*paymentType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NodeGroupId") != m.end() && !m["NodeGroupId"].empty()) {
      nodeGroupId = make_shared<string>(boost::any_cast<string>(m["NodeGroupId"]));
    }
    if (m.find("PaymentDuration") != m.end() && !m["PaymentDuration"].empty()) {
      paymentDuration = make_shared<long>(boost::any_cast<long>(m["PaymentDuration"]));
    }
    if (m.find("PaymentDurationUnit") != m.end() && !m["PaymentDurationUnit"].empty()) {
      paymentDurationUnit = make_shared<string>(boost::any_cast<string>(m["PaymentDurationUnit"]));
    }
    if (m.find("PaymentType") != m.end() && !m["PaymentType"].empty()) {
      paymentType = make_shared<string>(boost::any_cast<string>(m["PaymentType"]));
    }
  }


  virtual ~ConvertNodeGroup() = default;
};
class ConvertNodeGroupParam : public Darabonba::Model {
public:
  shared_ptr<string> nodeGroupId{};
  shared_ptr<long> paymentDuration{};
  shared_ptr<string> paymentDurationUnit{};
  shared_ptr<string> paymentType{};

  ConvertNodeGroupParam() {}

  explicit ConvertNodeGroupParam(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nodeGroupId) {
      res["NodeGroupId"] = boost::any(*nodeGroupId);
    }
    if (paymentDuration) {
      res["PaymentDuration"] = boost::any(*paymentDuration);
    }
    if (paymentDurationUnit) {
      res["PaymentDurationUnit"] = boost::any(*paymentDurationUnit);
    }
    if (paymentType) {
      res["PaymentType"] = boost::any(*paymentType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NodeGroupId") != m.end() && !m["NodeGroupId"].empty()) {
      nodeGroupId = make_shared<string>(boost::any_cast<string>(m["NodeGroupId"]));
    }
    if (m.find("PaymentDuration") != m.end() && !m["PaymentDuration"].empty()) {
      paymentDuration = make_shared<long>(boost::any_cast<long>(m["PaymentDuration"]));
    }
    if (m.find("PaymentDurationUnit") != m.end() && !m["PaymentDurationUnit"].empty()) {
      paymentDurationUnit = make_shared<string>(boost::any_cast<string>(m["PaymentDurationUnit"]));
    }
    if (m.find("PaymentType") != m.end() && !m["PaymentType"].empty()) {
      paymentType = make_shared<string>(boost::any_cast<string>(m["PaymentType"]));
    }
  }


  virtual ~ConvertNodeGroupParam() = default;
};
class CostOptimizedConfig : public Darabonba::Model {
public:
  shared_ptr<long> onDemandBaseCapacity{};
  shared_ptr<long> onDemandPercentageAboveBaseCapacity{};
  shared_ptr<long> spotInstancePools{};

  CostOptimizedConfig() {}

  explicit CostOptimizedConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (onDemandBaseCapacity) {
      res["OnDemandBaseCapacity"] = boost::any(*onDemandBaseCapacity);
    }
    if (onDemandPercentageAboveBaseCapacity) {
      res["OnDemandPercentageAboveBaseCapacity"] = boost::any(*onDemandPercentageAboveBaseCapacity);
    }
    if (spotInstancePools) {
      res["SpotInstancePools"] = boost::any(*spotInstancePools);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OnDemandBaseCapacity") != m.end() && !m["OnDemandBaseCapacity"].empty()) {
      onDemandBaseCapacity = make_shared<long>(boost::any_cast<long>(m["OnDemandBaseCapacity"]));
    }
    if (m.find("OnDemandPercentageAboveBaseCapacity") != m.end() && !m["OnDemandPercentageAboveBaseCapacity"].empty()) {
      onDemandPercentageAboveBaseCapacity = make_shared<long>(boost::any_cast<long>(m["OnDemandPercentageAboveBaseCapacity"]));
    }
    if (m.find("SpotInstancePools") != m.end() && !m["SpotInstancePools"].empty()) {
      spotInstancePools = make_shared<long>(boost::any_cast<long>(m["SpotInstancePools"]));
    }
  }


  virtual ~CostOptimizedConfig() = default;
};
class DiskInfo : public Darabonba::Model {
public:
  shared_ptr<string> category{};
  shared_ptr<long> count{};
  shared_ptr<string> performanceLevel{};
  shared_ptr<long> size{};

  DiskInfo() {}

  explicit DiskInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (performanceLevel) {
      res["PerformanceLevel"] = boost::any(*performanceLevel);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("PerformanceLevel") != m.end() && !m["PerformanceLevel"].empty()) {
      performanceLevel = make_shared<string>(boost::any_cast<string>(m["PerformanceLevel"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
  }


  virtual ~DiskInfo() = default;
};
class SystemDiskParam : public Darabonba::Model {
public:
  shared_ptr<string> category{};
  shared_ptr<string> performanceLevel{};
  shared_ptr<long> size{};

  SystemDiskParam() {}

  explicit SystemDiskParam(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (performanceLevel) {
      res["PerformanceLevel"] = boost::any(*performanceLevel);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("PerformanceLevel") != m.end() && !m["PerformanceLevel"].empty()) {
      performanceLevel = make_shared<string>(boost::any_cast<string>(m["PerformanceLevel"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
  }


  virtual ~SystemDiskParam() = default;
};
class CreateNodeGroupParam : public Darabonba::Model {
public:
  shared_ptr<bool> autoRenew{};
  shared_ptr<long> autoRenewDuration{};
  shared_ptr<string> autoRenewDurationUnit{};
  shared_ptr<vector<DiskInfo>> dataDisks{};
  shared_ptr<vector<string>> instanceTypes{};
  shared_ptr<long> nodeCount{};
  shared_ptr<string> nodeGroupName{};
  shared_ptr<string> nodeGroupType{};
  shared_ptr<string> nodeKeyPairName{};
  shared_ptr<string> nodeRamRole{};
  shared_ptr<string> nodeRootPassword{};
  shared_ptr<long> paymentDuration{};
  shared_ptr<string> paymentDurationUnit{};
  shared_ptr<string> paymentType{};
  shared_ptr<string> securityGroupId{};
  shared_ptr<string> spotStrategy{};
  shared_ptr<SystemDiskParam> systemDisk{};
  shared_ptr<vector<string>> vSwitchIds{};
  shared_ptr<bool> withPublicIp{};
  shared_ptr<string> zoneId{};

  CreateNodeGroupParam() {}

  explicit CreateNodeGroupParam(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoRenew) {
      res["AutoRenew"] = boost::any(*autoRenew);
    }
    if (autoRenewDuration) {
      res["AutoRenewDuration"] = boost::any(*autoRenewDuration);
    }
    if (autoRenewDurationUnit) {
      res["AutoRenewDurationUnit"] = boost::any(*autoRenewDurationUnit);
    }
    if (dataDisks) {
      vector<boost::any> temp1;
      for(auto item1:*dataDisks){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataDisks"] = boost::any(temp1);
    }
    if (instanceTypes) {
      res["InstanceTypes"] = boost::any(*instanceTypes);
    }
    if (nodeCount) {
      res["NodeCount"] = boost::any(*nodeCount);
    }
    if (nodeGroupName) {
      res["NodeGroupName"] = boost::any(*nodeGroupName);
    }
    if (nodeGroupType) {
      res["NodeGroupType"] = boost::any(*nodeGroupType);
    }
    if (nodeKeyPairName) {
      res["NodeKeyPairName"] = boost::any(*nodeKeyPairName);
    }
    if (nodeRamRole) {
      res["NodeRamRole"] = boost::any(*nodeRamRole);
    }
    if (nodeRootPassword) {
      res["NodeRootPassword"] = boost::any(*nodeRootPassword);
    }
    if (paymentDuration) {
      res["PaymentDuration"] = boost::any(*paymentDuration);
    }
    if (paymentDurationUnit) {
      res["PaymentDurationUnit"] = boost::any(*paymentDurationUnit);
    }
    if (paymentType) {
      res["PaymentType"] = boost::any(*paymentType);
    }
    if (securityGroupId) {
      res["SecurityGroupId"] = boost::any(*securityGroupId);
    }
    if (spotStrategy) {
      res["SpotStrategy"] = boost::any(*spotStrategy);
    }
    if (systemDisk) {
      res["SystemDisk"] = systemDisk ? boost::any(systemDisk->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (vSwitchIds) {
      res["VSwitchIds"] = boost::any(*vSwitchIds);
    }
    if (withPublicIp) {
      res["WithPublicIp"] = boost::any(*withPublicIp);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AutoRenew") != m.end() && !m["AutoRenew"].empty()) {
      autoRenew = make_shared<bool>(boost::any_cast<bool>(m["AutoRenew"]));
    }
    if (m.find("AutoRenewDuration") != m.end() && !m["AutoRenewDuration"].empty()) {
      autoRenewDuration = make_shared<long>(boost::any_cast<long>(m["AutoRenewDuration"]));
    }
    if (m.find("AutoRenewDurationUnit") != m.end() && !m["AutoRenewDurationUnit"].empty()) {
      autoRenewDurationUnit = make_shared<string>(boost::any_cast<string>(m["AutoRenewDurationUnit"]));
    }
    if (m.find("DataDisks") != m.end() && !m["DataDisks"].empty()) {
      if (typeid(vector<boost::any>) == m["DataDisks"].type()) {
        vector<DiskInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataDisks"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DiskInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataDisks = make_shared<vector<DiskInfo>>(expect1);
      }
    }
    if (m.find("InstanceTypes") != m.end() && !m["InstanceTypes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InstanceTypes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InstanceTypes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceTypes = make_shared<vector<string>>(toVec1);
    }
    if (m.find("NodeCount") != m.end() && !m["NodeCount"].empty()) {
      nodeCount = make_shared<long>(boost::any_cast<long>(m["NodeCount"]));
    }
    if (m.find("NodeGroupName") != m.end() && !m["NodeGroupName"].empty()) {
      nodeGroupName = make_shared<string>(boost::any_cast<string>(m["NodeGroupName"]));
    }
    if (m.find("NodeGroupType") != m.end() && !m["NodeGroupType"].empty()) {
      nodeGroupType = make_shared<string>(boost::any_cast<string>(m["NodeGroupType"]));
    }
    if (m.find("NodeKeyPairName") != m.end() && !m["NodeKeyPairName"].empty()) {
      nodeKeyPairName = make_shared<string>(boost::any_cast<string>(m["NodeKeyPairName"]));
    }
    if (m.find("NodeRamRole") != m.end() && !m["NodeRamRole"].empty()) {
      nodeRamRole = make_shared<string>(boost::any_cast<string>(m["NodeRamRole"]));
    }
    if (m.find("NodeRootPassword") != m.end() && !m["NodeRootPassword"].empty()) {
      nodeRootPassword = make_shared<string>(boost::any_cast<string>(m["NodeRootPassword"]));
    }
    if (m.find("PaymentDuration") != m.end() && !m["PaymentDuration"].empty()) {
      paymentDuration = make_shared<long>(boost::any_cast<long>(m["PaymentDuration"]));
    }
    if (m.find("PaymentDurationUnit") != m.end() && !m["PaymentDurationUnit"].empty()) {
      paymentDurationUnit = make_shared<string>(boost::any_cast<string>(m["PaymentDurationUnit"]));
    }
    if (m.find("PaymentType") != m.end() && !m["PaymentType"].empty()) {
      paymentType = make_shared<string>(boost::any_cast<string>(m["PaymentType"]));
    }
    if (m.find("SecurityGroupId") != m.end() && !m["SecurityGroupId"].empty()) {
      securityGroupId = make_shared<string>(boost::any_cast<string>(m["SecurityGroupId"]));
    }
    if (m.find("SpotStrategy") != m.end() && !m["SpotStrategy"].empty()) {
      spotStrategy = make_shared<string>(boost::any_cast<string>(m["SpotStrategy"]));
    }
    if (m.find("SystemDisk") != m.end() && !m["SystemDisk"].empty()) {
      if (typeid(map<string, boost::any>) == m["SystemDisk"].type()) {
        SystemDiskParam model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SystemDisk"]));
        systemDisk = make_shared<SystemDiskParam>(model1);
      }
    }
    if (m.find("VSwitchIds") != m.end() && !m["VSwitchIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["VSwitchIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["VSwitchIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      vSwitchIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("WithPublicIp") != m.end() && !m["WithPublicIp"].empty()) {
      withPublicIp = make_shared<bool>(boost::any_cast<bool>(m["WithPublicIp"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
  }


  virtual ~CreateNodeGroupParam() = default;
};
class DataDisk : public Darabonba::Model {
public:
  shared_ptr<string> category{};
  shared_ptr<long> count{};
  shared_ptr<string> performanceLevel{};
  shared_ptr<long> size{};

  DataDisk() {}

  explicit DataDisk(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (performanceLevel) {
      res["PerformanceLevel"] = boost::any(*performanceLevel);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("PerformanceLevel") != m.end() && !m["PerformanceLevel"].empty()) {
      performanceLevel = make_shared<string>(boost::any_cast<string>(m["PerformanceLevel"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
  }


  virtual ~DataDisk() = default;
};
class DecreaseNodeGroupParam : public Darabonba::Model {
public:
  shared_ptr<string> nodeGroupId{};
  shared_ptr<vector<string>> releaseInstanceIds{};

  DecreaseNodeGroupParam() {}

  explicit DecreaseNodeGroupParam(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nodeGroupId) {
      res["NodeGroupId"] = boost::any(*nodeGroupId);
    }
    if (releaseInstanceIds) {
      res["ReleaseInstanceIds"] = boost::any(*releaseInstanceIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NodeGroupId") != m.end() && !m["NodeGroupId"].empty()) {
      nodeGroupId = make_shared<string>(boost::any_cast<string>(m["NodeGroupId"]));
    }
    if (m.find("ReleaseInstanceIds") != m.end() && !m["ReleaseInstanceIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ReleaseInstanceIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ReleaseInstanceIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      releaseInstanceIds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DecreaseNodeGroupParam() = default;
};
class DeploymentLayout : public Darabonba::Model {
public:
  shared_ptr<string> applicationName{};
  shared_ptr<string> componentName{};
  shared_ptr<NodeSelector> nodeSelector{};

  DeploymentLayout() {}

  explicit DeploymentLayout(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applicationName) {
      res["ApplicationName"] = boost::any(*applicationName);
    }
    if (componentName) {
      res["ComponentName"] = boost::any(*componentName);
    }
    if (nodeSelector) {
      res["NodeSelector"] = nodeSelector ? boost::any(nodeSelector->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApplicationName") != m.end() && !m["ApplicationName"].empty()) {
      applicationName = make_shared<string>(boost::any_cast<string>(m["ApplicationName"]));
    }
    if (m.find("ComponentName") != m.end() && !m["ComponentName"].empty()) {
      componentName = make_shared<string>(boost::any_cast<string>(m["ComponentName"]));
    }
    if (m.find("NodeSelector") != m.end() && !m["NodeSelector"].empty()) {
      if (typeid(map<string, boost::any>) == m["NodeSelector"].type()) {
        NodeSelector model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NodeSelector"]));
        nodeSelector = make_shared<NodeSelector>(model1);
      }
    }
  }


  virtual ~DeploymentLayout() = default;
};
class InstanceCategory : public Darabonba::Model {
public:
  shared_ptr<string> defaultValue{};
  shared_ptr<vector<string>> keys{};
  shared_ptr<vector<string>> values{};

  InstanceCategory() {}

  explicit InstanceCategory(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (defaultValue) {
      res["DefaultValue"] = boost::any(*defaultValue);
    }
    if (keys) {
      res["Keys"] = boost::any(*keys);
    }
    if (values) {
      res["Values"] = boost::any(*values);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DefaultValue") != m.end() && !m["DefaultValue"].empty()) {
      defaultValue = make_shared<string>(boost::any_cast<string>(m["DefaultValue"]));
    }
    if (m.find("Keys") != m.end() && !m["Keys"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Keys"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Keys"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      keys = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Values") != m.end() && !m["Values"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Values"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Values"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      values = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~InstanceCategory() = default;
};
class ReplacementStrategy : public Darabonba::Model {
public:
  shared_ptr<vector<InstanceCategory>> instanceCategories{};

  ReplacementStrategy() {}

  explicit ReplacementStrategy(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceCategories) {
      vector<boost::any> temp1;
      for(auto item1:*instanceCategories){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InstanceCategories"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceCategories") != m.end() && !m["InstanceCategories"].empty()) {
      if (typeid(vector<boost::any>) == m["InstanceCategories"].type()) {
        vector<InstanceCategory> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InstanceCategories"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            InstanceCategory model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        instanceCategories = make_shared<vector<InstanceCategory>>(expect1);
      }
    }
  }


  virtual ~ReplacementStrategy() = default;
};
class DeploymentSetConstraints : public Darabonba::Model {
public:
  shared_ptr<string> defaultValue{};
  shared_ptr<string> enableState{};
  shared_ptr<ReplacementStrategy> replacementStrategy{};
  shared_ptr<vector<string>> values{};

  DeploymentSetConstraints() {}

  explicit DeploymentSetConstraints(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (defaultValue) {
      res["DefaultValue"] = boost::any(*defaultValue);
    }
    if (enableState) {
      res["EnableState"] = boost::any(*enableState);
    }
    if (replacementStrategy) {
      res["ReplacementStrategy"] = replacementStrategy ? boost::any(replacementStrategy->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (values) {
      res["Values"] = boost::any(*values);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DefaultValue") != m.end() && !m["DefaultValue"].empty()) {
      defaultValue = make_shared<string>(boost::any_cast<string>(m["DefaultValue"]));
    }
    if (m.find("EnableState") != m.end() && !m["EnableState"].empty()) {
      enableState = make_shared<string>(boost::any_cast<string>(m["EnableState"]));
    }
    if (m.find("ReplacementStrategy") != m.end() && !m["ReplacementStrategy"].empty()) {
      if (typeid(map<string, boost::any>) == m["ReplacementStrategy"].type()) {
        ReplacementStrategy model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ReplacementStrategy"]));
        replacementStrategy = make_shared<ReplacementStrategy>(model1);
      }
    }
    if (m.find("Values") != m.end() && !m["Values"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Values"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Values"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      values = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DeploymentSetConstraints() = default;
};
class Disk : public Darabonba::Model {
public:
  shared_ptr<string> category{};
  shared_ptr<long> count{};
  shared_ptr<string> performanceLevel{};
  shared_ptr<long> size{};

  Disk() {}

  explicit Disk(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (performanceLevel) {
      res["PerformanceLevel"] = boost::any(*performanceLevel);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("PerformanceLevel") != m.end() && !m["PerformanceLevel"].empty()) {
      performanceLevel = make_shared<string>(boost::any_cast<string>(m["PerformanceLevel"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
  }


  virtual ~Disk() = default;
};
class ValueConstraints : public Darabonba::Model {
public:
  shared_ptr<long> defaultValue{};
  shared_ptr<long> end{};
  shared_ptr<long> start{};
  shared_ptr<long> step{};
  shared_ptr<string> type{};
  shared_ptr<vector<long>> values{};

  ValueConstraints() {}

  explicit ValueConstraints(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (defaultValue) {
      res["DefaultValue"] = boost::any(*defaultValue);
    }
    if (end) {
      res["End"] = boost::any(*end);
    }
    if (start) {
      res["Start"] = boost::any(*start);
    }
    if (step) {
      res["Step"] = boost::any(*step);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (values) {
      res["Values"] = boost::any(*values);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DefaultValue") != m.end() && !m["DefaultValue"].empty()) {
      defaultValue = make_shared<long>(boost::any_cast<long>(m["DefaultValue"]));
    }
    if (m.find("End") != m.end() && !m["End"].empty()) {
      end = make_shared<long>(boost::any_cast<long>(m["End"]));
    }
    if (m.find("Start") != m.end() && !m["Start"].empty()) {
      start = make_shared<long>(boost::any_cast<long>(m["Start"]));
    }
    if (m.find("Step") != m.end() && !m["Step"].empty()) {
      step = make_shared<long>(boost::any_cast<long>(m["Step"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Values") != m.end() && !m["Values"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["Values"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Values"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      values = make_shared<vector<long>>(toVec1);
    }
  }


  virtual ~ValueConstraints() = default;
};
class DiskConstraints : public Darabonba::Model {
public:
  shared_ptr<vector<string>> categories{};
  shared_ptr<ValueConstraints> countConstraint{};
  shared_ptr<ValueConstraints> sizeConstraint{};

  DiskConstraints() {}

  explicit DiskConstraints(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (categories) {
      res["Categories"] = boost::any(*categories);
    }
    if (countConstraint) {
      res["CountConstraint"] = countConstraint ? boost::any(countConstraint->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (sizeConstraint) {
      res["SizeConstraint"] = sizeConstraint ? boost::any(sizeConstraint->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Categories") != m.end() && !m["Categories"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Categories"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Categories"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      categories = make_shared<vector<string>>(toVec1);
    }
    if (m.find("CountConstraint") != m.end() && !m["CountConstraint"].empty()) {
      if (typeid(map<string, boost::any>) == m["CountConstraint"].type()) {
        ValueConstraints model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CountConstraint"]));
        countConstraint = make_shared<ValueConstraints>(model1);
      }
    }
    if (m.find("SizeConstraint") != m.end() && !m["SizeConstraint"].empty()) {
      if (typeid(map<string, boost::any>) == m["SizeConstraint"].type()) {
        ValueConstraints model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SizeConstraint"]));
        sizeConstraint = make_shared<ValueConstraints>(model1);
      }
    }
  }


  virtual ~DiskConstraints() = default;
};
class DiskSize : public Darabonba::Model {
public:
  shared_ptr<string> category{};
  shared_ptr<long> size{};

  DiskSize() {}

  explicit DiskSize(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
  }


  virtual ~DiskSize() = default;
};
class FailedReason : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};

  FailedReason() {}

  explicit FailedReason(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~FailedReason() = default;
};
class HealthSummary : public Darabonba::Model {
public:
  shared_ptr<long> badCount{};
  shared_ptr<long> goodCount{};
  shared_ptr<long> noneCount{};
  shared_ptr<long> stoppedCount{};
  shared_ptr<long> totalCount{};
  shared_ptr<long> unknownCount{};
  shared_ptr<long> warningCount{};

  HealthSummary() {}

  explicit HealthSummary(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (badCount) {
      res["BadCount"] = boost::any(*badCount);
    }
    if (goodCount) {
      res["GoodCount"] = boost::any(*goodCount);
    }
    if (noneCount) {
      res["NoneCount"] = boost::any(*noneCount);
    }
    if (stoppedCount) {
      res["StoppedCount"] = boost::any(*stoppedCount);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (unknownCount) {
      res["UnknownCount"] = boost::any(*unknownCount);
    }
    if (warningCount) {
      res["WarningCount"] = boost::any(*warningCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BadCount") != m.end() && !m["BadCount"].empty()) {
      badCount = make_shared<long>(boost::any_cast<long>(m["BadCount"]));
    }
    if (m.find("GoodCount") != m.end() && !m["GoodCount"].empty()) {
      goodCount = make_shared<long>(boost::any_cast<long>(m["GoodCount"]));
    }
    if (m.find("NoneCount") != m.end() && !m["NoneCount"].empty()) {
      noneCount = make_shared<long>(boost::any_cast<long>(m["NoneCount"]));
    }
    if (m.find("StoppedCount") != m.end() && !m["StoppedCount"].empty()) {
      stoppedCount = make_shared<long>(boost::any_cast<long>(m["StoppedCount"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("UnknownCount") != m.end() && !m["UnknownCount"].empty()) {
      unknownCount = make_shared<long>(boost::any_cast<long>(m["UnknownCount"]));
    }
    if (m.find("WarningCount") != m.end() && !m["WarningCount"].empty()) {
      warningCount = make_shared<long>(boost::any_cast<long>(m["WarningCount"]));
    }
  }


  virtual ~HealthSummary() = default;
};
class IncreaseNodeGroup : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<long> nodeCount{};
  shared_ptr<string> nodeGroupId{};
  shared_ptr<long> paymentDuration{};
  shared_ptr<string> paymentDurationUnit{};
  shared_ptr<string> vSwitchId{};

  IncreaseNodeGroup() {}

  explicit IncreaseNodeGroup(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (nodeCount) {
      res["NodeCount"] = boost::any(*nodeCount);
    }
    if (nodeGroupId) {
      res["NodeGroupId"] = boost::any(*nodeGroupId);
    }
    if (paymentDuration) {
      res["PaymentDuration"] = boost::any(*paymentDuration);
    }
    if (paymentDurationUnit) {
      res["PaymentDurationUnit"] = boost::any(*paymentDurationUnit);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("NodeCount") != m.end() && !m["NodeCount"].empty()) {
      nodeCount = make_shared<long>(boost::any_cast<long>(m["NodeCount"]));
    }
    if (m.find("NodeGroupId") != m.end() && !m["NodeGroupId"].empty()) {
      nodeGroupId = make_shared<string>(boost::any_cast<string>(m["NodeGroupId"]));
    }
    if (m.find("PaymentDuration") != m.end() && !m["PaymentDuration"].empty()) {
      paymentDuration = make_shared<long>(boost::any_cast<long>(m["PaymentDuration"]));
    }
    if (m.find("PaymentDurationUnit") != m.end() && !m["PaymentDurationUnit"].empty()) {
      paymentDurationUnit = make_shared<string>(boost::any_cast<string>(m["PaymentDurationUnit"]));
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
  }


  virtual ~IncreaseNodeGroup() = default;
};
class IncreaseNodeGroupParam : public Darabonba::Model {
public:
  shared_ptr<long> nodeCount{};
  shared_ptr<string> nodeGroupId{};
  shared_ptr<long> paymentDuration{};
  shared_ptr<string> paymentDurationUnit{};
  shared_ptr<string> vSwitchId{};

  IncreaseNodeGroupParam() {}

  explicit IncreaseNodeGroupParam(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nodeCount) {
      res["NodeCount"] = boost::any(*nodeCount);
    }
    if (nodeGroupId) {
      res["NodeGroupId"] = boost::any(*nodeGroupId);
    }
    if (paymentDuration) {
      res["PaymentDuration"] = boost::any(*paymentDuration);
    }
    if (paymentDurationUnit) {
      res["PaymentDurationUnit"] = boost::any(*paymentDurationUnit);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NodeCount") != m.end() && !m["NodeCount"].empty()) {
      nodeCount = make_shared<long>(boost::any_cast<long>(m["NodeCount"]));
    }
    if (m.find("NodeGroupId") != m.end() && !m["NodeGroupId"].empty()) {
      nodeGroupId = make_shared<string>(boost::any_cast<string>(m["NodeGroupId"]));
    }
    if (m.find("PaymentDuration") != m.end() && !m["PaymentDuration"].empty()) {
      paymentDuration = make_shared<long>(boost::any_cast<long>(m["PaymentDuration"]));
    }
    if (m.find("PaymentDurationUnit") != m.end() && !m["PaymentDurationUnit"].empty()) {
      paymentDurationUnit = make_shared<string>(boost::any_cast<string>(m["PaymentDurationUnit"]));
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
  }


  virtual ~IncreaseNodeGroupParam() = default;
};
class InstanceType : public Darabonba::Model {
public:
  shared_ptr<string> cpuArchitecture{};
  shared_ptr<long> cpuCore{};
  shared_ptr<string> instanceCategory{};
  shared_ptr<string> instanceType{};
  shared_ptr<string> instanceTypeFamily{};
  shared_ptr<long> localStorageAmount{};
  shared_ptr<long> localStorageCapacity{};
  shared_ptr<bool> optimized{};

  InstanceType() {}

  explicit InstanceType(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cpuArchitecture) {
      res["CpuArchitecture"] = boost::any(*cpuArchitecture);
    }
    if (cpuCore) {
      res["CpuCore"] = boost::any(*cpuCore);
    }
    if (instanceCategory) {
      res["InstanceCategory"] = boost::any(*instanceCategory);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (instanceTypeFamily) {
      res["InstanceTypeFamily"] = boost::any(*instanceTypeFamily);
    }
    if (localStorageAmount) {
      res["LocalStorageAmount"] = boost::any(*localStorageAmount);
    }
    if (localStorageCapacity) {
      res["LocalStorageCapacity"] = boost::any(*localStorageCapacity);
    }
    if (optimized) {
      res["Optimized"] = boost::any(*optimized);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CpuArchitecture") != m.end() && !m["CpuArchitecture"].empty()) {
      cpuArchitecture = make_shared<string>(boost::any_cast<string>(m["CpuArchitecture"]));
    }
    if (m.find("CpuCore") != m.end() && !m["CpuCore"].empty()) {
      cpuCore = make_shared<long>(boost::any_cast<long>(m["CpuCore"]));
    }
    if (m.find("InstanceCategory") != m.end() && !m["InstanceCategory"].empty()) {
      instanceCategory = make_shared<string>(boost::any_cast<string>(m["InstanceCategory"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("InstanceTypeFamily") != m.end() && !m["InstanceTypeFamily"].empty()) {
      instanceTypeFamily = make_shared<string>(boost::any_cast<string>(m["InstanceTypeFamily"]));
    }
    if (m.find("LocalStorageAmount") != m.end() && !m["LocalStorageAmount"].empty()) {
      localStorageAmount = make_shared<long>(boost::any_cast<long>(m["LocalStorageAmount"]));
    }
    if (m.find("LocalStorageCapacity") != m.end() && !m["LocalStorageCapacity"].empty()) {
      localStorageCapacity = make_shared<long>(boost::any_cast<long>(m["LocalStorageCapacity"]));
    }
    if (m.find("Optimized") != m.end() && !m["Optimized"].empty()) {
      optimized = make_shared<bool>(boost::any_cast<bool>(m["Optimized"]));
    }
  }


  virtual ~InstanceType() = default;
};
class KeyValue : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  KeyValue() {}

  explicit KeyValue(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~KeyValue() = default;
};
class ListApiTemplatesDTO : public Darabonba::Model {
public:
  shared_ptr<string> apiName{};
  shared_ptr<string> content{};
  shared_ptr<long> gmtCreate{};
  shared_ptr<long> gmtModified{};
  shared_ptr<long> id{};
  shared_ptr<string> operatorId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> status{};
  shared_ptr<string> templateId{};
  shared_ptr<string> templateName{};
  shared_ptr<string> userId{};

  ListApiTemplatesDTO() {}

  explicit ListApiTemplatesDTO(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiName) {
      res["ApiName"] = boost::any(*apiName);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (operatorId) {
      res["OperatorId"] = boost::any(*operatorId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (templateName) {
      res["TemplateName"] = boost::any(*templateName);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiName") != m.end() && !m["ApiName"].empty()) {
      apiName = make_shared<string>(boost::any_cast<string>(m["ApiName"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<long>(boost::any_cast<long>(m["GmtModified"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("OperatorId") != m.end() && !m["OperatorId"].empty()) {
      operatorId = make_shared<string>(boost::any_cast<string>(m["OperatorId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("TemplateName") != m.end() && !m["TemplateName"].empty()) {
      templateName = make_shared<string>(boost::any_cast<string>(m["TemplateName"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~ListApiTemplatesDTO() = default;
};
class MetaStoreConf : public Darabonba::Model {
public:
  shared_ptr<string> dbPassword{};
  shared_ptr<string> dbUrl{};
  shared_ptr<string> dbUserName{};

  MetaStoreConf() {}

  explicit MetaStoreConf(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dbPassword) {
      res["DbPassword"] = boost::any(*dbPassword);
    }
    if (dbUrl) {
      res["DbUrl"] = boost::any(*dbUrl);
    }
    if (dbUserName) {
      res["DbUserName"] = boost::any(*dbUserName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DbPassword") != m.end() && !m["DbPassword"].empty()) {
      dbPassword = make_shared<string>(boost::any_cast<string>(m["DbPassword"]));
    }
    if (m.find("DbUrl") != m.end() && !m["DbUrl"].empty()) {
      dbUrl = make_shared<string>(boost::any_cast<string>(m["DbUrl"]));
    }
    if (m.find("DbUserName") != m.end() && !m["DbUserName"].empty()) {
      dbUserName = make_shared<string>(boost::any_cast<string>(m["DbUserName"]));
    }
  }


  virtual ~MetaStoreConf() = default;
};
class Node : public Darabonba::Model {
public:
  shared_ptr<bool> autoRenew{};
  shared_ptr<long> autoRenewDuration{};
  shared_ptr<string> autoRenewDurationUnit{};
  shared_ptr<long> createTime{};
  shared_ptr<long> expireTime{};
  shared_ptr<string> instanceType{};
  shared_ptr<string> maintenanceStatus{};
  shared_ptr<string> nodeGroupId{};
  shared_ptr<string> nodeGroupType{};
  shared_ptr<string> nodeId{};
  shared_ptr<string> nodeName{};
  shared_ptr<string> nodeState{};
  shared_ptr<string> privateIp{};
  shared_ptr<string> publicIp{};
  shared_ptr<string> zoneId{};

  Node() {}

  explicit Node(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoRenew) {
      res["AutoRenew"] = boost::any(*autoRenew);
    }
    if (autoRenewDuration) {
      res["AutoRenewDuration"] = boost::any(*autoRenewDuration);
    }
    if (autoRenewDurationUnit) {
      res["AutoRenewDurationUnit"] = boost::any(*autoRenewDurationUnit);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (expireTime) {
      res["ExpireTime"] = boost::any(*expireTime);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (maintenanceStatus) {
      res["MaintenanceStatus"] = boost::any(*maintenanceStatus);
    }
    if (nodeGroupId) {
      res["NodeGroupId"] = boost::any(*nodeGroupId);
    }
    if (nodeGroupType) {
      res["NodeGroupType"] = boost::any(*nodeGroupType);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (nodeName) {
      res["NodeName"] = boost::any(*nodeName);
    }
    if (nodeState) {
      res["NodeState"] = boost::any(*nodeState);
    }
    if (privateIp) {
      res["PrivateIp"] = boost::any(*privateIp);
    }
    if (publicIp) {
      res["PublicIp"] = boost::any(*publicIp);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AutoRenew") != m.end() && !m["AutoRenew"].empty()) {
      autoRenew = make_shared<bool>(boost::any_cast<bool>(m["AutoRenew"]));
    }
    if (m.find("AutoRenewDuration") != m.end() && !m["AutoRenewDuration"].empty()) {
      autoRenewDuration = make_shared<long>(boost::any_cast<long>(m["AutoRenewDuration"]));
    }
    if (m.find("AutoRenewDurationUnit") != m.end() && !m["AutoRenewDurationUnit"].empty()) {
      autoRenewDurationUnit = make_shared<string>(boost::any_cast<string>(m["AutoRenewDurationUnit"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("ExpireTime") != m.end() && !m["ExpireTime"].empty()) {
      expireTime = make_shared<long>(boost::any_cast<long>(m["ExpireTime"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("MaintenanceStatus") != m.end() && !m["MaintenanceStatus"].empty()) {
      maintenanceStatus = make_shared<string>(boost::any_cast<string>(m["MaintenanceStatus"]));
    }
    if (m.find("NodeGroupId") != m.end() && !m["NodeGroupId"].empty()) {
      nodeGroupId = make_shared<string>(boost::any_cast<string>(m["NodeGroupId"]));
    }
    if (m.find("NodeGroupType") != m.end() && !m["NodeGroupType"].empty()) {
      nodeGroupType = make_shared<string>(boost::any_cast<string>(m["NodeGroupType"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<string>(boost::any_cast<string>(m["NodeId"]));
    }
    if (m.find("NodeName") != m.end() && !m["NodeName"].empty()) {
      nodeName = make_shared<string>(boost::any_cast<string>(m["NodeName"]));
    }
    if (m.find("NodeState") != m.end() && !m["NodeState"].empty()) {
      nodeState = make_shared<string>(boost::any_cast<string>(m["NodeState"]));
    }
    if (m.find("PrivateIp") != m.end() && !m["PrivateIp"].empty()) {
      privateIp = make_shared<string>(boost::any_cast<string>(m["PrivateIp"]));
    }
    if (m.find("PublicIp") != m.end() && !m["PublicIp"].empty()) {
      publicIp = make_shared<string>(boost::any_cast<string>(m["PublicIp"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
  }


  virtual ~Node() = default;
};
class NodeCountConstraint : public Darabonba::Model {
public:
  shared_ptr<long> max{};
  shared_ptr<long> min{};
  shared_ptr<string> type{};
  shared_ptr<vector<long>> values{};

  NodeCountConstraint() {}

  explicit NodeCountConstraint(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (max) {
      res["Max"] = boost::any(*max);
    }
    if (min) {
      res["Min"] = boost::any(*min);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (values) {
      res["Values"] = boost::any(*values);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Max") != m.end() && !m["Max"].empty()) {
      max = make_shared<long>(boost::any_cast<long>(m["Max"]));
    }
    if (m.find("Min") != m.end() && !m["Min"].empty()) {
      min = make_shared<long>(boost::any_cast<long>(m["Min"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Values") != m.end() && !m["Values"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["Values"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Values"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      values = make_shared<vector<long>>(toVec1);
    }
  }


  virtual ~NodeCountConstraint() = default;
};
class SpotBidPrice : public Darabonba::Model {
public:
  shared_ptr<double> bidPrice{};
  shared_ptr<string> instanceType{};

  SpotBidPrice() {}

  explicit SpotBidPrice(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bidPrice) {
      res["BidPrice"] = boost::any(*bidPrice);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BidPrice") != m.end() && !m["BidPrice"].empty()) {
      bidPrice = make_shared<double>(boost::any_cast<double>(m["BidPrice"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
  }


  virtual ~SpotBidPrice() = default;
};
class NodeGroupStateChangeReason : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};

  NodeGroupStateChangeReason() {}

  explicit NodeGroupStateChangeReason(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
  }


  virtual ~NodeGroupStateChangeReason() = default;
};
class SystemDisk : public Darabonba::Model {
public:
  shared_ptr<string> category{};
  shared_ptr<long> count{};
  shared_ptr<string> performanceLevel{};
  shared_ptr<long> size{};

  SystemDisk() {}

  explicit SystemDisk(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (performanceLevel) {
      res["PerformanceLevel"] = boost::any(*performanceLevel);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("PerformanceLevel") != m.end() && !m["PerformanceLevel"].empty()) {
      performanceLevel = make_shared<string>(boost::any_cast<string>(m["PerformanceLevel"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
  }


  virtual ~SystemDisk() = default;
};
class NodeGroup : public Darabonba::Model {
public:
  shared_ptr<vector<string>> additionalSecurityGroupIds{};
  shared_ptr<CostOptimizedConfig> costOptimizedConfig{};
  shared_ptr<vector<DataDisk>> dataDisks{};
  shared_ptr<string> deploymentSetStrategy{};
  shared_ptr<bool> gracefulShutdown{};
  shared_ptr<vector<string>> instanceTypes{};
  shared_ptr<string> nodeGroupId{};
  shared_ptr<string> nodeGroupName{};
  shared_ptr<string> nodeGroupState{};
  shared_ptr<string> nodeGroupType{};
  shared_ptr<string> nodeResizeStrategy{};
  shared_ptr<string> paymentType{};
  shared_ptr<long> runningNodeCount{};
  shared_ptr<vector<SpotBidPrice>> spotBidPrices{};
  shared_ptr<bool> spotInstanceRemedy{};
  shared_ptr<string> spotStrategy{};
  shared_ptr<NodeGroupStateChangeReason> stateChangeReason{};
  shared_ptr<string> status{};
  shared_ptr<SystemDisk> systemDisk{};
  shared_ptr<vector<string>> vSwitchIds{};
  shared_ptr<bool> withPublicIp{};
  shared_ptr<string> zoneId{};

  NodeGroup() {}

  explicit NodeGroup(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (additionalSecurityGroupIds) {
      res["AdditionalSecurityGroupIds"] = boost::any(*additionalSecurityGroupIds);
    }
    if (costOptimizedConfig) {
      res["CostOptimizedConfig"] = costOptimizedConfig ? boost::any(costOptimizedConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (dataDisks) {
      vector<boost::any> temp1;
      for(auto item1:*dataDisks){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataDisks"] = boost::any(temp1);
    }
    if (deploymentSetStrategy) {
      res["DeploymentSetStrategy"] = boost::any(*deploymentSetStrategy);
    }
    if (gracefulShutdown) {
      res["GracefulShutdown"] = boost::any(*gracefulShutdown);
    }
    if (instanceTypes) {
      res["InstanceTypes"] = boost::any(*instanceTypes);
    }
    if (nodeGroupId) {
      res["NodeGroupId"] = boost::any(*nodeGroupId);
    }
    if (nodeGroupName) {
      res["NodeGroupName"] = boost::any(*nodeGroupName);
    }
    if (nodeGroupState) {
      res["NodeGroupState"] = boost::any(*nodeGroupState);
    }
    if (nodeGroupType) {
      res["NodeGroupType"] = boost::any(*nodeGroupType);
    }
    if (nodeResizeStrategy) {
      res["NodeResizeStrategy"] = boost::any(*nodeResizeStrategy);
    }
    if (paymentType) {
      res["PaymentType"] = boost::any(*paymentType);
    }
    if (runningNodeCount) {
      res["RunningNodeCount"] = boost::any(*runningNodeCount);
    }
    if (spotBidPrices) {
      vector<boost::any> temp1;
      for(auto item1:*spotBidPrices){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SpotBidPrices"] = boost::any(temp1);
    }
    if (spotInstanceRemedy) {
      res["SpotInstanceRemedy"] = boost::any(*spotInstanceRemedy);
    }
    if (spotStrategy) {
      res["SpotStrategy"] = boost::any(*spotStrategy);
    }
    if (stateChangeReason) {
      res["StateChangeReason"] = stateChangeReason ? boost::any(stateChangeReason->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (systemDisk) {
      res["SystemDisk"] = systemDisk ? boost::any(systemDisk->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (vSwitchIds) {
      res["VSwitchIds"] = boost::any(*vSwitchIds);
    }
    if (withPublicIp) {
      res["WithPublicIp"] = boost::any(*withPublicIp);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AdditionalSecurityGroupIds") != m.end() && !m["AdditionalSecurityGroupIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["AdditionalSecurityGroupIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["AdditionalSecurityGroupIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      additionalSecurityGroupIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("CostOptimizedConfig") != m.end() && !m["CostOptimizedConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["CostOptimizedConfig"].type()) {
        CostOptimizedConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CostOptimizedConfig"]));
        costOptimizedConfig = make_shared<CostOptimizedConfig>(model1);
      }
    }
    if (m.find("DataDisks") != m.end() && !m["DataDisks"].empty()) {
      if (typeid(vector<boost::any>) == m["DataDisks"].type()) {
        vector<DataDisk> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataDisks"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DataDisk model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataDisks = make_shared<vector<DataDisk>>(expect1);
      }
    }
    if (m.find("DeploymentSetStrategy") != m.end() && !m["DeploymentSetStrategy"].empty()) {
      deploymentSetStrategy = make_shared<string>(boost::any_cast<string>(m["DeploymentSetStrategy"]));
    }
    if (m.find("GracefulShutdown") != m.end() && !m["GracefulShutdown"].empty()) {
      gracefulShutdown = make_shared<bool>(boost::any_cast<bool>(m["GracefulShutdown"]));
    }
    if (m.find("InstanceTypes") != m.end() && !m["InstanceTypes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InstanceTypes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InstanceTypes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceTypes = make_shared<vector<string>>(toVec1);
    }
    if (m.find("NodeGroupId") != m.end() && !m["NodeGroupId"].empty()) {
      nodeGroupId = make_shared<string>(boost::any_cast<string>(m["NodeGroupId"]));
    }
    if (m.find("NodeGroupName") != m.end() && !m["NodeGroupName"].empty()) {
      nodeGroupName = make_shared<string>(boost::any_cast<string>(m["NodeGroupName"]));
    }
    if (m.find("NodeGroupState") != m.end() && !m["NodeGroupState"].empty()) {
      nodeGroupState = make_shared<string>(boost::any_cast<string>(m["NodeGroupState"]));
    }
    if (m.find("NodeGroupType") != m.end() && !m["NodeGroupType"].empty()) {
      nodeGroupType = make_shared<string>(boost::any_cast<string>(m["NodeGroupType"]));
    }
    if (m.find("NodeResizeStrategy") != m.end() && !m["NodeResizeStrategy"].empty()) {
      nodeResizeStrategy = make_shared<string>(boost::any_cast<string>(m["NodeResizeStrategy"]));
    }
    if (m.find("PaymentType") != m.end() && !m["PaymentType"].empty()) {
      paymentType = make_shared<string>(boost::any_cast<string>(m["PaymentType"]));
    }
    if (m.find("RunningNodeCount") != m.end() && !m["RunningNodeCount"].empty()) {
      runningNodeCount = make_shared<long>(boost::any_cast<long>(m["RunningNodeCount"]));
    }
    if (m.find("SpotBidPrices") != m.end() && !m["SpotBidPrices"].empty()) {
      if (typeid(vector<boost::any>) == m["SpotBidPrices"].type()) {
        vector<SpotBidPrice> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SpotBidPrices"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SpotBidPrice model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        spotBidPrices = make_shared<vector<SpotBidPrice>>(expect1);
      }
    }
    if (m.find("SpotInstanceRemedy") != m.end() && !m["SpotInstanceRemedy"].empty()) {
      spotInstanceRemedy = make_shared<bool>(boost::any_cast<bool>(m["SpotInstanceRemedy"]));
    }
    if (m.find("SpotStrategy") != m.end() && !m["SpotStrategy"].empty()) {
      spotStrategy = make_shared<string>(boost::any_cast<string>(m["SpotStrategy"]));
    }
    if (m.find("StateChangeReason") != m.end() && !m["StateChangeReason"].empty()) {
      if (typeid(map<string, boost::any>) == m["StateChangeReason"].type()) {
        NodeGroupStateChangeReason model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["StateChangeReason"]));
        stateChangeReason = make_shared<NodeGroupStateChangeReason>(model1);
      }
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("SystemDisk") != m.end() && !m["SystemDisk"].empty()) {
      if (typeid(map<string, boost::any>) == m["SystemDisk"].type()) {
        SystemDisk model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SystemDisk"]));
        systemDisk = make_shared<SystemDisk>(model1);
      }
    }
    if (m.find("VSwitchIds") != m.end() && !m["VSwitchIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["VSwitchIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["VSwitchIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      vSwitchIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("WithPublicIp") != m.end() && !m["WithPublicIp"].empty()) {
      withPublicIp = make_shared<bool>(boost::any_cast<bool>(m["WithPublicIp"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
  }


  virtual ~NodeGroup() = default;
};
class NodeGroupConfig : public Darabonba::Model {
public:
  shared_ptr<vector<string>> additionalSecurityGroupIds{};
  shared_ptr<vector<string>> componentTags{};
  shared_ptr<CostOptimizedConfig> costOptimizedConfig{};
  shared_ptr<vector<DataDisk>> dataDisks{};
  shared_ptr<string> deploymentSetStrategy{};
  shared_ptr<bool> gracefulShutdown{};
  shared_ptr<vector<string>> instanceTypes{};
  shared_ptr<long> nodeCount{};
  shared_ptr<string> nodeGroupName{};
  shared_ptr<string> nodeGroupType{};
  shared_ptr<string> nodeResizeStrategy{};
  shared_ptr<string> paymentType{};
  shared_ptr<vector<SpotBidPrice>> spotBidPrices{};
  shared_ptr<bool> spotInstanceRemedy{};
  shared_ptr<string> spotStrategy{};
  shared_ptr<SubscriptionConfig> subscriptionConfig{};
  shared_ptr<SystemDisk> systemDisk{};
  shared_ptr<vector<string>> vSwitchIds{};
  shared_ptr<bool> withPublicIp{};

  NodeGroupConfig() {}

  explicit NodeGroupConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (additionalSecurityGroupIds) {
      res["AdditionalSecurityGroupIds"] = boost::any(*additionalSecurityGroupIds);
    }
    if (componentTags) {
      res["ComponentTags"] = boost::any(*componentTags);
    }
    if (costOptimizedConfig) {
      res["CostOptimizedConfig"] = costOptimizedConfig ? boost::any(costOptimizedConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (dataDisks) {
      vector<boost::any> temp1;
      for(auto item1:*dataDisks){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataDisks"] = boost::any(temp1);
    }
    if (deploymentSetStrategy) {
      res["DeploymentSetStrategy"] = boost::any(*deploymentSetStrategy);
    }
    if (gracefulShutdown) {
      res["GracefulShutdown"] = boost::any(*gracefulShutdown);
    }
    if (instanceTypes) {
      res["InstanceTypes"] = boost::any(*instanceTypes);
    }
    if (nodeCount) {
      res["NodeCount"] = boost::any(*nodeCount);
    }
    if (nodeGroupName) {
      res["NodeGroupName"] = boost::any(*nodeGroupName);
    }
    if (nodeGroupType) {
      res["NodeGroupType"] = boost::any(*nodeGroupType);
    }
    if (nodeResizeStrategy) {
      res["NodeResizeStrategy"] = boost::any(*nodeResizeStrategy);
    }
    if (paymentType) {
      res["PaymentType"] = boost::any(*paymentType);
    }
    if (spotBidPrices) {
      vector<boost::any> temp1;
      for(auto item1:*spotBidPrices){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SpotBidPrices"] = boost::any(temp1);
    }
    if (spotInstanceRemedy) {
      res["SpotInstanceRemedy"] = boost::any(*spotInstanceRemedy);
    }
    if (spotStrategy) {
      res["SpotStrategy"] = boost::any(*spotStrategy);
    }
    if (subscriptionConfig) {
      res["SubscriptionConfig"] = subscriptionConfig ? boost::any(subscriptionConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (systemDisk) {
      res["SystemDisk"] = systemDisk ? boost::any(systemDisk->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (vSwitchIds) {
      res["VSwitchIds"] = boost::any(*vSwitchIds);
    }
    if (withPublicIp) {
      res["WithPublicIp"] = boost::any(*withPublicIp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AdditionalSecurityGroupIds") != m.end() && !m["AdditionalSecurityGroupIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["AdditionalSecurityGroupIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["AdditionalSecurityGroupIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      additionalSecurityGroupIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ComponentTags") != m.end() && !m["ComponentTags"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ComponentTags"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ComponentTags"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      componentTags = make_shared<vector<string>>(toVec1);
    }
    if (m.find("CostOptimizedConfig") != m.end() && !m["CostOptimizedConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["CostOptimizedConfig"].type()) {
        CostOptimizedConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CostOptimizedConfig"]));
        costOptimizedConfig = make_shared<CostOptimizedConfig>(model1);
      }
    }
    if (m.find("DataDisks") != m.end() && !m["DataDisks"].empty()) {
      if (typeid(vector<boost::any>) == m["DataDisks"].type()) {
        vector<DataDisk> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataDisks"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DataDisk model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataDisks = make_shared<vector<DataDisk>>(expect1);
      }
    }
    if (m.find("DeploymentSetStrategy") != m.end() && !m["DeploymentSetStrategy"].empty()) {
      deploymentSetStrategy = make_shared<string>(boost::any_cast<string>(m["DeploymentSetStrategy"]));
    }
    if (m.find("GracefulShutdown") != m.end() && !m["GracefulShutdown"].empty()) {
      gracefulShutdown = make_shared<bool>(boost::any_cast<bool>(m["GracefulShutdown"]));
    }
    if (m.find("InstanceTypes") != m.end() && !m["InstanceTypes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InstanceTypes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InstanceTypes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceTypes = make_shared<vector<string>>(toVec1);
    }
    if (m.find("NodeCount") != m.end() && !m["NodeCount"].empty()) {
      nodeCount = make_shared<long>(boost::any_cast<long>(m["NodeCount"]));
    }
    if (m.find("NodeGroupName") != m.end() && !m["NodeGroupName"].empty()) {
      nodeGroupName = make_shared<string>(boost::any_cast<string>(m["NodeGroupName"]));
    }
    if (m.find("NodeGroupType") != m.end() && !m["NodeGroupType"].empty()) {
      nodeGroupType = make_shared<string>(boost::any_cast<string>(m["NodeGroupType"]));
    }
    if (m.find("NodeResizeStrategy") != m.end() && !m["NodeResizeStrategy"].empty()) {
      nodeResizeStrategy = make_shared<string>(boost::any_cast<string>(m["NodeResizeStrategy"]));
    }
    if (m.find("PaymentType") != m.end() && !m["PaymentType"].empty()) {
      paymentType = make_shared<string>(boost::any_cast<string>(m["PaymentType"]));
    }
    if (m.find("SpotBidPrices") != m.end() && !m["SpotBidPrices"].empty()) {
      if (typeid(vector<boost::any>) == m["SpotBidPrices"].type()) {
        vector<SpotBidPrice> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SpotBidPrices"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SpotBidPrice model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        spotBidPrices = make_shared<vector<SpotBidPrice>>(expect1);
      }
    }
    if (m.find("SpotInstanceRemedy") != m.end() && !m["SpotInstanceRemedy"].empty()) {
      spotInstanceRemedy = make_shared<bool>(boost::any_cast<bool>(m["SpotInstanceRemedy"]));
    }
    if (m.find("SpotStrategy") != m.end() && !m["SpotStrategy"].empty()) {
      spotStrategy = make_shared<string>(boost::any_cast<string>(m["SpotStrategy"]));
    }
    if (m.find("SubscriptionConfig") != m.end() && !m["SubscriptionConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["SubscriptionConfig"].type()) {
        SubscriptionConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SubscriptionConfig"]));
        subscriptionConfig = make_shared<SubscriptionConfig>(model1);
      }
    }
    if (m.find("SystemDisk") != m.end() && !m["SystemDisk"].empty()) {
      if (typeid(map<string, boost::any>) == m["SystemDisk"].type()) {
        SystemDisk model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SystemDisk"]));
        systemDisk = make_shared<SystemDisk>(model1);
      }
    }
    if (m.find("VSwitchIds") != m.end() && !m["VSwitchIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["VSwitchIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["VSwitchIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      vSwitchIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("WithPublicIp") != m.end() && !m["WithPublicIp"].empty()) {
      withPublicIp = make_shared<bool>(boost::any_cast<bool>(m["WithPublicIp"]));
    }
  }


  virtual ~NodeGroupConfig() = default;
};
class NodeGroupParam : public Darabonba::Model {
public:
  shared_ptr<bool> autoPayOrder{};
  shared_ptr<bool> autoRenew{};
  shared_ptr<long> autoRenewDuration{};
  shared_ptr<string> autoRenewDurationUnit{};
  shared_ptr<vector<DiskInfo>> dataDisks{};
  shared_ptr<string> description{};
  shared_ptr<vector<string>> instanceTypes{};
  shared_ptr<long> nodeCount{};
  shared_ptr<long> nodeGroupIndex{};
  shared_ptr<string> nodeGroupName{};
  shared_ptr<string> nodeGroupType{};
  shared_ptr<long> paymentDuration{};
  shared_ptr<string> paymentDurationUnit{};
  shared_ptr<string> paymentType{};
  shared_ptr<SystemDiskParam> systemDisk{};
  shared_ptr<vector<string>> vSwitchIds{};
  shared_ptr<string> zoneId{};

  NodeGroupParam() {}

  explicit NodeGroupParam(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoPayOrder) {
      res["AutoPayOrder"] = boost::any(*autoPayOrder);
    }
    if (autoRenew) {
      res["AutoRenew"] = boost::any(*autoRenew);
    }
    if (autoRenewDuration) {
      res["AutoRenewDuration"] = boost::any(*autoRenewDuration);
    }
    if (autoRenewDurationUnit) {
      res["AutoRenewDurationUnit"] = boost::any(*autoRenewDurationUnit);
    }
    if (dataDisks) {
      vector<boost::any> temp1;
      for(auto item1:*dataDisks){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataDisks"] = boost::any(temp1);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (instanceTypes) {
      res["InstanceTypes"] = boost::any(*instanceTypes);
    }
    if (nodeCount) {
      res["NodeCount"] = boost::any(*nodeCount);
    }
    if (nodeGroupIndex) {
      res["NodeGroupIndex"] = boost::any(*nodeGroupIndex);
    }
    if (nodeGroupName) {
      res["NodeGroupName"] = boost::any(*nodeGroupName);
    }
    if (nodeGroupType) {
      res["NodeGroupType"] = boost::any(*nodeGroupType);
    }
    if (paymentDuration) {
      res["PaymentDuration"] = boost::any(*paymentDuration);
    }
    if (paymentDurationUnit) {
      res["PaymentDurationUnit"] = boost::any(*paymentDurationUnit);
    }
    if (paymentType) {
      res["PaymentType"] = boost::any(*paymentType);
    }
    if (systemDisk) {
      res["SystemDisk"] = systemDisk ? boost::any(systemDisk->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (vSwitchIds) {
      res["VSwitchIds"] = boost::any(*vSwitchIds);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AutoPayOrder") != m.end() && !m["AutoPayOrder"].empty()) {
      autoPayOrder = make_shared<bool>(boost::any_cast<bool>(m["AutoPayOrder"]));
    }
    if (m.find("AutoRenew") != m.end() && !m["AutoRenew"].empty()) {
      autoRenew = make_shared<bool>(boost::any_cast<bool>(m["AutoRenew"]));
    }
    if (m.find("AutoRenewDuration") != m.end() && !m["AutoRenewDuration"].empty()) {
      autoRenewDuration = make_shared<long>(boost::any_cast<long>(m["AutoRenewDuration"]));
    }
    if (m.find("AutoRenewDurationUnit") != m.end() && !m["AutoRenewDurationUnit"].empty()) {
      autoRenewDurationUnit = make_shared<string>(boost::any_cast<string>(m["AutoRenewDurationUnit"]));
    }
    if (m.find("DataDisks") != m.end() && !m["DataDisks"].empty()) {
      if (typeid(vector<boost::any>) == m["DataDisks"].type()) {
        vector<DiskInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataDisks"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DiskInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataDisks = make_shared<vector<DiskInfo>>(expect1);
      }
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("InstanceTypes") != m.end() && !m["InstanceTypes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InstanceTypes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InstanceTypes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceTypes = make_shared<vector<string>>(toVec1);
    }
    if (m.find("NodeCount") != m.end() && !m["NodeCount"].empty()) {
      nodeCount = make_shared<long>(boost::any_cast<long>(m["NodeCount"]));
    }
    if (m.find("NodeGroupIndex") != m.end() && !m["NodeGroupIndex"].empty()) {
      nodeGroupIndex = make_shared<long>(boost::any_cast<long>(m["NodeGroupIndex"]));
    }
    if (m.find("NodeGroupName") != m.end() && !m["NodeGroupName"].empty()) {
      nodeGroupName = make_shared<string>(boost::any_cast<string>(m["NodeGroupName"]));
    }
    if (m.find("NodeGroupType") != m.end() && !m["NodeGroupType"].empty()) {
      nodeGroupType = make_shared<string>(boost::any_cast<string>(m["NodeGroupType"]));
    }
    if (m.find("PaymentDuration") != m.end() && !m["PaymentDuration"].empty()) {
      paymentDuration = make_shared<long>(boost::any_cast<long>(m["PaymentDuration"]));
    }
    if (m.find("PaymentDurationUnit") != m.end() && !m["PaymentDurationUnit"].empty()) {
      paymentDurationUnit = make_shared<string>(boost::any_cast<string>(m["PaymentDurationUnit"]));
    }
    if (m.find("PaymentType") != m.end() && !m["PaymentType"].empty()) {
      paymentType = make_shared<string>(boost::any_cast<string>(m["PaymentType"]));
    }
    if (m.find("SystemDisk") != m.end() && !m["SystemDisk"].empty()) {
      if (typeid(map<string, boost::any>) == m["SystemDisk"].type()) {
        SystemDiskParam model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SystemDisk"]));
        systemDisk = make_shared<SystemDiskParam>(model1);
      }
    }
    if (m.find("VSwitchIds") != m.end() && !m["VSwitchIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["VSwitchIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["VSwitchIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      vSwitchIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
  }


  virtual ~NodeGroupParam() = default;
};
class OSUser : public Darabonba::Model {
public:
  shared_ptr<string> group{};
  shared_ptr<string> password{};
  shared_ptr<string> user{};

  OSUser() {}

  explicit OSUser(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (group) {
      res["Group"] = boost::any(*group);
    }
    if (password) {
      res["Password"] = boost::any(*password);
    }
    if (user) {
      res["User"] = boost::any(*user);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Group") != m.end() && !m["Group"].empty()) {
      group = make_shared<string>(boost::any_cast<string>(m["Group"]));
    }
    if (m.find("Password") != m.end() && !m["Password"].empty()) {
      password = make_shared<string>(boost::any_cast<string>(m["Password"]));
    }
    if (m.find("User") != m.end() && !m["User"].empty()) {
      user = make_shared<string>(boost::any_cast<string>(m["User"]));
    }
  }


  virtual ~OSUser() = default;
};
class OnKubeClusterResource : public Darabonba::Model {
public:
  shared_ptr<string> cpu{};
  shared_ptr<string> memory{};

  OnKubeClusterResource() {}

  explicit OnKubeClusterResource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cpu) {
      res["Cpu"] = boost::any(*cpu);
    }
    if (memory) {
      res["Memory"] = boost::any(*memory);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cpu") != m.end() && !m["Cpu"].empty()) {
      cpu = make_shared<string>(boost::any_cast<string>(m["Cpu"]));
    }
    if (m.find("Memory") != m.end() && !m["Memory"].empty()) {
      memory = make_shared<string>(boost::any_cast<string>(m["Memory"]));
    }
  }


  virtual ~OnKubeClusterResource() = default;
};
class OperationStateChangeReason : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};

  OperationStateChangeReason() {}

  explicit OperationStateChangeReason(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
  }


  virtual ~OperationStateChangeReason() = default;
};
class Operation : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<long> createTime{};
  shared_ptr<string> description{};
  shared_ptr<long> endTime{};
  shared_ptr<string> operationId{};
  shared_ptr<string> operationState{};
  shared_ptr<string> operationType{};
  shared_ptr<long> startTime{};
  shared_ptr<OperationStateChangeReason> stateChangeReason{};

  Operation() {}

  explicit Operation(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (operationId) {
      res["OperationId"] = boost::any(*operationId);
    }
    if (operationState) {
      res["OperationState"] = boost::any(*operationState);
    }
    if (operationType) {
      res["OperationType"] = boost::any(*operationType);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (stateChangeReason) {
      res["StateChangeReason"] = stateChangeReason ? boost::any(stateChangeReason->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("OperationId") != m.end() && !m["OperationId"].empty()) {
      operationId = make_shared<string>(boost::any_cast<string>(m["OperationId"]));
    }
    if (m.find("OperationState") != m.end() && !m["OperationState"].empty()) {
      operationState = make_shared<string>(boost::any_cast<string>(m["OperationState"]));
    }
    if (m.find("OperationType") != m.end() && !m["OperationType"].empty()) {
      operationType = make_shared<string>(boost::any_cast<string>(m["OperationType"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("StateChangeReason") != m.end() && !m["StateChangeReason"].empty()) {
      if (typeid(map<string, boost::any>) == m["StateChangeReason"].type()) {
        OperationStateChangeReason model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["StateChangeReason"]));
        stateChangeReason = make_shared<OperationStateChangeReason>(model1);
      }
    }
  }


  virtual ~Operation() = default;
};
class OperationData : public Darabonba::Model {
public:
  shared_ptr<long> actualDeliveredAmounts{};
  shared_ptr<long> toBeDeliveredAmounts{};

  OperationData() {}

  explicit OperationData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (actualDeliveredAmounts) {
      res["actualDeliveredAmounts"] = boost::any(*actualDeliveredAmounts);
    }
    if (toBeDeliveredAmounts) {
      res["toBeDeliveredAmounts"] = boost::any(*toBeDeliveredAmounts);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("actualDeliveredAmounts") != m.end() && !m["actualDeliveredAmounts"].empty()) {
      actualDeliveredAmounts = make_shared<long>(boost::any_cast<long>(m["actualDeliveredAmounts"]));
    }
    if (m.find("toBeDeliveredAmounts") != m.end() && !m["toBeDeliveredAmounts"].empty()) {
      toBeDeliveredAmounts = make_shared<long>(boost::any_cast<long>(m["toBeDeliveredAmounts"]));
    }
  }


  virtual ~OperationData() = default;
};
class Order : public Darabonba::Model {
public:
  shared_ptr<string> createTime{};
  shared_ptr<string> orderId{};

  Order() {}

  explicit Order(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<string>(boost::any_cast<string>(m["OrderId"]));
    }
  }


  virtual ~Order() = default;
};
class Page : public Darabonba::Model {
public:
  shared_ptr<vector<string>> items{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<long> totalCount{};

  Page() {}

  explicit Page(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (items) {
      res["Items"] = boost::any(*items);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Items") != m.end() && !m["Items"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Items"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Items"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      items = make_shared<vector<string>>(toVec1);
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~Page() = default;
};
class Pod : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> podName{};
  shared_ptr<string> podStatus{};
  shared_ptr<string> reason{};

  Pod() {}

  explicit Pod(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (podName) {
      res["PodName"] = boost::any(*podName);
    }
    if (podStatus) {
      res["PodStatus"] = boost::any(*podStatus);
    }
    if (reason) {
      res["Reason"] = boost::any(*reason);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("PodName") != m.end() && !m["PodName"].empty()) {
      podName = make_shared<string>(boost::any_cast<string>(m["PodName"]));
    }
    if (m.find("PodStatus") != m.end() && !m["PodStatus"].empty()) {
      podStatus = make_shared<string>(boost::any_cast<string>(m["PodStatus"]));
    }
    if (m.find("Reason") != m.end() && !m["Reason"].empty()) {
      reason = make_shared<string>(boost::any_cast<string>(m["Reason"]));
    }
  }


  virtual ~Pod() = default;
};
class PromotionInfo : public Darabonba::Model {
public:
  shared_ptr<string> canPromFee{};
  shared_ptr<string> isSelected{};
  shared_ptr<string> promotionDesc{};
  shared_ptr<string> promotionName{};
  shared_ptr<string> promotionOptionCode{};
  shared_ptr<string> promotionOptionNo{};

  PromotionInfo() {}

  explicit PromotionInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (canPromFee) {
      res["CanPromFee"] = boost::any(*canPromFee);
    }
    if (isSelected) {
      res["IsSelected"] = boost::any(*isSelected);
    }
    if (promotionDesc) {
      res["PromotionDesc"] = boost::any(*promotionDesc);
    }
    if (promotionName) {
      res["PromotionName"] = boost::any(*promotionName);
    }
    if (promotionOptionCode) {
      res["PromotionOptionCode"] = boost::any(*promotionOptionCode);
    }
    if (promotionOptionNo) {
      res["PromotionOptionNo"] = boost::any(*promotionOptionNo);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CanPromFee") != m.end() && !m["CanPromFee"].empty()) {
      canPromFee = make_shared<string>(boost::any_cast<string>(m["CanPromFee"]));
    }
    if (m.find("IsSelected") != m.end() && !m["IsSelected"].empty()) {
      isSelected = make_shared<string>(boost::any_cast<string>(m["IsSelected"]));
    }
    if (m.find("PromotionDesc") != m.end() && !m["PromotionDesc"].empty()) {
      promotionDesc = make_shared<string>(boost::any_cast<string>(m["PromotionDesc"]));
    }
    if (m.find("PromotionName") != m.end() && !m["PromotionName"].empty()) {
      promotionName = make_shared<string>(boost::any_cast<string>(m["PromotionName"]));
    }
    if (m.find("PromotionOptionCode") != m.end() && !m["PromotionOptionCode"].empty()) {
      promotionOptionCode = make_shared<string>(boost::any_cast<string>(m["PromotionOptionCode"]));
    }
    if (m.find("PromotionOptionNo") != m.end() && !m["PromotionOptionNo"].empty()) {
      promotionOptionNo = make_shared<string>(boost::any_cast<string>(m["PromotionOptionNo"]));
    }
  }


  virtual ~PromotionInfo() = default;
};
class PriceInfo : public Darabonba::Model {
public:
  shared_ptr<string> currency{};
  shared_ptr<string> discountPrice{};
  shared_ptr<string> originalPrice{};
  shared_ptr<string> payType{};
  shared_ptr<vector<PromotionInfo>> promotionResults{};
  shared_ptr<string> resourceType{};
  shared_ptr<string> spotInstanceTypeOriginalPrice{};
  shared_ptr<string> spotInstanceTypePrice{};
  shared_ptr<string> spotOriginalPrice{};
  shared_ptr<string> spotPrice{};
  shared_ptr<string> taxPrice{};
  shared_ptr<string> tradePrice{};

  PriceInfo() {}

  explicit PriceInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currency) {
      res["Currency"] = boost::any(*currency);
    }
    if (discountPrice) {
      res["DiscountPrice"] = boost::any(*discountPrice);
    }
    if (originalPrice) {
      res["OriginalPrice"] = boost::any(*originalPrice);
    }
    if (payType) {
      res["PayType"] = boost::any(*payType);
    }
    if (promotionResults) {
      vector<boost::any> temp1;
      for(auto item1:*promotionResults){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PromotionResults"] = boost::any(temp1);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (spotInstanceTypeOriginalPrice) {
      res["SpotInstanceTypeOriginalPrice"] = boost::any(*spotInstanceTypeOriginalPrice);
    }
    if (spotInstanceTypePrice) {
      res["SpotInstanceTypePrice"] = boost::any(*spotInstanceTypePrice);
    }
    if (spotOriginalPrice) {
      res["SpotOriginalPrice"] = boost::any(*spotOriginalPrice);
    }
    if (spotPrice) {
      res["SpotPrice"] = boost::any(*spotPrice);
    }
    if (taxPrice) {
      res["TaxPrice"] = boost::any(*taxPrice);
    }
    if (tradePrice) {
      res["TradePrice"] = boost::any(*tradePrice);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Currency") != m.end() && !m["Currency"].empty()) {
      currency = make_shared<string>(boost::any_cast<string>(m["Currency"]));
    }
    if (m.find("DiscountPrice") != m.end() && !m["DiscountPrice"].empty()) {
      discountPrice = make_shared<string>(boost::any_cast<string>(m["DiscountPrice"]));
    }
    if (m.find("OriginalPrice") != m.end() && !m["OriginalPrice"].empty()) {
      originalPrice = make_shared<string>(boost::any_cast<string>(m["OriginalPrice"]));
    }
    if (m.find("PayType") != m.end() && !m["PayType"].empty()) {
      payType = make_shared<string>(boost::any_cast<string>(m["PayType"]));
    }
    if (m.find("PromotionResults") != m.end() && !m["PromotionResults"].empty()) {
      if (typeid(vector<boost::any>) == m["PromotionResults"].type()) {
        vector<PromotionInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PromotionResults"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            PromotionInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        promotionResults = make_shared<vector<PromotionInfo>>(expect1);
      }
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("SpotInstanceTypeOriginalPrice") != m.end() && !m["SpotInstanceTypeOriginalPrice"].empty()) {
      spotInstanceTypeOriginalPrice = make_shared<string>(boost::any_cast<string>(m["SpotInstanceTypeOriginalPrice"]));
    }
    if (m.find("SpotInstanceTypePrice") != m.end() && !m["SpotInstanceTypePrice"].empty()) {
      spotInstanceTypePrice = make_shared<string>(boost::any_cast<string>(m["SpotInstanceTypePrice"]));
    }
    if (m.find("SpotOriginalPrice") != m.end() && !m["SpotOriginalPrice"].empty()) {
      spotOriginalPrice = make_shared<string>(boost::any_cast<string>(m["SpotOriginalPrice"]));
    }
    if (m.find("SpotPrice") != m.end() && !m["SpotPrice"].empty()) {
      spotPrice = make_shared<string>(boost::any_cast<string>(m["SpotPrice"]));
    }
    if (m.find("TaxPrice") != m.end() && !m["TaxPrice"].empty()) {
      taxPrice = make_shared<string>(boost::any_cast<string>(m["TaxPrice"]));
    }
    if (m.find("TradePrice") != m.end() && !m["TradePrice"].empty()) {
      tradePrice = make_shared<string>(boost::any_cast<string>(m["TradePrice"]));
    }
  }


  virtual ~PriceInfo() = default;
};
class Promotion : public Darabonba::Model {
public:
  shared_ptr<string> productCode{};
  shared_ptr<string> promotionDesc{};
  shared_ptr<string> promotionName{};
  shared_ptr<string> promotionOptionCode{};
  shared_ptr<string> promotionOptionNo{};

  Promotion() {}

  explicit Promotion(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (productCode) {
      res["ProductCode"] = boost::any(*productCode);
    }
    if (promotionDesc) {
      res["PromotionDesc"] = boost::any(*promotionDesc);
    }
    if (promotionName) {
      res["PromotionName"] = boost::any(*promotionName);
    }
    if (promotionOptionCode) {
      res["PromotionOptionCode"] = boost::any(*promotionOptionCode);
    }
    if (promotionOptionNo) {
      res["PromotionOptionNo"] = boost::any(*promotionOptionNo);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProductCode") != m.end() && !m["ProductCode"].empty()) {
      productCode = make_shared<string>(boost::any_cast<string>(m["ProductCode"]));
    }
    if (m.find("PromotionDesc") != m.end() && !m["PromotionDesc"].empty()) {
      promotionDesc = make_shared<string>(boost::any_cast<string>(m["PromotionDesc"]));
    }
    if (m.find("PromotionName") != m.end() && !m["PromotionName"].empty()) {
      promotionName = make_shared<string>(boost::any_cast<string>(m["PromotionName"]));
    }
    if (m.find("PromotionOptionCode") != m.end() && !m["PromotionOptionCode"].empty()) {
      promotionOptionCode = make_shared<string>(boost::any_cast<string>(m["PromotionOptionCode"]));
    }
    if (m.find("PromotionOptionNo") != m.end() && !m["PromotionOptionNo"].empty()) {
      promotionOptionNo = make_shared<string>(boost::any_cast<string>(m["PromotionOptionNo"]));
    }
  }


  virtual ~Promotion() = default;
};
class PromotionParam : public Darabonba::Model {
public:
  shared_ptr<string> productCode{};
  shared_ptr<string> promotionOptionCode{};
  shared_ptr<string> promotionOptionNo{};

  PromotionParam() {}

  explicit PromotionParam(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (productCode) {
      res["ProductCode"] = boost::any(*productCode);
    }
    if (promotionOptionCode) {
      res["PromotionOptionCode"] = boost::any(*promotionOptionCode);
    }
    if (promotionOptionNo) {
      res["PromotionOptionNo"] = boost::any(*promotionOptionNo);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProductCode") != m.end() && !m["ProductCode"].empty()) {
      productCode = make_shared<string>(boost::any_cast<string>(m["ProductCode"]));
    }
    if (m.find("PromotionOptionCode") != m.end() && !m["PromotionOptionCode"].empty()) {
      promotionOptionCode = make_shared<string>(boost::any_cast<string>(m["PromotionOptionCode"]));
    }
    if (m.find("PromotionOptionNo") != m.end() && !m["PromotionOptionNo"].empty()) {
      promotionOptionNo = make_shared<string>(boost::any_cast<string>(m["PromotionOptionNo"]));
    }
  }


  virtual ~PromotionParam() = default;
};
class RecommendScalingRule : public Darabonba::Model {
public:
  shared_ptr<string> activityType{};
  shared_ptr<long> adjustmentValue{};
  shared_ptr<string> instanceType{};
  shared_ptr<double> maxSave{};
  shared_ptr<MetricsTrigger> metricsTrigger{};
  shared_ptr<string> ruleName{};
  shared_ptr<TimeTrigger> timeTrigger{};
  shared_ptr<string> triggerType{};

  RecommendScalingRule() {}

  explicit RecommendScalingRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (activityType) {
      res["ActivityType"] = boost::any(*activityType);
    }
    if (adjustmentValue) {
      res["AdjustmentValue"] = boost::any(*adjustmentValue);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (maxSave) {
      res["MaxSave"] = boost::any(*maxSave);
    }
    if (metricsTrigger) {
      res["MetricsTrigger"] = metricsTrigger ? boost::any(metricsTrigger->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    if (timeTrigger) {
      res["TimeTrigger"] = timeTrigger ? boost::any(timeTrigger->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (triggerType) {
      res["TriggerType"] = boost::any(*triggerType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActivityType") != m.end() && !m["ActivityType"].empty()) {
      activityType = make_shared<string>(boost::any_cast<string>(m["ActivityType"]));
    }
    if (m.find("AdjustmentValue") != m.end() && !m["AdjustmentValue"].empty()) {
      adjustmentValue = make_shared<long>(boost::any_cast<long>(m["AdjustmentValue"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("MaxSave") != m.end() && !m["MaxSave"].empty()) {
      maxSave = make_shared<double>(boost::any_cast<double>(m["MaxSave"]));
    }
    if (m.find("MetricsTrigger") != m.end() && !m["MetricsTrigger"].empty()) {
      if (typeid(map<string, boost::any>) == m["MetricsTrigger"].type()) {
        MetricsTrigger model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MetricsTrigger"]));
        metricsTrigger = make_shared<MetricsTrigger>(model1);
      }
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
    if (m.find("TimeTrigger") != m.end() && !m["TimeTrigger"].empty()) {
      if (typeid(map<string, boost::any>) == m["TimeTrigger"].type()) {
        TimeTrigger model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TimeTrigger"]));
        timeTrigger = make_shared<TimeTrigger>(model1);
      }
    }
    if (m.find("TriggerType") != m.end() && !m["TriggerType"].empty()) {
      triggerType = make_shared<string>(boost::any_cast<string>(m["TriggerType"]));
    }
  }


  virtual ~RecommendScalingRule() = default;
};
class RenewInstance : public Darabonba::Model {
public:
  shared_ptr<long> emrRenewDuration{};
  shared_ptr<string> emrRenewDurationUnit{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> renewDuration{};
  shared_ptr<string> renewDurationUnit{};

  RenewInstance() {}

  explicit RenewInstance(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (emrRenewDuration) {
      res["EmrRenewDuration"] = boost::any(*emrRenewDuration);
    }
    if (emrRenewDurationUnit) {
      res["EmrRenewDurationUnit"] = boost::any(*emrRenewDurationUnit);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (renewDuration) {
      res["RenewDuration"] = boost::any(*renewDuration);
    }
    if (renewDurationUnit) {
      res["RenewDurationUnit"] = boost::any(*renewDurationUnit);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EmrRenewDuration") != m.end() && !m["EmrRenewDuration"].empty()) {
      emrRenewDuration = make_shared<long>(boost::any_cast<long>(m["EmrRenewDuration"]));
    }
    if (m.find("EmrRenewDurationUnit") != m.end() && !m["EmrRenewDurationUnit"].empty()) {
      emrRenewDurationUnit = make_shared<string>(boost::any_cast<string>(m["EmrRenewDurationUnit"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RenewDuration") != m.end() && !m["RenewDuration"].empty()) {
      renewDuration = make_shared<long>(boost::any_cast<long>(m["RenewDuration"]));
    }
    if (m.find("RenewDurationUnit") != m.end() && !m["RenewDurationUnit"].empty()) {
      renewDurationUnit = make_shared<string>(boost::any_cast<string>(m["RenewDurationUnit"]));
    }
  }


  virtual ~RenewInstance() = default;
};
class RenewInstanceParam : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<long> renewDuration{};
  shared_ptr<string> renewDurationUnit{};

  RenewInstanceParam() {}

  explicit RenewInstanceParam(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (renewDuration) {
      res["RenewDuration"] = boost::any(*renewDuration);
    }
    if (renewDurationUnit) {
      res["RenewDurationUnit"] = boost::any(*renewDurationUnit);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RenewDuration") != m.end() && !m["RenewDuration"].empty()) {
      renewDuration = make_shared<long>(boost::any_cast<long>(m["RenewDuration"]));
    }
    if (m.find("RenewDurationUnit") != m.end() && !m["RenewDurationUnit"].empty()) {
      renewDurationUnit = make_shared<string>(boost::any_cast<string>(m["RenewDurationUnit"]));
    }
  }


  virtual ~RenewInstanceParam() = default;
};
class RequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  RequestTag() {}

  explicit RequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~RequestTag() = default;
};
class ResizeDiskNodeGroupParam : public Darabonba::Model {
public:
  shared_ptr<long> dataDiskCapacity{};
  shared_ptr<string> nodeGroupId{};
  shared_ptr<bool> rollingRestart{};

  ResizeDiskNodeGroupParam() {}

  explicit ResizeDiskNodeGroupParam(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataDiskCapacity) {
      res["DataDiskCapacity"] = boost::any(*dataDiskCapacity);
    }
    if (nodeGroupId) {
      res["NodeGroupId"] = boost::any(*nodeGroupId);
    }
    if (rollingRestart) {
      res["RollingRestart"] = boost::any(*rollingRestart);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataDiskCapacity") != m.end() && !m["DataDiskCapacity"].empty()) {
      dataDiskCapacity = make_shared<long>(boost::any_cast<long>(m["DataDiskCapacity"]));
    }
    if (m.find("NodeGroupId") != m.end() && !m["NodeGroupId"].empty()) {
      nodeGroupId = make_shared<string>(boost::any_cast<string>(m["NodeGroupId"]));
    }
    if (m.find("RollingRestart") != m.end() && !m["RollingRestart"].empty()) {
      rollingRestart = make_shared<bool>(boost::any_cast<bool>(m["RollingRestart"]));
    }
  }


  virtual ~ResizeDiskNodeGroupParam() = default;
};
class ScalingActivity : public Darabonba::Model {
public:
  shared_ptr<string> cause{};
  shared_ptr<string> description{};
  shared_ptr<long> endTime{};
  shared_ptr<string> essScalingRuleId{};
  shared_ptr<long> expectNum{};
  shared_ptr<string> hostGroupName{};
  shared_ptr<string> id{};
  shared_ptr<string> instanceIds{};
  shared_ptr<string> scalingGroupId{};
  shared_ptr<string> scalingRuleName{};
  shared_ptr<long> startTime{};
  shared_ptr<string> status{};
  shared_ptr<long> totalCapacity{};
  shared_ptr<string> transition{};

  ScalingActivity() {}

  explicit ScalingActivity(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cause) {
      res["Cause"] = boost::any(*cause);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (essScalingRuleId) {
      res["EssScalingRuleId"] = boost::any(*essScalingRuleId);
    }
    if (expectNum) {
      res["ExpectNum"] = boost::any(*expectNum);
    }
    if (hostGroupName) {
      res["HostGroupName"] = boost::any(*hostGroupName);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (instanceIds) {
      res["InstanceIds"] = boost::any(*instanceIds);
    }
    if (scalingGroupId) {
      res["ScalingGroupId"] = boost::any(*scalingGroupId);
    }
    if (scalingRuleName) {
      res["ScalingRuleName"] = boost::any(*scalingRuleName);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (totalCapacity) {
      res["TotalCapacity"] = boost::any(*totalCapacity);
    }
    if (transition) {
      res["Transition"] = boost::any(*transition);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cause") != m.end() && !m["Cause"].empty()) {
      cause = make_shared<string>(boost::any_cast<string>(m["Cause"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("EssScalingRuleId") != m.end() && !m["EssScalingRuleId"].empty()) {
      essScalingRuleId = make_shared<string>(boost::any_cast<string>(m["EssScalingRuleId"]));
    }
    if (m.find("ExpectNum") != m.end() && !m["ExpectNum"].empty()) {
      expectNum = make_shared<long>(boost::any_cast<long>(m["ExpectNum"]));
    }
    if (m.find("HostGroupName") != m.end() && !m["HostGroupName"].empty()) {
      hostGroupName = make_shared<string>(boost::any_cast<string>(m["HostGroupName"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("InstanceIds") != m.end() && !m["InstanceIds"].empty()) {
      instanceIds = make_shared<string>(boost::any_cast<string>(m["InstanceIds"]));
    }
    if (m.find("ScalingGroupId") != m.end() && !m["ScalingGroupId"].empty()) {
      scalingGroupId = make_shared<string>(boost::any_cast<string>(m["ScalingGroupId"]));
    }
    if (m.find("ScalingRuleName") != m.end() && !m["ScalingRuleName"].empty()) {
      scalingRuleName = make_shared<string>(boost::any_cast<string>(m["ScalingRuleName"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TotalCapacity") != m.end() && !m["TotalCapacity"].empty()) {
      totalCapacity = make_shared<long>(boost::any_cast<long>(m["TotalCapacity"]));
    }
    if (m.find("Transition") != m.end() && !m["Transition"].empty()) {
      transition = make_shared<string>(boost::any_cast<string>(m["Transition"]));
    }
  }


  virtual ~ScalingActivity() = default;
};
class ScalingActivityResult : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};

  ScalingActivityResult() {}

  explicit ScalingActivityResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~ScalingActivityResult() = default;
};
class ScalingActivityResultDTO : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};

  ScalingActivityResultDTO() {}

  explicit ScalingActivityResultDTO(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~ScalingActivityResultDTO() = default;
};
class ScalingAnalyzeResult : public Darabonba::Model {
public:
  shared_ptr<double> actualUsage{};
  shared_ptr<double> idealUsage{};
  shared_ptr<long> releaseCores{};
  shared_ptr<long> reservedCores{};

  ScalingAnalyzeResult() {}

  explicit ScalingAnalyzeResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (actualUsage) {
      res["ActualUsage"] = boost::any(*actualUsage);
    }
    if (idealUsage) {
      res["IdealUsage"] = boost::any(*idealUsage);
    }
    if (releaseCores) {
      res["ReleaseCores"] = boost::any(*releaseCores);
    }
    if (reservedCores) {
      res["ReservedCores"] = boost::any(*reservedCores);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActualUsage") != m.end() && !m["ActualUsage"].empty()) {
      actualUsage = make_shared<double>(boost::any_cast<double>(m["ActualUsage"]));
    }
    if (m.find("IdealUsage") != m.end() && !m["IdealUsage"].empty()) {
      idealUsage = make_shared<double>(boost::any_cast<double>(m["IdealUsage"]));
    }
    if (m.find("ReleaseCores") != m.end() && !m["ReleaseCores"].empty()) {
      releaseCores = make_shared<long>(boost::any_cast<long>(m["ReleaseCores"]));
    }
    if (m.find("ReservedCores") != m.end() && !m["ReservedCores"].empty()) {
      reservedCores = make_shared<long>(boost::any_cast<long>(m["ReservedCores"]));
    }
  }


  virtual ~ScalingAnalyzeResult() = default;
};
class ScalingAnalyzeTimeRange : public Darabonba::Model {
public:
  shared_ptr<long> endTime{};
  shared_ptr<long> startTime{};
  shared_ptr<string> type{};

  ScalingAnalyzeTimeRange() {}

  explicit ScalingAnalyzeTimeRange(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ScalingAnalyzeTimeRange() = default;
};
class ScalingConstraints : public Darabonba::Model {
public:
  shared_ptr<long> maxCapacity{};
  shared_ptr<long> minCapacity{};

  ScalingConstraints() {}

  explicit ScalingConstraints(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxCapacity) {
      res["MaxCapacity"] = boost::any(*maxCapacity);
    }
    if (minCapacity) {
      res["MinCapacity"] = boost::any(*minCapacity);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MaxCapacity") != m.end() && !m["MaxCapacity"].empty()) {
      maxCapacity = make_shared<long>(boost::any_cast<long>(m["MaxCapacity"]));
    }
    if (m.find("MinCapacity") != m.end() && !m["MinCapacity"].empty()) {
      minCapacity = make_shared<long>(boost::any_cast<long>(m["MinCapacity"]));
    }
  }


  virtual ~ScalingConstraints() = default;
};
class ScalingGroupConfigInstanceTypeList : public Darabonba::Model {
public:
  shared_ptr<string> instanceType{};
  shared_ptr<double> spotPriceLimit{};

  ScalingGroupConfigInstanceTypeList() {}

  explicit ScalingGroupConfigInstanceTypeList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (spotPriceLimit) {
      res["SpotPriceLimit"] = boost::any(*spotPriceLimit);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("SpotPriceLimit") != m.end() && !m["SpotPriceLimit"].empty()) {
      spotPriceLimit = make_shared<double>(boost::any_cast<double>(m["SpotPriceLimit"]));
    }
  }


  virtual ~ScalingGroupConfigInstanceTypeList() = default;
};
class ScalingGroupConfigMultiAvailablePolicyPolicyParam : public Darabonba::Model {
public:
  shared_ptr<long> onDemandBaseCapacity{};
  shared_ptr<long> onDemandPercentageAboveBaseCapacity{};
  shared_ptr<long> spotInstancePools{};
  shared_ptr<bool> spotInstanceRemedy{};

  ScalingGroupConfigMultiAvailablePolicyPolicyParam() {}

  explicit ScalingGroupConfigMultiAvailablePolicyPolicyParam(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (onDemandBaseCapacity) {
      res["OnDemandBaseCapacity"] = boost::any(*onDemandBaseCapacity);
    }
    if (onDemandPercentageAboveBaseCapacity) {
      res["OnDemandPercentageAboveBaseCapacity"] = boost::any(*onDemandPercentageAboveBaseCapacity);
    }
    if (spotInstancePools) {
      res["SpotInstancePools"] = boost::any(*spotInstancePools);
    }
    if (spotInstanceRemedy) {
      res["SpotInstanceRemedy"] = boost::any(*spotInstanceRemedy);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OnDemandBaseCapacity") != m.end() && !m["OnDemandBaseCapacity"].empty()) {
      onDemandBaseCapacity = make_shared<long>(boost::any_cast<long>(m["OnDemandBaseCapacity"]));
    }
    if (m.find("OnDemandPercentageAboveBaseCapacity") != m.end() && !m["OnDemandPercentageAboveBaseCapacity"].empty()) {
      onDemandPercentageAboveBaseCapacity = make_shared<long>(boost::any_cast<long>(m["OnDemandPercentageAboveBaseCapacity"]));
    }
    if (m.find("SpotInstancePools") != m.end() && !m["SpotInstancePools"].empty()) {
      spotInstancePools = make_shared<long>(boost::any_cast<long>(m["SpotInstancePools"]));
    }
    if (m.find("SpotInstanceRemedy") != m.end() && !m["SpotInstanceRemedy"].empty()) {
      spotInstanceRemedy = make_shared<bool>(boost::any_cast<bool>(m["SpotInstanceRemedy"]));
    }
  }


  virtual ~ScalingGroupConfigMultiAvailablePolicyPolicyParam() = default;
};
class ScalingGroupConfigMultiAvailablePolicy : public Darabonba::Model {
public:
  shared_ptr<ScalingGroupConfigMultiAvailablePolicyPolicyParam> policyParam{};
  shared_ptr<string> policyType{};

  ScalingGroupConfigMultiAvailablePolicy() {}

  explicit ScalingGroupConfigMultiAvailablePolicy(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (policyParam) {
      res["PolicyParam"] = policyParam ? boost::any(policyParam->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (policyType) {
      res["PolicyType"] = boost::any(*policyType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PolicyParam") != m.end() && !m["PolicyParam"].empty()) {
      if (typeid(map<string, boost::any>) == m["PolicyParam"].type()) {
        ScalingGroupConfigMultiAvailablePolicyPolicyParam model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PolicyParam"]));
        policyParam = make_shared<ScalingGroupConfigMultiAvailablePolicyPolicyParam>(model1);
      }
    }
    if (m.find("PolicyType") != m.end() && !m["PolicyType"].empty()) {
      policyType = make_shared<string>(boost::any_cast<string>(m["PolicyType"]));
    }
  }


  virtual ~ScalingGroupConfigMultiAvailablePolicy() = default;
};
class ScalingGroupConfigNodeOfflinePolicy : public Darabonba::Model {
public:
  shared_ptr<string> mode{};
  shared_ptr<long> timeoutMs{};

  ScalingGroupConfigNodeOfflinePolicy() {}

  explicit ScalingGroupConfigNodeOfflinePolicy(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mode) {
      res["Mode"] = boost::any(*mode);
    }
    if (timeoutMs) {
      res["TimeoutMs"] = boost::any(*timeoutMs);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Mode") != m.end() && !m["Mode"].empty()) {
      mode = make_shared<string>(boost::any_cast<string>(m["Mode"]));
    }
    if (m.find("TimeoutMs") != m.end() && !m["TimeoutMs"].empty()) {
      timeoutMs = make_shared<long>(boost::any_cast<long>(m["TimeoutMs"]));
    }
  }


  virtual ~ScalingGroupConfigNodeOfflinePolicy() = default;
};
class ScalingGroupConfigPrivatePoolOptions : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> matchCriteria{};

  ScalingGroupConfigPrivatePoolOptions() {}

  explicit ScalingGroupConfigPrivatePoolOptions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (matchCriteria) {
      res["MatchCriteria"] = boost::any(*matchCriteria);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("MatchCriteria") != m.end() && !m["MatchCriteria"].empty()) {
      matchCriteria = make_shared<string>(boost::any_cast<string>(m["MatchCriteria"]));
    }
  }


  virtual ~ScalingGroupConfigPrivatePoolOptions() = default;
};
class ScalingGroupConfig : public Darabonba::Model {
public:
  shared_ptr<string> dataDiskCategory{};
  shared_ptr<long> dataDiskCount{};
  shared_ptr<long> dataDiskSize{};
  shared_ptr<long> defaultCoolDownTime{};
  shared_ptr<vector<ScalingGroupConfigInstanceTypeList>> instanceTypeList{};
  shared_ptr<ScalingGroupConfigMultiAvailablePolicy> multiAvailablePolicy{};
  shared_ptr<ScalingGroupConfigNodeOfflinePolicy> nodeOfflinePolicy{};
  shared_ptr<ScalingGroupConfigPrivatePoolOptions> privatePoolOptions{};
  shared_ptr<long> scalingMaxSize{};
  shared_ptr<long> scalingMinSize{};
  shared_ptr<string> spotStrategy{};
  shared_ptr<string> sysDiskCategory{};
  shared_ptr<long> sysDiskSize{};
  shared_ptr<string> triggerMode{};

  ScalingGroupConfig() {}

  explicit ScalingGroupConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataDiskCategory) {
      res["DataDiskCategory"] = boost::any(*dataDiskCategory);
    }
    if (dataDiskCount) {
      res["DataDiskCount"] = boost::any(*dataDiskCount);
    }
    if (dataDiskSize) {
      res["DataDiskSize"] = boost::any(*dataDiskSize);
    }
    if (defaultCoolDownTime) {
      res["DefaultCoolDownTime"] = boost::any(*defaultCoolDownTime);
    }
    if (instanceTypeList) {
      vector<boost::any> temp1;
      for(auto item1:*instanceTypeList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InstanceTypeList"] = boost::any(temp1);
    }
    if (multiAvailablePolicy) {
      res["MultiAvailablePolicy"] = multiAvailablePolicy ? boost::any(multiAvailablePolicy->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (nodeOfflinePolicy) {
      res["NodeOfflinePolicy"] = nodeOfflinePolicy ? boost::any(nodeOfflinePolicy->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (privatePoolOptions) {
      res["PrivatePoolOptions"] = privatePoolOptions ? boost::any(privatePoolOptions->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (scalingMaxSize) {
      res["ScalingMaxSize"] = boost::any(*scalingMaxSize);
    }
    if (scalingMinSize) {
      res["ScalingMinSize"] = boost::any(*scalingMinSize);
    }
    if (spotStrategy) {
      res["SpotStrategy"] = boost::any(*spotStrategy);
    }
    if (sysDiskCategory) {
      res["SysDiskCategory"] = boost::any(*sysDiskCategory);
    }
    if (sysDiskSize) {
      res["SysDiskSize"] = boost::any(*sysDiskSize);
    }
    if (triggerMode) {
      res["TriggerMode"] = boost::any(*triggerMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataDiskCategory") != m.end() && !m["DataDiskCategory"].empty()) {
      dataDiskCategory = make_shared<string>(boost::any_cast<string>(m["DataDiskCategory"]));
    }
    if (m.find("DataDiskCount") != m.end() && !m["DataDiskCount"].empty()) {
      dataDiskCount = make_shared<long>(boost::any_cast<long>(m["DataDiskCount"]));
    }
    if (m.find("DataDiskSize") != m.end() && !m["DataDiskSize"].empty()) {
      dataDiskSize = make_shared<long>(boost::any_cast<long>(m["DataDiskSize"]));
    }
    if (m.find("DefaultCoolDownTime") != m.end() && !m["DefaultCoolDownTime"].empty()) {
      defaultCoolDownTime = make_shared<long>(boost::any_cast<long>(m["DefaultCoolDownTime"]));
    }
    if (m.find("InstanceTypeList") != m.end() && !m["InstanceTypeList"].empty()) {
      if (typeid(vector<boost::any>) == m["InstanceTypeList"].type()) {
        vector<ScalingGroupConfigInstanceTypeList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InstanceTypeList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ScalingGroupConfigInstanceTypeList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        instanceTypeList = make_shared<vector<ScalingGroupConfigInstanceTypeList>>(expect1);
      }
    }
    if (m.find("MultiAvailablePolicy") != m.end() && !m["MultiAvailablePolicy"].empty()) {
      if (typeid(map<string, boost::any>) == m["MultiAvailablePolicy"].type()) {
        ScalingGroupConfigMultiAvailablePolicy model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MultiAvailablePolicy"]));
        multiAvailablePolicy = make_shared<ScalingGroupConfigMultiAvailablePolicy>(model1);
      }
    }
    if (m.find("NodeOfflinePolicy") != m.end() && !m["NodeOfflinePolicy"].empty()) {
      if (typeid(map<string, boost::any>) == m["NodeOfflinePolicy"].type()) {
        ScalingGroupConfigNodeOfflinePolicy model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NodeOfflinePolicy"]));
        nodeOfflinePolicy = make_shared<ScalingGroupConfigNodeOfflinePolicy>(model1);
      }
    }
    if (m.find("PrivatePoolOptions") != m.end() && !m["PrivatePoolOptions"].empty()) {
      if (typeid(map<string, boost::any>) == m["PrivatePoolOptions"].type()) {
        ScalingGroupConfigPrivatePoolOptions model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PrivatePoolOptions"]));
        privatePoolOptions = make_shared<ScalingGroupConfigPrivatePoolOptions>(model1);
      }
    }
    if (m.find("ScalingMaxSize") != m.end() && !m["ScalingMaxSize"].empty()) {
      scalingMaxSize = make_shared<long>(boost::any_cast<long>(m["ScalingMaxSize"]));
    }
    if (m.find("ScalingMinSize") != m.end() && !m["ScalingMinSize"].empty()) {
      scalingMinSize = make_shared<long>(boost::any_cast<long>(m["ScalingMinSize"]));
    }
    if (m.find("SpotStrategy") != m.end() && !m["SpotStrategy"].empty()) {
      spotStrategy = make_shared<string>(boost::any_cast<string>(m["SpotStrategy"]));
    }
    if (m.find("SysDiskCategory") != m.end() && !m["SysDiskCategory"].empty()) {
      sysDiskCategory = make_shared<string>(boost::any_cast<string>(m["SysDiskCategory"]));
    }
    if (m.find("SysDiskSize") != m.end() && !m["SysDiskSize"].empty()) {
      sysDiskSize = make_shared<long>(boost::any_cast<long>(m["SysDiskSize"]));
    }
    if (m.find("TriggerMode") != m.end() && !m["TriggerMode"].empty()) {
      triggerMode = make_shared<string>(boost::any_cast<string>(m["TriggerMode"]));
    }
  }


  virtual ~ScalingGroupConfig() = default;
};
class ScalingRuleSpecByLoadScalingRuleSpec : public Darabonba::Model {
public:
  shared_ptr<string> comparisonOperator{};
  shared_ptr<long> evaluationCount{};
  shared_ptr<string> metricName{};
  shared_ptr<string> statistics{};
  shared_ptr<double> threshold{};
  shared_ptr<long> timeWindow{};

  ScalingRuleSpecByLoadScalingRuleSpec() {}

  explicit ScalingRuleSpecByLoadScalingRuleSpec(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (comparisonOperator) {
      res["ComparisonOperator"] = boost::any(*comparisonOperator);
    }
    if (evaluationCount) {
      res["EvaluationCount"] = boost::any(*evaluationCount);
    }
    if (metricName) {
      res["MetricName"] = boost::any(*metricName);
    }
    if (statistics) {
      res["Statistics"] = boost::any(*statistics);
    }
    if (threshold) {
      res["Threshold"] = boost::any(*threshold);
    }
    if (timeWindow) {
      res["TimeWindow"] = boost::any(*timeWindow);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ComparisonOperator") != m.end() && !m["ComparisonOperator"].empty()) {
      comparisonOperator = make_shared<string>(boost::any_cast<string>(m["ComparisonOperator"]));
    }
    if (m.find("EvaluationCount") != m.end() && !m["EvaluationCount"].empty()) {
      evaluationCount = make_shared<long>(boost::any_cast<long>(m["EvaluationCount"]));
    }
    if (m.find("MetricName") != m.end() && !m["MetricName"].empty()) {
      metricName = make_shared<string>(boost::any_cast<string>(m["MetricName"]));
    }
    if (m.find("Statistics") != m.end() && !m["Statistics"].empty()) {
      statistics = make_shared<string>(boost::any_cast<string>(m["Statistics"]));
    }
    if (m.find("Threshold") != m.end() && !m["Threshold"].empty()) {
      threshold = make_shared<double>(boost::any_cast<double>(m["Threshold"]));
    }
    if (m.find("TimeWindow") != m.end() && !m["TimeWindow"].empty()) {
      timeWindow = make_shared<long>(boost::any_cast<long>(m["TimeWindow"]));
    }
  }


  virtual ~ScalingRuleSpecByLoadScalingRuleSpec() = default;
};
class ScalingRuleSpecByTimeScalingRuleSpec : public Darabonba::Model {
public:
  shared_ptr<long> endTime{};
  shared_ptr<long> launchTime{};
  shared_ptr<string> recurrenceType{};
  shared_ptr<string> recurrenceValue{};

  ScalingRuleSpecByTimeScalingRuleSpec() {}

  explicit ScalingRuleSpecByTimeScalingRuleSpec(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (launchTime) {
      res["LaunchTime"] = boost::any(*launchTime);
    }
    if (recurrenceType) {
      res["RecurrenceType"] = boost::any(*recurrenceType);
    }
    if (recurrenceValue) {
      res["RecurrenceValue"] = boost::any(*recurrenceValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("LaunchTime") != m.end() && !m["LaunchTime"].empty()) {
      launchTime = make_shared<long>(boost::any_cast<long>(m["LaunchTime"]));
    }
    if (m.find("RecurrenceType") != m.end() && !m["RecurrenceType"].empty()) {
      recurrenceType = make_shared<string>(boost::any_cast<string>(m["RecurrenceType"]));
    }
    if (m.find("RecurrenceValue") != m.end() && !m["RecurrenceValue"].empty()) {
      recurrenceValue = make_shared<string>(boost::any_cast<string>(m["RecurrenceValue"]));
    }
  }


  virtual ~ScalingRuleSpecByTimeScalingRuleSpec() = default;
};
class ScalingRuleSpec : public Darabonba::Model {
public:
  shared_ptr<long> adjustmentValue{};
  shared_ptr<ScalingRuleSpecByLoadScalingRuleSpec> byLoadScalingRuleSpec{};
  shared_ptr<ScalingRuleSpecByTimeScalingRuleSpec> byTimeScalingRuleSpec{};
  shared_ptr<long> coolDownInterval{};
  shared_ptr<string> scalingActivityType{};
  shared_ptr<string> scalingRuleName{};
  shared_ptr<string> scalingRuleType{};

  ScalingRuleSpec() {}

  explicit ScalingRuleSpec(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (adjustmentValue) {
      res["AdjustmentValue"] = boost::any(*adjustmentValue);
    }
    if (byLoadScalingRuleSpec) {
      res["ByLoadScalingRuleSpec"] = byLoadScalingRuleSpec ? boost::any(byLoadScalingRuleSpec->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (byTimeScalingRuleSpec) {
      res["ByTimeScalingRuleSpec"] = byTimeScalingRuleSpec ? boost::any(byTimeScalingRuleSpec->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (coolDownInterval) {
      res["CoolDownInterval"] = boost::any(*coolDownInterval);
    }
    if (scalingActivityType) {
      res["ScalingActivityType"] = boost::any(*scalingActivityType);
    }
    if (scalingRuleName) {
      res["ScalingRuleName"] = boost::any(*scalingRuleName);
    }
    if (scalingRuleType) {
      res["ScalingRuleType"] = boost::any(*scalingRuleType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AdjustmentValue") != m.end() && !m["AdjustmentValue"].empty()) {
      adjustmentValue = make_shared<long>(boost::any_cast<long>(m["AdjustmentValue"]));
    }
    if (m.find("ByLoadScalingRuleSpec") != m.end() && !m["ByLoadScalingRuleSpec"].empty()) {
      if (typeid(map<string, boost::any>) == m["ByLoadScalingRuleSpec"].type()) {
        ScalingRuleSpecByLoadScalingRuleSpec model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ByLoadScalingRuleSpec"]));
        byLoadScalingRuleSpec = make_shared<ScalingRuleSpecByLoadScalingRuleSpec>(model1);
      }
    }
    if (m.find("ByTimeScalingRuleSpec") != m.end() && !m["ByTimeScalingRuleSpec"].empty()) {
      if (typeid(map<string, boost::any>) == m["ByTimeScalingRuleSpec"].type()) {
        ScalingRuleSpecByTimeScalingRuleSpec model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ByTimeScalingRuleSpec"]));
        byTimeScalingRuleSpec = make_shared<ScalingRuleSpecByTimeScalingRuleSpec>(model1);
      }
    }
    if (m.find("CoolDownInterval") != m.end() && !m["CoolDownInterval"].empty()) {
      coolDownInterval = make_shared<long>(boost::any_cast<long>(m["CoolDownInterval"]));
    }
    if (m.find("ScalingActivityType") != m.end() && !m["ScalingActivityType"].empty()) {
      scalingActivityType = make_shared<string>(boost::any_cast<string>(m["ScalingActivityType"]));
    }
    if (m.find("ScalingRuleName") != m.end() && !m["ScalingRuleName"].empty()) {
      scalingRuleName = make_shared<string>(boost::any_cast<string>(m["ScalingRuleName"]));
    }
    if (m.find("ScalingRuleType") != m.end() && !m["ScalingRuleType"].empty()) {
      scalingRuleType = make_shared<string>(boost::any_cast<string>(m["ScalingRuleType"]));
    }
  }


  virtual ~ScalingRuleSpec() = default;
};
class ScalingRuleV1RuleParam : public Darabonba::Model {
public:
  shared_ptr<string> comparisonOperator{};
  shared_ptr<long> evaluationCount{};
  shared_ptr<long> launchExpirationTime{};
  shared_ptr<string> launchTime{};
  shared_ptr<string> metricName{};
  shared_ptr<long> period{};
  shared_ptr<string> recurrenceEndTime{};
  shared_ptr<string> recurrenceType{};
  shared_ptr<string> recurrenceValue{};
  shared_ptr<string> statistics{};
  shared_ptr<long> threshold{};

  ScalingRuleV1RuleParam() {}

  explicit ScalingRuleV1RuleParam(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (comparisonOperator) {
      res["ComparisonOperator"] = boost::any(*comparisonOperator);
    }
    if (evaluationCount) {
      res["EvaluationCount"] = boost::any(*evaluationCount);
    }
    if (launchExpirationTime) {
      res["LaunchExpirationTime"] = boost::any(*launchExpirationTime);
    }
    if (launchTime) {
      res["LaunchTime"] = boost::any(*launchTime);
    }
    if (metricName) {
      res["MetricName"] = boost::any(*metricName);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (recurrenceEndTime) {
      res["RecurrenceEndTime"] = boost::any(*recurrenceEndTime);
    }
    if (recurrenceType) {
      res["RecurrenceType"] = boost::any(*recurrenceType);
    }
    if (recurrenceValue) {
      res["RecurrenceValue"] = boost::any(*recurrenceValue);
    }
    if (statistics) {
      res["Statistics"] = boost::any(*statistics);
    }
    if (threshold) {
      res["Threshold"] = boost::any(*threshold);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ComparisonOperator") != m.end() && !m["ComparisonOperator"].empty()) {
      comparisonOperator = make_shared<string>(boost::any_cast<string>(m["ComparisonOperator"]));
    }
    if (m.find("EvaluationCount") != m.end() && !m["EvaluationCount"].empty()) {
      evaluationCount = make_shared<long>(boost::any_cast<long>(m["EvaluationCount"]));
    }
    if (m.find("LaunchExpirationTime") != m.end() && !m["LaunchExpirationTime"].empty()) {
      launchExpirationTime = make_shared<long>(boost::any_cast<long>(m["LaunchExpirationTime"]));
    }
    if (m.find("LaunchTime") != m.end() && !m["LaunchTime"].empty()) {
      launchTime = make_shared<string>(boost::any_cast<string>(m["LaunchTime"]));
    }
    if (m.find("MetricName") != m.end() && !m["MetricName"].empty()) {
      metricName = make_shared<string>(boost::any_cast<string>(m["MetricName"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<long>(boost::any_cast<long>(m["Period"]));
    }
    if (m.find("RecurrenceEndTime") != m.end() && !m["RecurrenceEndTime"].empty()) {
      recurrenceEndTime = make_shared<string>(boost::any_cast<string>(m["RecurrenceEndTime"]));
    }
    if (m.find("RecurrenceType") != m.end() && !m["RecurrenceType"].empty()) {
      recurrenceType = make_shared<string>(boost::any_cast<string>(m["RecurrenceType"]));
    }
    if (m.find("RecurrenceValue") != m.end() && !m["RecurrenceValue"].empty()) {
      recurrenceValue = make_shared<string>(boost::any_cast<string>(m["RecurrenceValue"]));
    }
    if (m.find("Statistics") != m.end() && !m["Statistics"].empty()) {
      statistics = make_shared<string>(boost::any_cast<string>(m["Statistics"]));
    }
    if (m.find("Threshold") != m.end() && !m["Threshold"].empty()) {
      threshold = make_shared<long>(boost::any_cast<long>(m["Threshold"]));
    }
  }


  virtual ~ScalingRuleV1RuleParam() = default;
};
class ScalingRuleV1 : public Darabonba::Model {
public:
  shared_ptr<string> adjustmentType{};
  shared_ptr<long> adjustmentValue{};
  shared_ptr<long> coolDownTime{};
  shared_ptr<string> ruleName{};
  shared_ptr<ScalingRuleV1RuleParam> ruleParam{};
  shared_ptr<string> ruleType{};
  shared_ptr<string> scalingConfigBizId{};

  ScalingRuleV1() {}

  explicit ScalingRuleV1(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (adjustmentType) {
      res["AdjustmentType"] = boost::any(*adjustmentType);
    }
    if (adjustmentValue) {
      res["AdjustmentValue"] = boost::any(*adjustmentValue);
    }
    if (coolDownTime) {
      res["CoolDownTime"] = boost::any(*coolDownTime);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    if (ruleParam) {
      res["RuleParam"] = ruleParam ? boost::any(ruleParam->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (ruleType) {
      res["RuleType"] = boost::any(*ruleType);
    }
    if (scalingConfigBizId) {
      res["ScalingConfigBizId"] = boost::any(*scalingConfigBizId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AdjustmentType") != m.end() && !m["AdjustmentType"].empty()) {
      adjustmentType = make_shared<string>(boost::any_cast<string>(m["AdjustmentType"]));
    }
    if (m.find("AdjustmentValue") != m.end() && !m["AdjustmentValue"].empty()) {
      adjustmentValue = make_shared<long>(boost::any_cast<long>(m["AdjustmentValue"]));
    }
    if (m.find("CoolDownTime") != m.end() && !m["CoolDownTime"].empty()) {
      coolDownTime = make_shared<long>(boost::any_cast<long>(m["CoolDownTime"]));
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
    if (m.find("RuleParam") != m.end() && !m["RuleParam"].empty()) {
      if (typeid(map<string, boost::any>) == m["RuleParam"].type()) {
        ScalingRuleV1RuleParam model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RuleParam"]));
        ruleParam = make_shared<ScalingRuleV1RuleParam>(model1);
      }
    }
    if (m.find("RuleType") != m.end() && !m["RuleType"].empty()) {
      ruleType = make_shared<string>(boost::any_cast<string>(m["RuleType"]));
    }
    if (m.find("ScalingConfigBizId") != m.end() && !m["ScalingConfigBizId"].empty()) {
      scalingConfigBizId = make_shared<string>(boost::any_cast<string>(m["ScalingConfigBizId"]));
    }
  }


  virtual ~ScalingRuleV1() = default;
};
class Script : public Darabonba::Model {
public:
  shared_ptr<string> executionFailStrategy{};
  shared_ptr<string> executionMoment{};
  shared_ptr<NodeSelector> nodeSelector{};
  shared_ptr<long> priority{};
  shared_ptr<string> scriptArgs{};
  shared_ptr<string> scriptName{};
  shared_ptr<string> scriptPath{};

  Script() {}

  explicit Script(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (executionFailStrategy) {
      res["ExecutionFailStrategy"] = boost::any(*executionFailStrategy);
    }
    if (executionMoment) {
      res["ExecutionMoment"] = boost::any(*executionMoment);
    }
    if (nodeSelector) {
      res["NodeSelector"] = nodeSelector ? boost::any(nodeSelector->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (scriptArgs) {
      res["ScriptArgs"] = boost::any(*scriptArgs);
    }
    if (scriptName) {
      res["ScriptName"] = boost::any(*scriptName);
    }
    if (scriptPath) {
      res["ScriptPath"] = boost::any(*scriptPath);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ExecutionFailStrategy") != m.end() && !m["ExecutionFailStrategy"].empty()) {
      executionFailStrategy = make_shared<string>(boost::any_cast<string>(m["ExecutionFailStrategy"]));
    }
    if (m.find("ExecutionMoment") != m.end() && !m["ExecutionMoment"].empty()) {
      executionMoment = make_shared<string>(boost::any_cast<string>(m["ExecutionMoment"]));
    }
    if (m.find("NodeSelector") != m.end() && !m["NodeSelector"].empty()) {
      if (typeid(map<string, boost::any>) == m["NodeSelector"].type()) {
        NodeSelector model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NodeSelector"]));
        nodeSelector = make_shared<NodeSelector>(model1);
      }
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
    if (m.find("ScriptArgs") != m.end() && !m["ScriptArgs"].empty()) {
      scriptArgs = make_shared<string>(boost::any_cast<string>(m["ScriptArgs"]));
    }
    if (m.find("ScriptName") != m.end() && !m["ScriptName"].empty()) {
      scriptName = make_shared<string>(boost::any_cast<string>(m["ScriptName"]));
    }
    if (m.find("ScriptPath") != m.end() && !m["ScriptPath"].empty()) {
      scriptPath = make_shared<string>(boost::any_cast<string>(m["ScriptPath"]));
    }
  }


  virtual ~Script() = default;
};
class SpotPriceLimit : public Darabonba::Model {
public:
  shared_ptr<string> instanceType{};
  shared_ptr<double> priceLimit{};

  SpotPriceLimit() {}

  explicit SpotPriceLimit(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (priceLimit) {
      res["PriceLimit"] = boost::any(*priceLimit);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("PriceLimit") != m.end() && !m["PriceLimit"].empty()) {
      priceLimit = make_shared<double>(boost::any_cast<double>(m["PriceLimit"]));
    }
  }


  virtual ~SpotPriceLimit() = default;
};
class StateChangeReason : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};

  StateChangeReason() {}

  explicit StateChangeReason(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
  }


  virtual ~StateChangeReason() = default;
};
class TagResource : public Darabonba::Model {
public:
  shared_ptr<string> resourceId{};
  shared_ptr<string> resourceType{};
  shared_ptr<string> tagKey{};
  shared_ptr<string> tagValue{};

  TagResource() {}

  explicit TagResource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    if (tagValue) {
      res["TagValue"] = boost::any(*tagValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["TagKey"]));
    }
    if (m.find("TagValue") != m.end() && !m["TagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["TagValue"]));
    }
  }


  virtual ~TagResource() = default;
};
class TimeRange : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<string> startTime{};

  TimeRange() {}

  explicit TimeRange(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~TimeRange() = default;
};
class UpdateApplicationConfig : public Darabonba::Model {
public:
  shared_ptr<string> configDescription{};
  shared_ptr<string> configFileName{};
  shared_ptr<string> configItemKey{};
  shared_ptr<string> configItemValue{};

  UpdateApplicationConfig() {}

  explicit UpdateApplicationConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configDescription) {
      res["ConfigDescription"] = boost::any(*configDescription);
    }
    if (configFileName) {
      res["ConfigFileName"] = boost::any(*configFileName);
    }
    if (configItemKey) {
      res["ConfigItemKey"] = boost::any(*configItemKey);
    }
    if (configItemValue) {
      res["ConfigItemValue"] = boost::any(*configItemValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigDescription") != m.end() && !m["ConfigDescription"].empty()) {
      configDescription = make_shared<string>(boost::any_cast<string>(m["ConfigDescription"]));
    }
    if (m.find("ConfigFileName") != m.end() && !m["ConfigFileName"].empty()) {
      configFileName = make_shared<string>(boost::any_cast<string>(m["ConfigFileName"]));
    }
    if (m.find("ConfigItemKey") != m.end() && !m["ConfigItemKey"].empty()) {
      configItemKey = make_shared<string>(boost::any_cast<string>(m["ConfigItemKey"]));
    }
    if (m.find("ConfigItemValue") != m.end() && !m["ConfigItemValue"].empty()) {
      configItemValue = make_shared<string>(boost::any_cast<string>(m["ConfigItemValue"]));
    }
  }


  virtual ~UpdateApplicationConfig() = default;
};
class UpdateSpecNodeGroup : public Darabonba::Model {
public:
  shared_ptr<string> newInstanceType{};
  shared_ptr<string> nodeGroupId{};

  UpdateSpecNodeGroup() {}

  explicit UpdateSpecNodeGroup(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (newInstanceType) {
      res["NewInstanceType"] = boost::any(*newInstanceType);
    }
    if (nodeGroupId) {
      res["NodeGroupId"] = boost::any(*nodeGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NewInstanceType") != m.end() && !m["NewInstanceType"].empty()) {
      newInstanceType = make_shared<string>(boost::any_cast<string>(m["NewInstanceType"]));
    }
    if (m.find("NodeGroupId") != m.end() && !m["NodeGroupId"].empty()) {
      nodeGroupId = make_shared<string>(boost::any_cast<string>(m["NodeGroupId"]));
    }
  }


  virtual ~UpdateSpecNodeGroup() = default;
};
class UpdateSpecNodeGroupParam : public Darabonba::Model {
public:
  shared_ptr<string> newInstanceType{};
  shared_ptr<string> nodeGroupId{};

  UpdateSpecNodeGroupParam() {}

  explicit UpdateSpecNodeGroupParam(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (newInstanceType) {
      res["NewInstanceType"] = boost::any(*newInstanceType);
    }
    if (nodeGroupId) {
      res["NodeGroupId"] = boost::any(*nodeGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NewInstanceType") != m.end() && !m["NewInstanceType"].empty()) {
      newInstanceType = make_shared<string>(boost::any_cast<string>(m["NewInstanceType"]));
    }
    if (m.find("NodeGroupId") != m.end() && !m["NodeGroupId"].empty()) {
      nodeGroupId = make_shared<string>(boost::any_cast<string>(m["NodeGroupId"]));
    }
  }


  virtual ~UpdateSpecNodeGroupParam() = default;
};
class User : public Darabonba::Model {
public:
  shared_ptr<string> group{};
  shared_ptr<string> password{};
  shared_ptr<string> userId{};
  shared_ptr<string> userName{};
  shared_ptr<string> userType{};

  User() {}

  explicit User(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (group) {
      res["Group"] = boost::any(*group);
    }
    if (password) {
      res["Password"] = boost::any(*password);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (userName) {
      res["UserName"] = boost::any(*userName);
    }
    if (userType) {
      res["UserType"] = boost::any(*userType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Group") != m.end() && !m["Group"].empty()) {
      group = make_shared<string>(boost::any_cast<string>(m["Group"]));
    }
    if (m.find("Password") != m.end() && !m["Password"].empty()) {
      password = make_shared<string>(boost::any_cast<string>(m["Password"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("UserName") != m.end() && !m["UserName"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["UserName"]));
    }
    if (m.find("UserType") != m.end() && !m["UserType"].empty()) {
      userType = make_shared<string>(boost::any_cast<string>(m["UserType"]));
    }
  }


  virtual ~User() = default;
};
class UserParam : public Darabonba::Model {
public:
  shared_ptr<string> password{};
  shared_ptr<string> userId{};
  shared_ptr<string> userName{};

  UserParam() {}

  explicit UserParam(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (password) {
      res["Password"] = boost::any(*password);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (userName) {
      res["UserName"] = boost::any(*userName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Password") != m.end() && !m["Password"].empty()) {
      password = make_shared<string>(boost::any_cast<string>(m["Password"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("UserName") != m.end() && !m["UserName"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["UserName"]));
    }
  }


  virtual ~UserParam() = default;
};
class CreateApiTemplateRequest : public Darabonba::Model {
public:
  shared_ptr<string> apiName{};
  shared_ptr<string> content{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> templateName{};

  CreateApiTemplateRequest() {}

  explicit CreateApiTemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiName) {
      res["ApiName"] = boost::any(*apiName);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (templateName) {
      res["TemplateName"] = boost::any(*templateName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiName") != m.end() && !m["ApiName"].empty()) {
      apiName = make_shared<string>(boost::any_cast<string>(m["ApiName"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("TemplateName") != m.end() && !m["TemplateName"].empty()) {
      templateName = make_shared<string>(boost::any_cast<string>(m["TemplateName"]));
    }
  }


  virtual ~CreateApiTemplateRequest() = default;
};
class CreateApiTemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};
  shared_ptr<string> templateId{};

  CreateApiTemplateResponseBody() {}

  explicit CreateApiTemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~CreateApiTemplateResponseBody() = default;
};
class CreateApiTemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateApiTemplateResponseBody> body{};

  CreateApiTemplateResponse() {}

  explicit CreateApiTemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateApiTemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateApiTemplateResponseBody>(model1);
      }
    }
  }


  virtual ~CreateApiTemplateResponse() = default;
};
class CreateClusterRequest : public Darabonba::Model {
public:
  shared_ptr<vector<ApplicationConfig>> applicationConfigs{};
  shared_ptr<vector<Application>> applications{};
  shared_ptr<vector<Script>> bootstrapScripts{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> clusterName{};
  shared_ptr<string> clusterType{};
  shared_ptr<string> deployMode{};
  shared_ptr<NodeAttributes> nodeAttributes{};
  shared_ptr<vector<NodeGroupConfig>> nodeGroups{};
  shared_ptr<string> paymentType{};
  shared_ptr<string> regionId{};
  shared_ptr<string> releaseVersion{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> securityMode{};
  shared_ptr<SubscriptionConfig> subscriptionConfig{};
  shared_ptr<vector<Tag>> tags{};

  CreateClusterRequest() {}

  explicit CreateClusterRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applicationConfigs) {
      vector<boost::any> temp1;
      for(auto item1:*applicationConfigs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ApplicationConfigs"] = boost::any(temp1);
    }
    if (applications) {
      vector<boost::any> temp1;
      for(auto item1:*applications){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Applications"] = boost::any(temp1);
    }
    if (bootstrapScripts) {
      vector<boost::any> temp1;
      for(auto item1:*bootstrapScripts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["BootstrapScripts"] = boost::any(temp1);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (clusterName) {
      res["ClusterName"] = boost::any(*clusterName);
    }
    if (clusterType) {
      res["ClusterType"] = boost::any(*clusterType);
    }
    if (deployMode) {
      res["DeployMode"] = boost::any(*deployMode);
    }
    if (nodeAttributes) {
      res["NodeAttributes"] = nodeAttributes ? boost::any(nodeAttributes->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (nodeGroups) {
      vector<boost::any> temp1;
      for(auto item1:*nodeGroups){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NodeGroups"] = boost::any(temp1);
    }
    if (paymentType) {
      res["PaymentType"] = boost::any(*paymentType);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (releaseVersion) {
      res["ReleaseVersion"] = boost::any(*releaseVersion);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (securityMode) {
      res["SecurityMode"] = boost::any(*securityMode);
    }
    if (subscriptionConfig) {
      res["SubscriptionConfig"] = subscriptionConfig ? boost::any(subscriptionConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApplicationConfigs") != m.end() && !m["ApplicationConfigs"].empty()) {
      if (typeid(vector<boost::any>) == m["ApplicationConfigs"].type()) {
        vector<ApplicationConfig> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ApplicationConfigs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ApplicationConfig model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        applicationConfigs = make_shared<vector<ApplicationConfig>>(expect1);
      }
    }
    if (m.find("Applications") != m.end() && !m["Applications"].empty()) {
      if (typeid(vector<boost::any>) == m["Applications"].type()) {
        vector<Application> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Applications"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            Application model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        applications = make_shared<vector<Application>>(expect1);
      }
    }
    if (m.find("BootstrapScripts") != m.end() && !m["BootstrapScripts"].empty()) {
      if (typeid(vector<boost::any>) == m["BootstrapScripts"].type()) {
        vector<Script> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["BootstrapScripts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            Script model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        bootstrapScripts = make_shared<vector<Script>>(expect1);
      }
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("ClusterName") != m.end() && !m["ClusterName"].empty()) {
      clusterName = make_shared<string>(boost::any_cast<string>(m["ClusterName"]));
    }
    if (m.find("ClusterType") != m.end() && !m["ClusterType"].empty()) {
      clusterType = make_shared<string>(boost::any_cast<string>(m["ClusterType"]));
    }
    if (m.find("DeployMode") != m.end() && !m["DeployMode"].empty()) {
      deployMode = make_shared<string>(boost::any_cast<string>(m["DeployMode"]));
    }
    if (m.find("NodeAttributes") != m.end() && !m["NodeAttributes"].empty()) {
      if (typeid(map<string, boost::any>) == m["NodeAttributes"].type()) {
        NodeAttributes model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NodeAttributes"]));
        nodeAttributes = make_shared<NodeAttributes>(model1);
      }
    }
    if (m.find("NodeGroups") != m.end() && !m["NodeGroups"].empty()) {
      if (typeid(vector<boost::any>) == m["NodeGroups"].type()) {
        vector<NodeGroupConfig> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NodeGroups"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            NodeGroupConfig model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        nodeGroups = make_shared<vector<NodeGroupConfig>>(expect1);
      }
    }
    if (m.find("PaymentType") != m.end() && !m["PaymentType"].empty()) {
      paymentType = make_shared<string>(boost::any_cast<string>(m["PaymentType"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ReleaseVersion") != m.end() && !m["ReleaseVersion"].empty()) {
      releaseVersion = make_shared<string>(boost::any_cast<string>(m["ReleaseVersion"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("SecurityMode") != m.end() && !m["SecurityMode"].empty()) {
      securityMode = make_shared<string>(boost::any_cast<string>(m["SecurityMode"]));
    }
    if (m.find("SubscriptionConfig") != m.end() && !m["SubscriptionConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["SubscriptionConfig"].type()) {
        SubscriptionConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SubscriptionConfig"]));
        subscriptionConfig = make_shared<SubscriptionConfig>(model1);
      }
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<Tag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            Tag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<Tag>>(expect1);
      }
    }
  }


  virtual ~CreateClusterRequest() = default;
};
class CreateClusterResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> operationId{};
  shared_ptr<string> requestId{};

  CreateClusterResponseBody() {}

  explicit CreateClusterResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (operationId) {
      res["OperationId"] = boost::any(*operationId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("OperationId") != m.end() && !m["OperationId"].empty()) {
      operationId = make_shared<string>(boost::any_cast<string>(m["OperationId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateClusterResponseBody() = default;
};
class CreateClusterResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateClusterResponseBody> body{};

  CreateClusterResponse() {}

  explicit CreateClusterResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateClusterResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateClusterResponseBody>(model1);
      }
    }
  }


  virtual ~CreateClusterResponse() = default;
};
class CreateNodeGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<NodeGroupConfig> nodeGroup{};
  shared_ptr<string> regionId{};

  CreateNodeGroupRequest() {}

  explicit CreateNodeGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (nodeGroup) {
      res["NodeGroup"] = nodeGroup ? boost::any(nodeGroup->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("NodeGroup") != m.end() && !m["NodeGroup"].empty()) {
      if (typeid(map<string, boost::any>) == m["NodeGroup"].type()) {
        NodeGroupConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NodeGroup"]));
        nodeGroup = make_shared<NodeGroupConfig>(model1);
      }
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~CreateNodeGroupRequest() = default;
};
class CreateNodeGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> nodeGroupId{};
  shared_ptr<string> requestId{};

  CreateNodeGroupResponseBody() {}

  explicit CreateNodeGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nodeGroupId) {
      res["NodeGroupId"] = boost::any(*nodeGroupId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NodeGroupId") != m.end() && !m["NodeGroupId"].empty()) {
      nodeGroupId = make_shared<string>(boost::any_cast<string>(m["NodeGroupId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateNodeGroupResponseBody() = default;
};
class CreateNodeGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateNodeGroupResponseBody> body{};

  CreateNodeGroupResponse() {}

  explicit CreateNodeGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateNodeGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateNodeGroupResponseBody>(model1);
      }
    }
  }


  virtual ~CreateNodeGroupResponse() = default;
};
class CreateScriptRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> scriptType{};
  shared_ptr<vector<Script>> scripts{};

  CreateScriptRequest() {}

  explicit CreateScriptRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (scriptType) {
      res["ScriptType"] = boost::any(*scriptType);
    }
    if (scripts) {
      vector<boost::any> temp1;
      for(auto item1:*scripts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Scripts"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ScriptType") != m.end() && !m["ScriptType"].empty()) {
      scriptType = make_shared<string>(boost::any_cast<string>(m["ScriptType"]));
    }
    if (m.find("Scripts") != m.end() && !m["Scripts"].empty()) {
      if (typeid(vector<boost::any>) == m["Scripts"].type()) {
        vector<Script> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Scripts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            Script model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        scripts = make_shared<vector<Script>>(expect1);
      }
    }
  }


  virtual ~CreateScriptRequest() = default;
};
class CreateScriptResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> scriptId{};

  CreateScriptResponseBody() {}

  explicit CreateScriptResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (scriptId) {
      res["ScriptId"] = boost::any(*scriptId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ScriptId") != m.end() && !m["ScriptId"].empty()) {
      scriptId = make_shared<string>(boost::any_cast<string>(m["ScriptId"]));
    }
  }


  virtual ~CreateScriptResponseBody() = default;
};
class CreateScriptResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateScriptResponseBody> body{};

  CreateScriptResponse() {}

  explicit CreateScriptResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateScriptResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateScriptResponseBody>(model1);
      }
    }
  }


  virtual ~CreateScriptResponse() = default;
};
class DecreaseNodesRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<long> decreaseNodeCount{};
  shared_ptr<string> nodeGroupId{};
  shared_ptr<vector<string>> nodeIds{};
  shared_ptr<string> regionId{};

  DecreaseNodesRequest() {}

  explicit DecreaseNodesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (decreaseNodeCount) {
      res["DecreaseNodeCount"] = boost::any(*decreaseNodeCount);
    }
    if (nodeGroupId) {
      res["NodeGroupId"] = boost::any(*nodeGroupId);
    }
    if (nodeIds) {
      res["NodeIds"] = boost::any(*nodeIds);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("DecreaseNodeCount") != m.end() && !m["DecreaseNodeCount"].empty()) {
      decreaseNodeCount = make_shared<long>(boost::any_cast<long>(m["DecreaseNodeCount"]));
    }
    if (m.find("NodeGroupId") != m.end() && !m["NodeGroupId"].empty()) {
      nodeGroupId = make_shared<string>(boost::any_cast<string>(m["NodeGroupId"]));
    }
    if (m.find("NodeIds") != m.end() && !m["NodeIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["NodeIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["NodeIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      nodeIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DecreaseNodesRequest() = default;
};
class DecreaseNodesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> operationId{};
  shared_ptr<string> requestId{};

  DecreaseNodesResponseBody() {}

  explicit DecreaseNodesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (operationId) {
      res["OperationId"] = boost::any(*operationId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OperationId") != m.end() && !m["OperationId"].empty()) {
      operationId = make_shared<string>(boost::any_cast<string>(m["OperationId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DecreaseNodesResponseBody() = default;
};
class DecreaseNodesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DecreaseNodesResponseBody> body{};

  DecreaseNodesResponse() {}

  explicit DecreaseNodesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DecreaseNodesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DecreaseNodesResponseBody>(model1);
      }
    }
  }


  virtual ~DecreaseNodesResponse() = default;
};
class DeleteApiTemplateRequest : public Darabonba::Model {
public:
  shared_ptr<string> apiName{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> templateId{};

  DeleteApiTemplateRequest() {}

  explicit DeleteApiTemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiName) {
      res["ApiName"] = boost::any(*apiName);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiName") != m.end() && !m["ApiName"].empty()) {
      apiName = make_shared<string>(boost::any_cast<string>(m["ApiName"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~DeleteApiTemplateRequest() = default;
};
class DeleteApiTemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteApiTemplateResponseBody() {}

  explicit DeleteApiTemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteApiTemplateResponseBody() = default;
};
class DeleteApiTemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteApiTemplateResponseBody> body{};

  DeleteApiTemplateResponse() {}

  explicit DeleteApiTemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteApiTemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteApiTemplateResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteApiTemplateResponse() = default;
};
class DeleteClusterRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> regionId{};

  DeleteClusterRequest() {}

  explicit DeleteClusterRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DeleteClusterRequest() = default;
};
class DeleteClusterResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> operationId{};
  shared_ptr<string> requestId{};

  DeleteClusterResponseBody() {}

  explicit DeleteClusterResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (operationId) {
      res["OperationId"] = boost::any(*operationId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OperationId") != m.end() && !m["OperationId"].empty()) {
      operationId = make_shared<string>(boost::any_cast<string>(m["OperationId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteClusterResponseBody() = default;
};
class DeleteClusterResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteClusterResponseBody> body{};

  DeleteClusterResponse() {}

  explicit DeleteClusterResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteClusterResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteClusterResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteClusterResponse() = default;
};
class DeleteScriptRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> scriptId{};
  shared_ptr<string> scriptType{};

  DeleteScriptRequest() {}

  explicit DeleteScriptRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (scriptId) {
      res["ScriptId"] = boost::any(*scriptId);
    }
    if (scriptType) {
      res["ScriptType"] = boost::any(*scriptType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ScriptId") != m.end() && !m["ScriptId"].empty()) {
      scriptId = make_shared<string>(boost::any_cast<string>(m["ScriptId"]));
    }
    if (m.find("ScriptType") != m.end() && !m["ScriptType"].empty()) {
      scriptType = make_shared<string>(boost::any_cast<string>(m["ScriptType"]));
    }
  }


  virtual ~DeleteScriptRequest() = default;
};
class DeleteScriptResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteScriptResponseBody() {}

  explicit DeleteScriptResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteScriptResponseBody() = default;
};
class DeleteScriptResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteScriptResponseBody> body{};

  DeleteScriptResponse() {}

  explicit DeleteScriptResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteScriptResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteScriptResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteScriptResponse() = default;
};
class GetApiTemplateRequest : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};
  shared_ptr<string> templateId{};

  GetApiTemplateRequest() {}

  explicit GetApiTemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~GetApiTemplateRequest() = default;
};
class GetApiTemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<ApiTemplate> data{};
  shared_ptr<string> requestId{};

  GetApiTemplateResponseBody() {}

  explicit GetApiTemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ApiTemplate model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ApiTemplate>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetApiTemplateResponseBody() = default;
};
class GetApiTemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetApiTemplateResponseBody> body{};

  GetApiTemplateResponse() {}

  explicit GetApiTemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetApiTemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetApiTemplateResponseBody>(model1);
      }
    }
  }


  virtual ~GetApiTemplateResponse() = default;
};
class GetApplicationRequest : public Darabonba::Model {
public:
  shared_ptr<string> applicationName{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> regionId{};

  GetApplicationRequest() {}

  explicit GetApplicationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applicationName) {
      res["ApplicationName"] = boost::any(*applicationName);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApplicationName") != m.end() && !m["ApplicationName"].empty()) {
      applicationName = make_shared<string>(boost::any_cast<string>(m["ApplicationName"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~GetApplicationRequest() = default;
};
class GetApplicationResponseBodyApplicationActionsActionParamsValueAttribute : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> valueIncrementStep{};
  shared_ptr<string> valueMaximum{};
  shared_ptr<string> valueMinimum{};
  shared_ptr<string> valueType{};
  shared_ptr<string> valueUnit{};

  GetApplicationResponseBodyApplicationActionsActionParamsValueAttribute() {}

  explicit GetApplicationResponseBodyApplicationActionsActionParamsValueAttribute(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (valueIncrementStep) {
      res["ValueIncrementStep"] = boost::any(*valueIncrementStep);
    }
    if (valueMaximum) {
      res["ValueMaximum"] = boost::any(*valueMaximum);
    }
    if (valueMinimum) {
      res["ValueMinimum"] = boost::any(*valueMinimum);
    }
    if (valueType) {
      res["ValueType"] = boost::any(*valueType);
    }
    if (valueUnit) {
      res["ValueUnit"] = boost::any(*valueUnit);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ValueIncrementStep") != m.end() && !m["ValueIncrementStep"].empty()) {
      valueIncrementStep = make_shared<string>(boost::any_cast<string>(m["ValueIncrementStep"]));
    }
    if (m.find("ValueMaximum") != m.end() && !m["ValueMaximum"].empty()) {
      valueMaximum = make_shared<string>(boost::any_cast<string>(m["ValueMaximum"]));
    }
    if (m.find("ValueMinimum") != m.end() && !m["ValueMinimum"].empty()) {
      valueMinimum = make_shared<string>(boost::any_cast<string>(m["ValueMinimum"]));
    }
    if (m.find("ValueType") != m.end() && !m["ValueType"].empty()) {
      valueType = make_shared<string>(boost::any_cast<string>(m["ValueType"]));
    }
    if (m.find("ValueUnit") != m.end() && !m["ValueUnit"].empty()) {
      valueUnit = make_shared<string>(boost::any_cast<string>(m["ValueUnit"]));
    }
  }


  virtual ~GetApplicationResponseBodyApplicationActionsActionParamsValueAttribute() = default;
};
class GetApplicationResponseBodyApplicationActionsActionParams : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> key{};
  shared_ptr<GetApplicationResponseBodyApplicationActionsActionParamsValueAttribute> valueAttribute{};

  GetApplicationResponseBodyApplicationActionsActionParams() {}

  explicit GetApplicationResponseBodyApplicationActionsActionParams(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (valueAttribute) {
      res["ValueAttribute"] = valueAttribute ? boost::any(valueAttribute->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("ValueAttribute") != m.end() && !m["ValueAttribute"].empty()) {
      if (typeid(map<string, boost::any>) == m["ValueAttribute"].type()) {
        GetApplicationResponseBodyApplicationActionsActionParamsValueAttribute model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ValueAttribute"]));
        valueAttribute = make_shared<GetApplicationResponseBodyApplicationActionsActionParamsValueAttribute>(model1);
      }
    }
  }


  virtual ~GetApplicationResponseBodyApplicationActionsActionParams() = default;
};
class GetApplicationResponseBodyApplicationActions : public Darabonba::Model {
public:
  shared_ptr<string> actionName{};
  shared_ptr<vector<GetApplicationResponseBodyApplicationActionsActionParams>> actionParams{};
  shared_ptr<string> command{};
  shared_ptr<string> componentName{};
  shared_ptr<string> description{};
  shared_ptr<string> runActionScope{};

  GetApplicationResponseBodyApplicationActions() {}

  explicit GetApplicationResponseBodyApplicationActions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (actionName) {
      res["ActionName"] = boost::any(*actionName);
    }
    if (actionParams) {
      vector<boost::any> temp1;
      for(auto item1:*actionParams){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ActionParams"] = boost::any(temp1);
    }
    if (command) {
      res["Command"] = boost::any(*command);
    }
    if (componentName) {
      res["ComponentName"] = boost::any(*componentName);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (runActionScope) {
      res["RunActionScope"] = boost::any(*runActionScope);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActionName") != m.end() && !m["ActionName"].empty()) {
      actionName = make_shared<string>(boost::any_cast<string>(m["ActionName"]));
    }
    if (m.find("ActionParams") != m.end() && !m["ActionParams"].empty()) {
      if (typeid(vector<boost::any>) == m["ActionParams"].type()) {
        vector<GetApplicationResponseBodyApplicationActionsActionParams> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ActionParams"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetApplicationResponseBodyApplicationActionsActionParams model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        actionParams = make_shared<vector<GetApplicationResponseBodyApplicationActionsActionParams>>(expect1);
      }
    }
    if (m.find("Command") != m.end() && !m["Command"].empty()) {
      command = make_shared<string>(boost::any_cast<string>(m["Command"]));
    }
    if (m.find("ComponentName") != m.end() && !m["ComponentName"].empty()) {
      componentName = make_shared<string>(boost::any_cast<string>(m["ComponentName"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("RunActionScope") != m.end() && !m["RunActionScope"].empty()) {
      runActionScope = make_shared<string>(boost::any_cast<string>(m["RunActionScope"]));
    }
  }


  virtual ~GetApplicationResponseBodyApplicationActions() = default;
};
class GetApplicationResponseBodyApplication : public Darabonba::Model {
public:
  shared_ptr<vector<GetApplicationResponseBodyApplicationActions>> actions{};
  shared_ptr<string> applicationName{};
  shared_ptr<string> applicationState{};
  shared_ptr<string> applicationVersion{};
  shared_ptr<string> communityVersion{};

  GetApplicationResponseBodyApplication() {}

  explicit GetApplicationResponseBodyApplication(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (actions) {
      vector<boost::any> temp1;
      for(auto item1:*actions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Actions"] = boost::any(temp1);
    }
    if (applicationName) {
      res["ApplicationName"] = boost::any(*applicationName);
    }
    if (applicationState) {
      res["ApplicationState"] = boost::any(*applicationState);
    }
    if (applicationVersion) {
      res["ApplicationVersion"] = boost::any(*applicationVersion);
    }
    if (communityVersion) {
      res["CommunityVersion"] = boost::any(*communityVersion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Actions") != m.end() && !m["Actions"].empty()) {
      if (typeid(vector<boost::any>) == m["Actions"].type()) {
        vector<GetApplicationResponseBodyApplicationActions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Actions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetApplicationResponseBodyApplicationActions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        actions = make_shared<vector<GetApplicationResponseBodyApplicationActions>>(expect1);
      }
    }
    if (m.find("ApplicationName") != m.end() && !m["ApplicationName"].empty()) {
      applicationName = make_shared<string>(boost::any_cast<string>(m["ApplicationName"]));
    }
    if (m.find("ApplicationState") != m.end() && !m["ApplicationState"].empty()) {
      applicationState = make_shared<string>(boost::any_cast<string>(m["ApplicationState"]));
    }
    if (m.find("ApplicationVersion") != m.end() && !m["ApplicationVersion"].empty()) {
      applicationVersion = make_shared<string>(boost::any_cast<string>(m["ApplicationVersion"]));
    }
    if (m.find("CommunityVersion") != m.end() && !m["CommunityVersion"].empty()) {
      communityVersion = make_shared<string>(boost::any_cast<string>(m["CommunityVersion"]));
    }
  }


  virtual ~GetApplicationResponseBodyApplication() = default;
};
class GetApplicationResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetApplicationResponseBodyApplication> application{};
  shared_ptr<string> requestId{};

  GetApplicationResponseBody() {}

  explicit GetApplicationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (application) {
      res["Application"] = application ? boost::any(application->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Application") != m.end() && !m["Application"].empty()) {
      if (typeid(map<string, boost::any>) == m["Application"].type()) {
        GetApplicationResponseBodyApplication model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Application"]));
        application = make_shared<GetApplicationResponseBodyApplication>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetApplicationResponseBody() = default;
};
class GetApplicationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetApplicationResponseBody> body{};

  GetApplicationResponse() {}

  explicit GetApplicationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetApplicationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetApplicationResponseBody>(model1);
      }
    }
  }


  virtual ~GetApplicationResponse() = default;
};
class GetAutoScalingActivityRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> scalingActivityId{};

  GetAutoScalingActivityRequest() {}

  explicit GetAutoScalingActivityRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (scalingActivityId) {
      res["ScalingActivityId"] = boost::any(*scalingActivityId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ScalingActivityId") != m.end() && !m["ScalingActivityId"].empty()) {
      scalingActivityId = make_shared<string>(boost::any_cast<string>(m["ScalingActivityId"]));
    }
  }


  virtual ~GetAutoScalingActivityRequest() = default;
};
class GetAutoScalingActivityResponseBodyScalingActivity : public Darabonba::Model {
public:
  shared_ptr<string> activityId{};
  shared_ptr<vector<ScalingActivityResult>> activityResults{};
  shared_ptr<string> activityState{};
  shared_ptr<string> activityType{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> description{};
  shared_ptr<long> endTime{};
  shared_ptr<long> expectNum{};
  shared_ptr<string> nodeGroupId{};
  shared_ptr<string> nodeGroupName{};
  shared_ptr<string> operationId{};
  shared_ptr<ScalingRule> ruleDetail{};
  shared_ptr<string> ruleName{};
  shared_ptr<long> startTime{};

  GetAutoScalingActivityResponseBodyScalingActivity() {}

  explicit GetAutoScalingActivityResponseBodyScalingActivity(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (activityId) {
      res["ActivityId"] = boost::any(*activityId);
    }
    if (activityResults) {
      vector<boost::any> temp1;
      for(auto item1:*activityResults){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ActivityResults"] = boost::any(temp1);
    }
    if (activityState) {
      res["ActivityState"] = boost::any(*activityState);
    }
    if (activityType) {
      res["ActivityType"] = boost::any(*activityType);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (expectNum) {
      res["ExpectNum"] = boost::any(*expectNum);
    }
    if (nodeGroupId) {
      res["NodeGroupId"] = boost::any(*nodeGroupId);
    }
    if (nodeGroupName) {
      res["NodeGroupName"] = boost::any(*nodeGroupName);
    }
    if (operationId) {
      res["OperationId"] = boost::any(*operationId);
    }
    if (ruleDetail) {
      res["RuleDetail"] = ruleDetail ? boost::any(ruleDetail->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActivityId") != m.end() && !m["ActivityId"].empty()) {
      activityId = make_shared<string>(boost::any_cast<string>(m["ActivityId"]));
    }
    if (m.find("ActivityResults") != m.end() && !m["ActivityResults"].empty()) {
      if (typeid(vector<boost::any>) == m["ActivityResults"].type()) {
        vector<ScalingActivityResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ActivityResults"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ScalingActivityResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        activityResults = make_shared<vector<ScalingActivityResult>>(expect1);
      }
    }
    if (m.find("ActivityState") != m.end() && !m["ActivityState"].empty()) {
      activityState = make_shared<string>(boost::any_cast<string>(m["ActivityState"]));
    }
    if (m.find("ActivityType") != m.end() && !m["ActivityType"].empty()) {
      activityType = make_shared<string>(boost::any_cast<string>(m["ActivityType"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("ExpectNum") != m.end() && !m["ExpectNum"].empty()) {
      expectNum = make_shared<long>(boost::any_cast<long>(m["ExpectNum"]));
    }
    if (m.find("NodeGroupId") != m.end() && !m["NodeGroupId"].empty()) {
      nodeGroupId = make_shared<string>(boost::any_cast<string>(m["NodeGroupId"]));
    }
    if (m.find("NodeGroupName") != m.end() && !m["NodeGroupName"].empty()) {
      nodeGroupName = make_shared<string>(boost::any_cast<string>(m["NodeGroupName"]));
    }
    if (m.find("OperationId") != m.end() && !m["OperationId"].empty()) {
      operationId = make_shared<string>(boost::any_cast<string>(m["OperationId"]));
    }
    if (m.find("RuleDetail") != m.end() && !m["RuleDetail"].empty()) {
      if (typeid(map<string, boost::any>) == m["RuleDetail"].type()) {
        ScalingRule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RuleDetail"]));
        ruleDetail = make_shared<ScalingRule>(model1);
      }
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
  }


  virtual ~GetAutoScalingActivityResponseBodyScalingActivity() = default;
};
class GetAutoScalingActivityResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<GetAutoScalingActivityResponseBodyScalingActivity> scalingActivity{};

  GetAutoScalingActivityResponseBody() {}

  explicit GetAutoScalingActivityResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (scalingActivity) {
      res["ScalingActivity"] = scalingActivity ? boost::any(scalingActivity->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ScalingActivity") != m.end() && !m["ScalingActivity"].empty()) {
      if (typeid(map<string, boost::any>) == m["ScalingActivity"].type()) {
        GetAutoScalingActivityResponseBodyScalingActivity model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ScalingActivity"]));
        scalingActivity = make_shared<GetAutoScalingActivityResponseBodyScalingActivity>(model1);
      }
    }
  }


  virtual ~GetAutoScalingActivityResponseBody() = default;
};
class GetAutoScalingActivityResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetAutoScalingActivityResponseBody> body{};

  GetAutoScalingActivityResponse() {}

  explicit GetAutoScalingActivityResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetAutoScalingActivityResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetAutoScalingActivityResponseBody>(model1);
      }
    }
  }


  virtual ~GetAutoScalingActivityResponse() = default;
};
class GetAutoScalingPolicyRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> nodeGroupId{};
  shared_ptr<string> regionId{};

  GetAutoScalingPolicyRequest() {}

  explicit GetAutoScalingPolicyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (nodeGroupId) {
      res["NodeGroupId"] = boost::any(*nodeGroupId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("NodeGroupId") != m.end() && !m["NodeGroupId"].empty()) {
      nodeGroupId = make_shared<string>(boost::any_cast<string>(m["NodeGroupId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~GetAutoScalingPolicyRequest() = default;
};
class GetAutoScalingPolicyResponseBodyScalingPolicyConstraints : public Darabonba::Model {
public:
  shared_ptr<long> maxCapacity{};
  shared_ptr<long> minCapacity{};

  GetAutoScalingPolicyResponseBodyScalingPolicyConstraints() {}

  explicit GetAutoScalingPolicyResponseBodyScalingPolicyConstraints(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxCapacity) {
      res["MaxCapacity"] = boost::any(*maxCapacity);
    }
    if (minCapacity) {
      res["MinCapacity"] = boost::any(*minCapacity);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MaxCapacity") != m.end() && !m["MaxCapacity"].empty()) {
      maxCapacity = make_shared<long>(boost::any_cast<long>(m["MaxCapacity"]));
    }
    if (m.find("MinCapacity") != m.end() && !m["MinCapacity"].empty()) {
      minCapacity = make_shared<long>(boost::any_cast<long>(m["MinCapacity"]));
    }
  }


  virtual ~GetAutoScalingPolicyResponseBodyScalingPolicyConstraints() = default;
};
class GetAutoScalingPolicyResponseBodyScalingPolicyScalingRules : public Darabonba::Model {
public:
  shared_ptr<string> activityType{};
  shared_ptr<string> adjustmentType{};
  shared_ptr<long> adjustmentValue{};
  shared_ptr<MetricsTrigger> metricsTrigger{};
  shared_ptr<string> ruleName{};
  shared_ptr<TimeTrigger> timeTrigger{};
  shared_ptr<string> triggerType{};

  GetAutoScalingPolicyResponseBodyScalingPolicyScalingRules() {}

  explicit GetAutoScalingPolicyResponseBodyScalingPolicyScalingRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (activityType) {
      res["ActivityType"] = boost::any(*activityType);
    }
    if (adjustmentType) {
      res["AdjustmentType"] = boost::any(*adjustmentType);
    }
    if (adjustmentValue) {
      res["AdjustmentValue"] = boost::any(*adjustmentValue);
    }
    if (metricsTrigger) {
      res["MetricsTrigger"] = metricsTrigger ? boost::any(metricsTrigger->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    if (timeTrigger) {
      res["TimeTrigger"] = timeTrigger ? boost::any(timeTrigger->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (triggerType) {
      res["TriggerType"] = boost::any(*triggerType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActivityType") != m.end() && !m["ActivityType"].empty()) {
      activityType = make_shared<string>(boost::any_cast<string>(m["ActivityType"]));
    }
    if (m.find("AdjustmentType") != m.end() && !m["AdjustmentType"].empty()) {
      adjustmentType = make_shared<string>(boost::any_cast<string>(m["AdjustmentType"]));
    }
    if (m.find("AdjustmentValue") != m.end() && !m["AdjustmentValue"].empty()) {
      adjustmentValue = make_shared<long>(boost::any_cast<long>(m["AdjustmentValue"]));
    }
    if (m.find("MetricsTrigger") != m.end() && !m["MetricsTrigger"].empty()) {
      if (typeid(map<string, boost::any>) == m["MetricsTrigger"].type()) {
        MetricsTrigger model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MetricsTrigger"]));
        metricsTrigger = make_shared<MetricsTrigger>(model1);
      }
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
    if (m.find("TimeTrigger") != m.end() && !m["TimeTrigger"].empty()) {
      if (typeid(map<string, boost::any>) == m["TimeTrigger"].type()) {
        TimeTrigger model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TimeTrigger"]));
        timeTrigger = make_shared<TimeTrigger>(model1);
      }
    }
    if (m.find("TriggerType") != m.end() && !m["TriggerType"].empty()) {
      triggerType = make_shared<string>(boost::any_cast<string>(m["TriggerType"]));
    }
  }


  virtual ~GetAutoScalingPolicyResponseBodyScalingPolicyScalingRules() = default;
};
class GetAutoScalingPolicyResponseBodyScalingPolicy : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<GetAutoScalingPolicyResponseBodyScalingPolicyConstraints> constraints{};
  shared_ptr<string> nodeGroupId{};
  shared_ptr<string> scalingPolicyId{};
  shared_ptr<vector<GetAutoScalingPolicyResponseBodyScalingPolicyScalingRules>> scalingRules{};

  GetAutoScalingPolicyResponseBodyScalingPolicy() {}

  explicit GetAutoScalingPolicyResponseBodyScalingPolicy(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (constraints) {
      res["Constraints"] = constraints ? boost::any(constraints->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (nodeGroupId) {
      res["NodeGroupId"] = boost::any(*nodeGroupId);
    }
    if (scalingPolicyId) {
      res["ScalingPolicyId"] = boost::any(*scalingPolicyId);
    }
    if (scalingRules) {
      vector<boost::any> temp1;
      for(auto item1:*scalingRules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ScalingRules"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("Constraints") != m.end() && !m["Constraints"].empty()) {
      if (typeid(map<string, boost::any>) == m["Constraints"].type()) {
        GetAutoScalingPolicyResponseBodyScalingPolicyConstraints model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Constraints"]));
        constraints = make_shared<GetAutoScalingPolicyResponseBodyScalingPolicyConstraints>(model1);
      }
    }
    if (m.find("NodeGroupId") != m.end() && !m["NodeGroupId"].empty()) {
      nodeGroupId = make_shared<string>(boost::any_cast<string>(m["NodeGroupId"]));
    }
    if (m.find("ScalingPolicyId") != m.end() && !m["ScalingPolicyId"].empty()) {
      scalingPolicyId = make_shared<string>(boost::any_cast<string>(m["ScalingPolicyId"]));
    }
    if (m.find("ScalingRules") != m.end() && !m["ScalingRules"].empty()) {
      if (typeid(vector<boost::any>) == m["ScalingRules"].type()) {
        vector<GetAutoScalingPolicyResponseBodyScalingPolicyScalingRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ScalingRules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetAutoScalingPolicyResponseBodyScalingPolicyScalingRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        scalingRules = make_shared<vector<GetAutoScalingPolicyResponseBodyScalingPolicyScalingRules>>(expect1);
      }
    }
  }


  virtual ~GetAutoScalingPolicyResponseBodyScalingPolicy() = default;
};
class GetAutoScalingPolicyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<GetAutoScalingPolicyResponseBodyScalingPolicy> scalingPolicy{};

  GetAutoScalingPolicyResponseBody() {}

  explicit GetAutoScalingPolicyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (scalingPolicy) {
      res["ScalingPolicy"] = scalingPolicy ? boost::any(scalingPolicy->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ScalingPolicy") != m.end() && !m["ScalingPolicy"].empty()) {
      if (typeid(map<string, boost::any>) == m["ScalingPolicy"].type()) {
        GetAutoScalingPolicyResponseBodyScalingPolicy model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ScalingPolicy"]));
        scalingPolicy = make_shared<GetAutoScalingPolicyResponseBodyScalingPolicy>(model1);
      }
    }
  }


  virtual ~GetAutoScalingPolicyResponseBody() = default;
};
class GetAutoScalingPolicyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetAutoScalingPolicyResponseBody> body{};

  GetAutoScalingPolicyResponse() {}

  explicit GetAutoScalingPolicyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetAutoScalingPolicyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetAutoScalingPolicyResponseBody>(model1);
      }
    }
  }


  virtual ~GetAutoScalingPolicyResponse() = default;
};
class GetClusterRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> regionId{};

  GetClusterRequest() {}

  explicit GetClusterRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~GetClusterRequest() = default;
};
class GetClusterResponseBody : public Darabonba::Model {
public:
  shared_ptr<Cluster> cluster{};
  shared_ptr<string> requestId{};

  GetClusterResponseBody() {}

  explicit GetClusterResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cluster) {
      res["Cluster"] = cluster ? boost::any(cluster->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cluster") != m.end() && !m["Cluster"].empty()) {
      if (typeid(map<string, boost::any>) == m["Cluster"].type()) {
        Cluster model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Cluster"]));
        cluster = make_shared<Cluster>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetClusterResponseBody() = default;
};
class GetClusterResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetClusterResponseBody> body{};

  GetClusterResponse() {}

  explicit GetClusterResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetClusterResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetClusterResponseBody>(model1);
      }
    }
  }


  virtual ~GetClusterResponse() = default;
};
class GetDoctorApplicationRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> dateTime{};
  shared_ptr<string> regionId{};

  GetDoctorApplicationRequest() {}

  explicit GetDoctorApplicationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (dateTime) {
      res["DateTime"] = boost::any(*dateTime);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("DateTime") != m.end() && !m["DateTime"].empty()) {
      dateTime = make_shared<string>(boost::any_cast<string>(m["DateTime"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~GetDoctorApplicationRequest() = default;
};
class GetDoctorApplicationResponseBodyDataAnalysis : public Darabonba::Model {
public:
  shared_ptr<long> score{};
  shared_ptr<string> suggestion{};

  GetDoctorApplicationResponseBodyDataAnalysis() {}

  explicit GetDoctorApplicationResponseBodyDataAnalysis(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (score) {
      res["Score"] = boost::any(*score);
    }
    if (suggestion) {
      res["Suggestion"] = boost::any(*suggestion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Score") != m.end() && !m["Score"].empty()) {
      score = make_shared<long>(boost::any_cast<long>(m["Score"]));
    }
    if (m.find("Suggestion") != m.end() && !m["Suggestion"].empty()) {
      suggestion = make_shared<string>(boost::any_cast<string>(m["Suggestion"]));
    }
  }


  virtual ~GetDoctorApplicationResponseBodyDataAnalysis() = default;
};
class GetDoctorApplicationResponseBodyDataMetricsMemSeconds : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  GetDoctorApplicationResponseBodyDataMetricsMemSeconds() {}

  explicit GetDoctorApplicationResponseBodyDataMetricsMemSeconds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~GetDoctorApplicationResponseBodyDataMetricsMemSeconds() = default;
};
class GetDoctorApplicationResponseBodyDataMetricsMemUtilization : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  GetDoctorApplicationResponseBodyDataMetricsMemUtilization() {}

  explicit GetDoctorApplicationResponseBodyDataMetricsMemUtilization(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~GetDoctorApplicationResponseBodyDataMetricsMemUtilization() = default;
};
class GetDoctorApplicationResponseBodyDataMetricsVcoreSeconds : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  GetDoctorApplicationResponseBodyDataMetricsVcoreSeconds() {}

  explicit GetDoctorApplicationResponseBodyDataMetricsVcoreSeconds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~GetDoctorApplicationResponseBodyDataMetricsVcoreSeconds() = default;
};
class GetDoctorApplicationResponseBodyDataMetricsVcoreUtilization : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  GetDoctorApplicationResponseBodyDataMetricsVcoreUtilization() {}

  explicit GetDoctorApplicationResponseBodyDataMetricsVcoreUtilization(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~GetDoctorApplicationResponseBodyDataMetricsVcoreUtilization() = default;
};
class GetDoctorApplicationResponseBodyDataMetrics : public Darabonba::Model {
public:
  shared_ptr<GetDoctorApplicationResponseBodyDataMetricsMemSeconds> memSeconds{};
  shared_ptr<GetDoctorApplicationResponseBodyDataMetricsMemUtilization> memUtilization{};
  shared_ptr<GetDoctorApplicationResponseBodyDataMetricsVcoreSeconds> vcoreSeconds{};
  shared_ptr<GetDoctorApplicationResponseBodyDataMetricsVcoreUtilization> vcoreUtilization{};

  GetDoctorApplicationResponseBodyDataMetrics() {}

  explicit GetDoctorApplicationResponseBodyDataMetrics(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (memSeconds) {
      res["MemSeconds"] = memSeconds ? boost::any(memSeconds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (memUtilization) {
      res["MemUtilization"] = memUtilization ? boost::any(memUtilization->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (vcoreSeconds) {
      res["VcoreSeconds"] = vcoreSeconds ? boost::any(vcoreSeconds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (vcoreUtilization) {
      res["VcoreUtilization"] = vcoreUtilization ? boost::any(vcoreUtilization->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MemSeconds") != m.end() && !m["MemSeconds"].empty()) {
      if (typeid(map<string, boost::any>) == m["MemSeconds"].type()) {
        GetDoctorApplicationResponseBodyDataMetricsMemSeconds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MemSeconds"]));
        memSeconds = make_shared<GetDoctorApplicationResponseBodyDataMetricsMemSeconds>(model1);
      }
    }
    if (m.find("MemUtilization") != m.end() && !m["MemUtilization"].empty()) {
      if (typeid(map<string, boost::any>) == m["MemUtilization"].type()) {
        GetDoctorApplicationResponseBodyDataMetricsMemUtilization model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MemUtilization"]));
        memUtilization = make_shared<GetDoctorApplicationResponseBodyDataMetricsMemUtilization>(model1);
      }
    }
    if (m.find("VcoreSeconds") != m.end() && !m["VcoreSeconds"].empty()) {
      if (typeid(map<string, boost::any>) == m["VcoreSeconds"].type()) {
        GetDoctorApplicationResponseBodyDataMetricsVcoreSeconds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VcoreSeconds"]));
        vcoreSeconds = make_shared<GetDoctorApplicationResponseBodyDataMetricsVcoreSeconds>(model1);
      }
    }
    if (m.find("VcoreUtilization") != m.end() && !m["VcoreUtilization"].empty()) {
      if (typeid(map<string, boost::any>) == m["VcoreUtilization"].type()) {
        GetDoctorApplicationResponseBodyDataMetricsVcoreUtilization model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VcoreUtilization"]));
        vcoreUtilization = make_shared<GetDoctorApplicationResponseBodyDataMetricsVcoreUtilization>(model1);
      }
    }
  }


  virtual ~GetDoctorApplicationResponseBodyDataMetrics() = default;
};
class GetDoctorApplicationResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<GetDoctorApplicationResponseBodyDataAnalysis> analysis{};
  shared_ptr<string> appName{};
  shared_ptr<long> endTime{};
  shared_ptr<vector<string>> ids{};
  shared_ptr<GetDoctorApplicationResponseBodyDataMetrics> metrics{};
  shared_ptr<string> querySql{};
  shared_ptr<string> queue{};
  shared_ptr<long> startTime{};
  shared_ptr<string> type{};
  shared_ptr<string> user{};

  GetDoctorApplicationResponseBodyData() {}

  explicit GetDoctorApplicationResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (analysis) {
      res["Analysis"] = analysis ? boost::any(analysis->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (ids) {
      res["Ids"] = boost::any(*ids);
    }
    if (metrics) {
      res["Metrics"] = metrics ? boost::any(metrics->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (querySql) {
      res["QuerySql"] = boost::any(*querySql);
    }
    if (queue) {
      res["Queue"] = boost::any(*queue);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (user) {
      res["User"] = boost::any(*user);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Analysis") != m.end() && !m["Analysis"].empty()) {
      if (typeid(map<string, boost::any>) == m["Analysis"].type()) {
        GetDoctorApplicationResponseBodyDataAnalysis model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Analysis"]));
        analysis = make_shared<GetDoctorApplicationResponseBodyDataAnalysis>(model1);
      }
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("Ids") != m.end() && !m["Ids"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Ids"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Ids"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ids = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Metrics") != m.end() && !m["Metrics"].empty()) {
      if (typeid(map<string, boost::any>) == m["Metrics"].type()) {
        GetDoctorApplicationResponseBodyDataMetrics model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Metrics"]));
        metrics = make_shared<GetDoctorApplicationResponseBodyDataMetrics>(model1);
      }
    }
    if (m.find("QuerySql") != m.end() && !m["QuerySql"].empty()) {
      querySql = make_shared<string>(boost::any_cast<string>(m["QuerySql"]));
    }
    if (m.find("Queue") != m.end() && !m["Queue"].empty()) {
      queue = make_shared<string>(boost::any_cast<string>(m["Queue"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("User") != m.end() && !m["User"].empty()) {
      user = make_shared<string>(boost::any_cast<string>(m["User"]));
    }
  }


  virtual ~GetDoctorApplicationResponseBodyData() = default;
};
class GetDoctorApplicationResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetDoctorApplicationResponseBodyData> data{};
  shared_ptr<string> requestId{};

  GetDoctorApplicationResponseBody() {}

  explicit GetDoctorApplicationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetDoctorApplicationResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetDoctorApplicationResponseBodyData>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetDoctorApplicationResponseBody() = default;
};
class GetDoctorApplicationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetDoctorApplicationResponseBody> body{};

  GetDoctorApplicationResponse() {}

  explicit GetDoctorApplicationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetDoctorApplicationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetDoctorApplicationResponseBody>(model1);
      }
    }
  }


  virtual ~GetDoctorApplicationResponse() = default;
};
class GetDoctorComputeSummaryRequestComponentInfo : public Darabonba::Model {
public:
  shared_ptr<string> componentName{};
  shared_ptr<string> componentType{};

  GetDoctorComputeSummaryRequestComponentInfo() {}

  explicit GetDoctorComputeSummaryRequestComponentInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (componentName) {
      res["ComponentName"] = boost::any(*componentName);
    }
    if (componentType) {
      res["ComponentType"] = boost::any(*componentType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ComponentName") != m.end() && !m["ComponentName"].empty()) {
      componentName = make_shared<string>(boost::any_cast<string>(m["ComponentName"]));
    }
    if (m.find("ComponentType") != m.end() && !m["ComponentType"].empty()) {
      componentType = make_shared<string>(boost::any_cast<string>(m["ComponentType"]));
    }
  }


  virtual ~GetDoctorComputeSummaryRequestComponentInfo() = default;
};
class GetDoctorComputeSummaryRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<GetDoctorComputeSummaryRequestComponentInfo> componentInfo{};
  shared_ptr<string> dateTime{};
  shared_ptr<string> regionId{};

  GetDoctorComputeSummaryRequest() {}

  explicit GetDoctorComputeSummaryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (componentInfo) {
      res["ComponentInfo"] = componentInfo ? boost::any(componentInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (dateTime) {
      res["DateTime"] = boost::any(*dateTime);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("ComponentInfo") != m.end() && !m["ComponentInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["ComponentInfo"].type()) {
        GetDoctorComputeSummaryRequestComponentInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ComponentInfo"]));
        componentInfo = make_shared<GetDoctorComputeSummaryRequestComponentInfo>(model1);
      }
    }
    if (m.find("DateTime") != m.end() && !m["DateTime"].empty()) {
      dateTime = make_shared<string>(boost::any_cast<string>(m["DateTime"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~GetDoctorComputeSummaryRequest() = default;
};
class GetDoctorComputeSummaryResponseBodyDataAnalysis : public Darabonba::Model {
public:
  shared_ptr<long> healthyJobCount{};
  shared_ptr<long> needAttentionJobCount{};
  shared_ptr<long> score{};
  shared_ptr<double> scoreDayGrowthRatio{};
  shared_ptr<long> subHealthyJobCount{};
  shared_ptr<long> unhealthyJobCount{};

  GetDoctorComputeSummaryResponseBodyDataAnalysis() {}

  explicit GetDoctorComputeSummaryResponseBodyDataAnalysis(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (healthyJobCount) {
      res["HealthyJobCount"] = boost::any(*healthyJobCount);
    }
    if (needAttentionJobCount) {
      res["NeedAttentionJobCount"] = boost::any(*needAttentionJobCount);
    }
    if (score) {
      res["Score"] = boost::any(*score);
    }
    if (scoreDayGrowthRatio) {
      res["ScoreDayGrowthRatio"] = boost::any(*scoreDayGrowthRatio);
    }
    if (subHealthyJobCount) {
      res["SubHealthyJobCount"] = boost::any(*subHealthyJobCount);
    }
    if (unhealthyJobCount) {
      res["UnhealthyJobCount"] = boost::any(*unhealthyJobCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HealthyJobCount") != m.end() && !m["HealthyJobCount"].empty()) {
      healthyJobCount = make_shared<long>(boost::any_cast<long>(m["HealthyJobCount"]));
    }
    if (m.find("NeedAttentionJobCount") != m.end() && !m["NeedAttentionJobCount"].empty()) {
      needAttentionJobCount = make_shared<long>(boost::any_cast<long>(m["NeedAttentionJobCount"]));
    }
    if (m.find("Score") != m.end() && !m["Score"].empty()) {
      score = make_shared<long>(boost::any_cast<long>(m["Score"]));
    }
    if (m.find("ScoreDayGrowthRatio") != m.end() && !m["ScoreDayGrowthRatio"].empty()) {
      scoreDayGrowthRatio = make_shared<double>(boost::any_cast<double>(m["ScoreDayGrowthRatio"]));
    }
    if (m.find("SubHealthyJobCount") != m.end() && !m["SubHealthyJobCount"].empty()) {
      subHealthyJobCount = make_shared<long>(boost::any_cast<long>(m["SubHealthyJobCount"]));
    }
    if (m.find("UnhealthyJobCount") != m.end() && !m["UnhealthyJobCount"].empty()) {
      unhealthyJobCount = make_shared<long>(boost::any_cast<long>(m["UnhealthyJobCount"]));
    }
  }


  virtual ~GetDoctorComputeSummaryResponseBodyDataAnalysis() = default;
};
class GetDoctorComputeSummaryResponseBodyDataMetricsMemSeconds : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  GetDoctorComputeSummaryResponseBodyDataMetricsMemSeconds() {}

  explicit GetDoctorComputeSummaryResponseBodyDataMetricsMemSeconds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~GetDoctorComputeSummaryResponseBodyDataMetricsMemSeconds() = default;
};
class GetDoctorComputeSummaryResponseBodyDataMetricsMemSecondsDayGrowthRatio : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  GetDoctorComputeSummaryResponseBodyDataMetricsMemSecondsDayGrowthRatio() {}

  explicit GetDoctorComputeSummaryResponseBodyDataMetricsMemSecondsDayGrowthRatio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~GetDoctorComputeSummaryResponseBodyDataMetricsMemSecondsDayGrowthRatio() = default;
};
class GetDoctorComputeSummaryResponseBodyDataMetricsMemUtilization : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  GetDoctorComputeSummaryResponseBodyDataMetricsMemUtilization() {}

  explicit GetDoctorComputeSummaryResponseBodyDataMetricsMemUtilization(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~GetDoctorComputeSummaryResponseBodyDataMetricsMemUtilization() = default;
};
class GetDoctorComputeSummaryResponseBodyDataMetricsReadSize : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  GetDoctorComputeSummaryResponseBodyDataMetricsReadSize() {}

  explicit GetDoctorComputeSummaryResponseBodyDataMetricsReadSize(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~GetDoctorComputeSummaryResponseBodyDataMetricsReadSize() = default;
};
class GetDoctorComputeSummaryResponseBodyDataMetricsVcoreSeconds : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  GetDoctorComputeSummaryResponseBodyDataMetricsVcoreSeconds() {}

  explicit GetDoctorComputeSummaryResponseBodyDataMetricsVcoreSeconds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~GetDoctorComputeSummaryResponseBodyDataMetricsVcoreSeconds() = default;
};
class GetDoctorComputeSummaryResponseBodyDataMetricsVcoreSecondsDayGrowthRatio : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  GetDoctorComputeSummaryResponseBodyDataMetricsVcoreSecondsDayGrowthRatio() {}

  explicit GetDoctorComputeSummaryResponseBodyDataMetricsVcoreSecondsDayGrowthRatio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~GetDoctorComputeSummaryResponseBodyDataMetricsVcoreSecondsDayGrowthRatio() = default;
};
class GetDoctorComputeSummaryResponseBodyDataMetricsVcoreUtilization : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  GetDoctorComputeSummaryResponseBodyDataMetricsVcoreUtilization() {}

  explicit GetDoctorComputeSummaryResponseBodyDataMetricsVcoreUtilization(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~GetDoctorComputeSummaryResponseBodyDataMetricsVcoreUtilization() = default;
};
class GetDoctorComputeSummaryResponseBodyDataMetricsWriteSize : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  GetDoctorComputeSummaryResponseBodyDataMetricsWriteSize() {}

  explicit GetDoctorComputeSummaryResponseBodyDataMetricsWriteSize(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~GetDoctorComputeSummaryResponseBodyDataMetricsWriteSize() = default;
};
class GetDoctorComputeSummaryResponseBodyDataMetrics : public Darabonba::Model {
public:
  shared_ptr<GetDoctorComputeSummaryResponseBodyDataMetricsMemSeconds> memSeconds{};
  shared_ptr<GetDoctorComputeSummaryResponseBodyDataMetricsMemSecondsDayGrowthRatio> memSecondsDayGrowthRatio{};
  shared_ptr<GetDoctorComputeSummaryResponseBodyDataMetricsMemUtilization> memUtilization{};
  shared_ptr<GetDoctorComputeSummaryResponseBodyDataMetricsReadSize> readSize{};
  shared_ptr<GetDoctorComputeSummaryResponseBodyDataMetricsVcoreSeconds> vcoreSeconds{};
  shared_ptr<GetDoctorComputeSummaryResponseBodyDataMetricsVcoreSecondsDayGrowthRatio> vcoreSecondsDayGrowthRatio{};
  shared_ptr<GetDoctorComputeSummaryResponseBodyDataMetricsVcoreUtilization> vcoreUtilization{};
  shared_ptr<GetDoctorComputeSummaryResponseBodyDataMetricsWriteSize> writeSize{};

  GetDoctorComputeSummaryResponseBodyDataMetrics() {}

  explicit GetDoctorComputeSummaryResponseBodyDataMetrics(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (memSeconds) {
      res["MemSeconds"] = memSeconds ? boost::any(memSeconds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (memSecondsDayGrowthRatio) {
      res["MemSecondsDayGrowthRatio"] = memSecondsDayGrowthRatio ? boost::any(memSecondsDayGrowthRatio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (memUtilization) {
      res["MemUtilization"] = memUtilization ? boost::any(memUtilization->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (readSize) {
      res["ReadSize"] = readSize ? boost::any(readSize->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (vcoreSeconds) {
      res["VcoreSeconds"] = vcoreSeconds ? boost::any(vcoreSeconds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (vcoreSecondsDayGrowthRatio) {
      res["VcoreSecondsDayGrowthRatio"] = vcoreSecondsDayGrowthRatio ? boost::any(vcoreSecondsDayGrowthRatio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (vcoreUtilization) {
      res["VcoreUtilization"] = vcoreUtilization ? boost::any(vcoreUtilization->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (writeSize) {
      res["WriteSize"] = writeSize ? boost::any(writeSize->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MemSeconds") != m.end() && !m["MemSeconds"].empty()) {
      if (typeid(map<string, boost::any>) == m["MemSeconds"].type()) {
        GetDoctorComputeSummaryResponseBodyDataMetricsMemSeconds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MemSeconds"]));
        memSeconds = make_shared<GetDoctorComputeSummaryResponseBodyDataMetricsMemSeconds>(model1);
      }
    }
    if (m.find("MemSecondsDayGrowthRatio") != m.end() && !m["MemSecondsDayGrowthRatio"].empty()) {
      if (typeid(map<string, boost::any>) == m["MemSecondsDayGrowthRatio"].type()) {
        GetDoctorComputeSummaryResponseBodyDataMetricsMemSecondsDayGrowthRatio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MemSecondsDayGrowthRatio"]));
        memSecondsDayGrowthRatio = make_shared<GetDoctorComputeSummaryResponseBodyDataMetricsMemSecondsDayGrowthRatio>(model1);
      }
    }
    if (m.find("MemUtilization") != m.end() && !m["MemUtilization"].empty()) {
      if (typeid(map<string, boost::any>) == m["MemUtilization"].type()) {
        GetDoctorComputeSummaryResponseBodyDataMetricsMemUtilization model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MemUtilization"]));
        memUtilization = make_shared<GetDoctorComputeSummaryResponseBodyDataMetricsMemUtilization>(model1);
      }
    }
    if (m.find("ReadSize") != m.end() && !m["ReadSize"].empty()) {
      if (typeid(map<string, boost::any>) == m["ReadSize"].type()) {
        GetDoctorComputeSummaryResponseBodyDataMetricsReadSize model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ReadSize"]));
        readSize = make_shared<GetDoctorComputeSummaryResponseBodyDataMetricsReadSize>(model1);
      }
    }
    if (m.find("VcoreSeconds") != m.end() && !m["VcoreSeconds"].empty()) {
      if (typeid(map<string, boost::any>) == m["VcoreSeconds"].type()) {
        GetDoctorComputeSummaryResponseBodyDataMetricsVcoreSeconds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VcoreSeconds"]));
        vcoreSeconds = make_shared<GetDoctorComputeSummaryResponseBodyDataMetricsVcoreSeconds>(model1);
      }
    }
    if (m.find("VcoreSecondsDayGrowthRatio") != m.end() && !m["VcoreSecondsDayGrowthRatio"].empty()) {
      if (typeid(map<string, boost::any>) == m["VcoreSecondsDayGrowthRatio"].type()) {
        GetDoctorComputeSummaryResponseBodyDataMetricsVcoreSecondsDayGrowthRatio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VcoreSecondsDayGrowthRatio"]));
        vcoreSecondsDayGrowthRatio = make_shared<GetDoctorComputeSummaryResponseBodyDataMetricsVcoreSecondsDayGrowthRatio>(model1);
      }
    }
    if (m.find("VcoreUtilization") != m.end() && !m["VcoreUtilization"].empty()) {
      if (typeid(map<string, boost::any>) == m["VcoreUtilization"].type()) {
        GetDoctorComputeSummaryResponseBodyDataMetricsVcoreUtilization model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VcoreUtilization"]));
        vcoreUtilization = make_shared<GetDoctorComputeSummaryResponseBodyDataMetricsVcoreUtilization>(model1);
      }
    }
    if (m.find("WriteSize") != m.end() && !m["WriteSize"].empty()) {
      if (typeid(map<string, boost::any>) == m["WriteSize"].type()) {
        GetDoctorComputeSummaryResponseBodyDataMetricsWriteSize model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["WriteSize"]));
        writeSize = make_shared<GetDoctorComputeSummaryResponseBodyDataMetricsWriteSize>(model1);
      }
    }
  }


  virtual ~GetDoctorComputeSummaryResponseBodyDataMetrics() = default;
};
class GetDoctorComputeSummaryResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<GetDoctorComputeSummaryResponseBodyDataAnalysis> analysis{};
  shared_ptr<GetDoctorComputeSummaryResponseBodyDataMetrics> metrics{};

  GetDoctorComputeSummaryResponseBodyData() {}

  explicit GetDoctorComputeSummaryResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (analysis) {
      res["Analysis"] = analysis ? boost::any(analysis->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (metrics) {
      res["Metrics"] = metrics ? boost::any(metrics->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Analysis") != m.end() && !m["Analysis"].empty()) {
      if (typeid(map<string, boost::any>) == m["Analysis"].type()) {
        GetDoctorComputeSummaryResponseBodyDataAnalysis model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Analysis"]));
        analysis = make_shared<GetDoctorComputeSummaryResponseBodyDataAnalysis>(model1);
      }
    }
    if (m.find("Metrics") != m.end() && !m["Metrics"].empty()) {
      if (typeid(map<string, boost::any>) == m["Metrics"].type()) {
        GetDoctorComputeSummaryResponseBodyDataMetrics model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Metrics"]));
        metrics = make_shared<GetDoctorComputeSummaryResponseBodyDataMetrics>(model1);
      }
    }
  }


  virtual ~GetDoctorComputeSummaryResponseBodyData() = default;
};
class GetDoctorComputeSummaryResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetDoctorComputeSummaryResponseBodyData> data{};
  shared_ptr<string> requestId{};

  GetDoctorComputeSummaryResponseBody() {}

  explicit GetDoctorComputeSummaryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetDoctorComputeSummaryResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetDoctorComputeSummaryResponseBodyData>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetDoctorComputeSummaryResponseBody() = default;
};
class GetDoctorComputeSummaryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetDoctorComputeSummaryResponseBody> body{};

  GetDoctorComputeSummaryResponse() {}

  explicit GetDoctorComputeSummaryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetDoctorComputeSummaryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetDoctorComputeSummaryResponseBody>(model1);
      }
    }
  }


  virtual ~GetDoctorComputeSummaryResponse() = default;
};
class GetDoctorHBaseClusterRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> dateTime{};
  shared_ptr<string> regionId{};

  GetDoctorHBaseClusterRequest() {}

  explicit GetDoctorHBaseClusterRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (dateTime) {
      res["DateTime"] = boost::any(*dateTime);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("DateTime") != m.end() && !m["DateTime"].empty()) {
      dateTime = make_shared<string>(boost::any_cast<string>(m["DateTime"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~GetDoctorHBaseClusterRequest() = default;
};
class GetDoctorHBaseClusterResponseBodyDataAnalysis : public Darabonba::Model {
public:
  shared_ptr<long> hbaseScore{};

  GetDoctorHBaseClusterResponseBodyDataAnalysis() {}

  explicit GetDoctorHBaseClusterResponseBodyDataAnalysis(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hbaseScore) {
      res["HbaseScore"] = boost::any(*hbaseScore);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HbaseScore") != m.end() && !m["HbaseScore"].empty()) {
      hbaseScore = make_shared<long>(boost::any_cast<long>(m["HbaseScore"]));
    }
  }


  virtual ~GetDoctorHBaseClusterResponseBodyDataAnalysis() = default;
};
class GetDoctorHBaseClusterResponseBodyDataMetricsAvgLoad : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  GetDoctorHBaseClusterResponseBodyDataMetricsAvgLoad() {}

  explicit GetDoctorHBaseClusterResponseBodyDataMetricsAvgLoad(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~GetDoctorHBaseClusterResponseBodyDataMetricsAvgLoad() = default;
};
class GetDoctorHBaseClusterResponseBodyDataMetricsDailyReadRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  GetDoctorHBaseClusterResponseBodyDataMetricsDailyReadRequest() {}

  explicit GetDoctorHBaseClusterResponseBodyDataMetricsDailyReadRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~GetDoctorHBaseClusterResponseBodyDataMetricsDailyReadRequest() = default;
};
class GetDoctorHBaseClusterResponseBodyDataMetricsDailyWriteRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  GetDoctorHBaseClusterResponseBodyDataMetricsDailyWriteRequest() {}

  explicit GetDoctorHBaseClusterResponseBodyDataMetricsDailyWriteRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~GetDoctorHBaseClusterResponseBodyDataMetricsDailyWriteRequest() = default;
};
class GetDoctorHBaseClusterResponseBodyDataMetricsMemHeap : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  GetDoctorHBaseClusterResponseBodyDataMetricsMemHeap() {}

  explicit GetDoctorHBaseClusterResponseBodyDataMetricsMemHeap(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~GetDoctorHBaseClusterResponseBodyDataMetricsMemHeap() = default;
};
class GetDoctorHBaseClusterResponseBodyDataMetricsNormalAvgLoad : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  GetDoctorHBaseClusterResponseBodyDataMetricsNormalAvgLoad() {}

  explicit GetDoctorHBaseClusterResponseBodyDataMetricsNormalAvgLoad(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~GetDoctorHBaseClusterResponseBodyDataMetricsNormalAvgLoad() = default;
};
class GetDoctorHBaseClusterResponseBodyDataMetricsRegionBalance : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  GetDoctorHBaseClusterResponseBodyDataMetricsRegionBalance() {}

  explicit GetDoctorHBaseClusterResponseBodyDataMetricsRegionBalance(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~GetDoctorHBaseClusterResponseBodyDataMetricsRegionBalance() = default;
};
class GetDoctorHBaseClusterResponseBodyDataMetricsRegionCount : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  GetDoctorHBaseClusterResponseBodyDataMetricsRegionCount() {}

  explicit GetDoctorHBaseClusterResponseBodyDataMetricsRegionCount(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~GetDoctorHBaseClusterResponseBodyDataMetricsRegionCount() = default;
};
class GetDoctorHBaseClusterResponseBodyDataMetricsRegionServerCount : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  GetDoctorHBaseClusterResponseBodyDataMetricsRegionServerCount() {}

  explicit GetDoctorHBaseClusterResponseBodyDataMetricsRegionServerCount(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~GetDoctorHBaseClusterResponseBodyDataMetricsRegionServerCount() = default;
};
class GetDoctorHBaseClusterResponseBodyDataMetricsStoreFileCount : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  GetDoctorHBaseClusterResponseBodyDataMetricsStoreFileCount() {}

  explicit GetDoctorHBaseClusterResponseBodyDataMetricsStoreFileCount(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~GetDoctorHBaseClusterResponseBodyDataMetricsStoreFileCount() = default;
};
class GetDoctorHBaseClusterResponseBodyDataMetricsTableCount : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  GetDoctorHBaseClusterResponseBodyDataMetricsTableCount() {}

  explicit GetDoctorHBaseClusterResponseBodyDataMetricsTableCount(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~GetDoctorHBaseClusterResponseBodyDataMetricsTableCount() = default;
};
class GetDoctorHBaseClusterResponseBodyDataMetricsTotalDataSize : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  GetDoctorHBaseClusterResponseBodyDataMetricsTotalDataSize() {}

  explicit GetDoctorHBaseClusterResponseBodyDataMetricsTotalDataSize(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~GetDoctorHBaseClusterResponseBodyDataMetricsTotalDataSize() = default;
};
class GetDoctorHBaseClusterResponseBodyDataMetricsTotalReadRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  GetDoctorHBaseClusterResponseBodyDataMetricsTotalReadRequest() {}

  explicit GetDoctorHBaseClusterResponseBodyDataMetricsTotalReadRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~GetDoctorHBaseClusterResponseBodyDataMetricsTotalReadRequest() = default;
};
class GetDoctorHBaseClusterResponseBodyDataMetricsTotalRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  GetDoctorHBaseClusterResponseBodyDataMetricsTotalRequest() {}

  explicit GetDoctorHBaseClusterResponseBodyDataMetricsTotalRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~GetDoctorHBaseClusterResponseBodyDataMetricsTotalRequest() = default;
};
class GetDoctorHBaseClusterResponseBodyDataMetricsTotalWriteRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  GetDoctorHBaseClusterResponseBodyDataMetricsTotalWriteRequest() {}

  explicit GetDoctorHBaseClusterResponseBodyDataMetricsTotalWriteRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~GetDoctorHBaseClusterResponseBodyDataMetricsTotalWriteRequest() = default;
};
class GetDoctorHBaseClusterResponseBodyDataMetrics : public Darabonba::Model {
public:
  shared_ptr<GetDoctorHBaseClusterResponseBodyDataMetricsAvgLoad> avgLoad{};
  shared_ptr<GetDoctorHBaseClusterResponseBodyDataMetricsDailyReadRequest> dailyReadRequest{};
  shared_ptr<GetDoctorHBaseClusterResponseBodyDataMetricsDailyWriteRequest> dailyWriteRequest{};
  shared_ptr<GetDoctorHBaseClusterResponseBodyDataMetricsMemHeap> memHeap{};
  shared_ptr<GetDoctorHBaseClusterResponseBodyDataMetricsNormalAvgLoad> normalAvgLoad{};
  shared_ptr<GetDoctorHBaseClusterResponseBodyDataMetricsRegionBalance> regionBalance{};
  shared_ptr<GetDoctorHBaseClusterResponseBodyDataMetricsRegionCount> regionCount{};
  shared_ptr<GetDoctorHBaseClusterResponseBodyDataMetricsRegionServerCount> regionServerCount{};
  shared_ptr<GetDoctorHBaseClusterResponseBodyDataMetricsStoreFileCount> storeFileCount{};
  shared_ptr<GetDoctorHBaseClusterResponseBodyDataMetricsTableCount> tableCount{};
  shared_ptr<GetDoctorHBaseClusterResponseBodyDataMetricsTotalDataSize> totalDataSize{};
  shared_ptr<GetDoctorHBaseClusterResponseBodyDataMetricsTotalReadRequest> totalReadRequest{};
  shared_ptr<GetDoctorHBaseClusterResponseBodyDataMetricsTotalRequest> totalRequest{};
  shared_ptr<GetDoctorHBaseClusterResponseBodyDataMetricsTotalWriteRequest> totalWriteRequest{};

  GetDoctorHBaseClusterResponseBodyDataMetrics() {}

  explicit GetDoctorHBaseClusterResponseBodyDataMetrics(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (avgLoad) {
      res["AvgLoad"] = avgLoad ? boost::any(avgLoad->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (dailyReadRequest) {
      res["DailyReadRequest"] = dailyReadRequest ? boost::any(dailyReadRequest->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (dailyWriteRequest) {
      res["DailyWriteRequest"] = dailyWriteRequest ? boost::any(dailyWriteRequest->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (memHeap) {
      res["MemHeap"] = memHeap ? boost::any(memHeap->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (normalAvgLoad) {
      res["NormalAvgLoad"] = normalAvgLoad ? boost::any(normalAvgLoad->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (regionBalance) {
      res["RegionBalance"] = regionBalance ? boost::any(regionBalance->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (regionCount) {
      res["RegionCount"] = regionCount ? boost::any(regionCount->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (regionServerCount) {
      res["RegionServerCount"] = regionServerCount ? boost::any(regionServerCount->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (storeFileCount) {
      res["StoreFileCount"] = storeFileCount ? boost::any(storeFileCount->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tableCount) {
      res["TableCount"] = tableCount ? boost::any(tableCount->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (totalDataSize) {
      res["TotalDataSize"] = totalDataSize ? boost::any(totalDataSize->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (totalReadRequest) {
      res["TotalReadRequest"] = totalReadRequest ? boost::any(totalReadRequest->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (totalRequest) {
      res["TotalRequest"] = totalRequest ? boost::any(totalRequest->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (totalWriteRequest) {
      res["TotalWriteRequest"] = totalWriteRequest ? boost::any(totalWriteRequest->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AvgLoad") != m.end() && !m["AvgLoad"].empty()) {
      if (typeid(map<string, boost::any>) == m["AvgLoad"].type()) {
        GetDoctorHBaseClusterResponseBodyDataMetricsAvgLoad model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AvgLoad"]));
        avgLoad = make_shared<GetDoctorHBaseClusterResponseBodyDataMetricsAvgLoad>(model1);
      }
    }
    if (m.find("DailyReadRequest") != m.end() && !m["DailyReadRequest"].empty()) {
      if (typeid(map<string, boost::any>) == m["DailyReadRequest"].type()) {
        GetDoctorHBaseClusterResponseBodyDataMetricsDailyReadRequest model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DailyReadRequest"]));
        dailyReadRequest = make_shared<GetDoctorHBaseClusterResponseBodyDataMetricsDailyReadRequest>(model1);
      }
    }
    if (m.find("DailyWriteRequest") != m.end() && !m["DailyWriteRequest"].empty()) {
      if (typeid(map<string, boost::any>) == m["DailyWriteRequest"].type()) {
        GetDoctorHBaseClusterResponseBodyDataMetricsDailyWriteRequest model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DailyWriteRequest"]));
        dailyWriteRequest = make_shared<GetDoctorHBaseClusterResponseBodyDataMetricsDailyWriteRequest>(model1);
      }
    }
    if (m.find("MemHeap") != m.end() && !m["MemHeap"].empty()) {
      if (typeid(map<string, boost::any>) == m["MemHeap"].type()) {
        GetDoctorHBaseClusterResponseBodyDataMetricsMemHeap model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MemHeap"]));
        memHeap = make_shared<GetDoctorHBaseClusterResponseBodyDataMetricsMemHeap>(model1);
      }
    }
    if (m.find("NormalAvgLoad") != m.end() && !m["NormalAvgLoad"].empty()) {
      if (typeid(map<string, boost::any>) == m["NormalAvgLoad"].type()) {
        GetDoctorHBaseClusterResponseBodyDataMetricsNormalAvgLoad model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NormalAvgLoad"]));
        normalAvgLoad = make_shared<GetDoctorHBaseClusterResponseBodyDataMetricsNormalAvgLoad>(model1);
      }
    }
    if (m.find("RegionBalance") != m.end() && !m["RegionBalance"].empty()) {
      if (typeid(map<string, boost::any>) == m["RegionBalance"].type()) {
        GetDoctorHBaseClusterResponseBodyDataMetricsRegionBalance model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RegionBalance"]));
        regionBalance = make_shared<GetDoctorHBaseClusterResponseBodyDataMetricsRegionBalance>(model1);
      }
    }
    if (m.find("RegionCount") != m.end() && !m["RegionCount"].empty()) {
      if (typeid(map<string, boost::any>) == m["RegionCount"].type()) {
        GetDoctorHBaseClusterResponseBodyDataMetricsRegionCount model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RegionCount"]));
        regionCount = make_shared<GetDoctorHBaseClusterResponseBodyDataMetricsRegionCount>(model1);
      }
    }
    if (m.find("RegionServerCount") != m.end() && !m["RegionServerCount"].empty()) {
      if (typeid(map<string, boost::any>) == m["RegionServerCount"].type()) {
        GetDoctorHBaseClusterResponseBodyDataMetricsRegionServerCount model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RegionServerCount"]));
        regionServerCount = make_shared<GetDoctorHBaseClusterResponseBodyDataMetricsRegionServerCount>(model1);
      }
    }
    if (m.find("StoreFileCount") != m.end() && !m["StoreFileCount"].empty()) {
      if (typeid(map<string, boost::any>) == m["StoreFileCount"].type()) {
        GetDoctorHBaseClusterResponseBodyDataMetricsStoreFileCount model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["StoreFileCount"]));
        storeFileCount = make_shared<GetDoctorHBaseClusterResponseBodyDataMetricsStoreFileCount>(model1);
      }
    }
    if (m.find("TableCount") != m.end() && !m["TableCount"].empty()) {
      if (typeid(map<string, boost::any>) == m["TableCount"].type()) {
        GetDoctorHBaseClusterResponseBodyDataMetricsTableCount model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TableCount"]));
        tableCount = make_shared<GetDoctorHBaseClusterResponseBodyDataMetricsTableCount>(model1);
      }
    }
    if (m.find("TotalDataSize") != m.end() && !m["TotalDataSize"].empty()) {
      if (typeid(map<string, boost::any>) == m["TotalDataSize"].type()) {
        GetDoctorHBaseClusterResponseBodyDataMetricsTotalDataSize model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TotalDataSize"]));
        totalDataSize = make_shared<GetDoctorHBaseClusterResponseBodyDataMetricsTotalDataSize>(model1);
      }
    }
    if (m.find("TotalReadRequest") != m.end() && !m["TotalReadRequest"].empty()) {
      if (typeid(map<string, boost::any>) == m["TotalReadRequest"].type()) {
        GetDoctorHBaseClusterResponseBodyDataMetricsTotalReadRequest model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TotalReadRequest"]));
        totalReadRequest = make_shared<GetDoctorHBaseClusterResponseBodyDataMetricsTotalReadRequest>(model1);
      }
    }
    if (m.find("TotalRequest") != m.end() && !m["TotalRequest"].empty()) {
      if (typeid(map<string, boost::any>) == m["TotalRequest"].type()) {
        GetDoctorHBaseClusterResponseBodyDataMetricsTotalRequest model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TotalRequest"]));
        totalRequest = make_shared<GetDoctorHBaseClusterResponseBodyDataMetricsTotalRequest>(model1);
      }
    }
    if (m.find("TotalWriteRequest") != m.end() && !m["TotalWriteRequest"].empty()) {
      if (typeid(map<string, boost::any>) == m["TotalWriteRequest"].type()) {
        GetDoctorHBaseClusterResponseBodyDataMetricsTotalWriteRequest model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TotalWriteRequest"]));
        totalWriteRequest = make_shared<GetDoctorHBaseClusterResponseBodyDataMetricsTotalWriteRequest>(model1);
      }
    }
  }


  virtual ~GetDoctorHBaseClusterResponseBodyDataMetrics() = default;
};
class GetDoctorHBaseClusterResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<GetDoctorHBaseClusterResponseBodyDataAnalysis> analysis{};
  shared_ptr<GetDoctorHBaseClusterResponseBodyDataMetrics> metrics{};

  GetDoctorHBaseClusterResponseBodyData() {}

  explicit GetDoctorHBaseClusterResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (analysis) {
      res["Analysis"] = analysis ? boost::any(analysis->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (metrics) {
      res["Metrics"] = metrics ? boost::any(metrics->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Analysis") != m.end() && !m["Analysis"].empty()) {
      if (typeid(map<string, boost::any>) == m["Analysis"].type()) {
        GetDoctorHBaseClusterResponseBodyDataAnalysis model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Analysis"]));
        analysis = make_shared<GetDoctorHBaseClusterResponseBodyDataAnalysis>(model1);
      }
    }
    if (m.find("Metrics") != m.end() && !m["Metrics"].empty()) {
      if (typeid(map<string, boost::any>) == m["Metrics"].type()) {
        GetDoctorHBaseClusterResponseBodyDataMetrics model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Metrics"]));
        metrics = make_shared<GetDoctorHBaseClusterResponseBodyDataMetrics>(model1);
      }
    }
  }


  virtual ~GetDoctorHBaseClusterResponseBodyData() = default;
};
class GetDoctorHBaseClusterResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetDoctorHBaseClusterResponseBodyData> data{};
  shared_ptr<string> requestId{};

  GetDoctorHBaseClusterResponseBody() {}

  explicit GetDoctorHBaseClusterResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetDoctorHBaseClusterResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetDoctorHBaseClusterResponseBodyData>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetDoctorHBaseClusterResponseBody() = default;
};
class GetDoctorHBaseClusterResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetDoctorHBaseClusterResponseBody> body{};

  GetDoctorHBaseClusterResponse() {}

  explicit GetDoctorHBaseClusterResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetDoctorHBaseClusterResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetDoctorHBaseClusterResponseBody>(model1);
      }
    }
  }


  virtual ~GetDoctorHBaseClusterResponse() = default;
};
class GetDoctorHBaseRegionRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> dateTime{};
  shared_ptr<string> hbaseRegionId{};
  shared_ptr<string> regionId{};

  GetDoctorHBaseRegionRequest() {}

  explicit GetDoctorHBaseRegionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (dateTime) {
      res["DateTime"] = boost::any(*dateTime);
    }
    if (hbaseRegionId) {
      res["HbaseRegionId"] = boost::any(*hbaseRegionId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("DateTime") != m.end() && !m["DateTime"].empty()) {
      dateTime = make_shared<string>(boost::any_cast<string>(m["DateTime"]));
    }
    if (m.find("HbaseRegionId") != m.end() && !m["HbaseRegionId"].empty()) {
      hbaseRegionId = make_shared<string>(boost::any_cast<string>(m["HbaseRegionId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~GetDoctorHBaseRegionRequest() = default;
};
class GetDoctorHBaseRegionResponseBodyDataMetricsDailyReadRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  GetDoctorHBaseRegionResponseBodyDataMetricsDailyReadRequest() {}

  explicit GetDoctorHBaseRegionResponseBodyDataMetricsDailyReadRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~GetDoctorHBaseRegionResponseBodyDataMetricsDailyReadRequest() = default;
};
class GetDoctorHBaseRegionResponseBodyDataMetricsDailyWriteRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  GetDoctorHBaseRegionResponseBodyDataMetricsDailyWriteRequest() {}

  explicit GetDoctorHBaseRegionResponseBodyDataMetricsDailyWriteRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~GetDoctorHBaseRegionResponseBodyDataMetricsDailyWriteRequest() = default;
};
class GetDoctorHBaseRegionResponseBodyDataMetricsStoreFileCount : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  GetDoctorHBaseRegionResponseBodyDataMetricsStoreFileCount() {}

  explicit GetDoctorHBaseRegionResponseBodyDataMetricsStoreFileCount(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~GetDoctorHBaseRegionResponseBodyDataMetricsStoreFileCount() = default;
};
class GetDoctorHBaseRegionResponseBodyDataMetricsTotalReadRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  GetDoctorHBaseRegionResponseBodyDataMetricsTotalReadRequest() {}

  explicit GetDoctorHBaseRegionResponseBodyDataMetricsTotalReadRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~GetDoctorHBaseRegionResponseBodyDataMetricsTotalReadRequest() = default;
};
class GetDoctorHBaseRegionResponseBodyDataMetricsTotalWriteRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  GetDoctorHBaseRegionResponseBodyDataMetricsTotalWriteRequest() {}

  explicit GetDoctorHBaseRegionResponseBodyDataMetricsTotalWriteRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~GetDoctorHBaseRegionResponseBodyDataMetricsTotalWriteRequest() = default;
};
class GetDoctorHBaseRegionResponseBodyDataMetrics : public Darabonba::Model {
public:
  shared_ptr<GetDoctorHBaseRegionResponseBodyDataMetricsDailyReadRequest> dailyReadRequest{};
  shared_ptr<GetDoctorHBaseRegionResponseBodyDataMetricsDailyWriteRequest> dailyWriteRequest{};
  shared_ptr<GetDoctorHBaseRegionResponseBodyDataMetricsStoreFileCount> storeFileCount{};
  shared_ptr<GetDoctorHBaseRegionResponseBodyDataMetricsTotalReadRequest> totalReadRequest{};
  shared_ptr<GetDoctorHBaseRegionResponseBodyDataMetricsTotalWriteRequest> totalWriteRequest{};

  GetDoctorHBaseRegionResponseBodyDataMetrics() {}

  explicit GetDoctorHBaseRegionResponseBodyDataMetrics(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dailyReadRequest) {
      res["DailyReadRequest"] = dailyReadRequest ? boost::any(dailyReadRequest->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (dailyWriteRequest) {
      res["DailyWriteRequest"] = dailyWriteRequest ? boost::any(dailyWriteRequest->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (storeFileCount) {
      res["StoreFileCount"] = storeFileCount ? boost::any(storeFileCount->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (totalReadRequest) {
      res["TotalReadRequest"] = totalReadRequest ? boost::any(totalReadRequest->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (totalWriteRequest) {
      res["TotalWriteRequest"] = totalWriteRequest ? boost::any(totalWriteRequest->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DailyReadRequest") != m.end() && !m["DailyReadRequest"].empty()) {
      if (typeid(map<string, boost::any>) == m["DailyReadRequest"].type()) {
        GetDoctorHBaseRegionResponseBodyDataMetricsDailyReadRequest model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DailyReadRequest"]));
        dailyReadRequest = make_shared<GetDoctorHBaseRegionResponseBodyDataMetricsDailyReadRequest>(model1);
      }
    }
    if (m.find("DailyWriteRequest") != m.end() && !m["DailyWriteRequest"].empty()) {
      if (typeid(map<string, boost::any>) == m["DailyWriteRequest"].type()) {
        GetDoctorHBaseRegionResponseBodyDataMetricsDailyWriteRequest model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DailyWriteRequest"]));
        dailyWriteRequest = make_shared<GetDoctorHBaseRegionResponseBodyDataMetricsDailyWriteRequest>(model1);
      }
    }
    if (m.find("StoreFileCount") != m.end() && !m["StoreFileCount"].empty()) {
      if (typeid(map<string, boost::any>) == m["StoreFileCount"].type()) {
        GetDoctorHBaseRegionResponseBodyDataMetricsStoreFileCount model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["StoreFileCount"]));
        storeFileCount = make_shared<GetDoctorHBaseRegionResponseBodyDataMetricsStoreFileCount>(model1);
      }
    }
    if (m.find("TotalReadRequest") != m.end() && !m["TotalReadRequest"].empty()) {
      if (typeid(map<string, boost::any>) == m["TotalReadRequest"].type()) {
        GetDoctorHBaseRegionResponseBodyDataMetricsTotalReadRequest model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TotalReadRequest"]));
        totalReadRequest = make_shared<GetDoctorHBaseRegionResponseBodyDataMetricsTotalReadRequest>(model1);
      }
    }
    if (m.find("TotalWriteRequest") != m.end() && !m["TotalWriteRequest"].empty()) {
      if (typeid(map<string, boost::any>) == m["TotalWriteRequest"].type()) {
        GetDoctorHBaseRegionResponseBodyDataMetricsTotalWriteRequest model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TotalWriteRequest"]));
        totalWriteRequest = make_shared<GetDoctorHBaseRegionResponseBodyDataMetricsTotalWriteRequest>(model1);
      }
    }
  }


  virtual ~GetDoctorHBaseRegionResponseBodyDataMetrics() = default;
};
class GetDoctorHBaseRegionResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<GetDoctorHBaseRegionResponseBodyDataMetrics> metrics{};
  shared_ptr<string> regionServerHost{};
  shared_ptr<string> tableName{};

  GetDoctorHBaseRegionResponseBodyData() {}

  explicit GetDoctorHBaseRegionResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (metrics) {
      res["Metrics"] = metrics ? boost::any(metrics->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (regionServerHost) {
      res["RegionServerHost"] = boost::any(*regionServerHost);
    }
    if (tableName) {
      res["TableName"] = boost::any(*tableName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Metrics") != m.end() && !m["Metrics"].empty()) {
      if (typeid(map<string, boost::any>) == m["Metrics"].type()) {
        GetDoctorHBaseRegionResponseBodyDataMetrics model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Metrics"]));
        metrics = make_shared<GetDoctorHBaseRegionResponseBodyDataMetrics>(model1);
      }
    }
    if (m.find("RegionServerHost") != m.end() && !m["RegionServerHost"].empty()) {
      regionServerHost = make_shared<string>(boost::any_cast<string>(m["RegionServerHost"]));
    }
    if (m.find("TableName") != m.end() && !m["TableName"].empty()) {
      tableName = make_shared<string>(boost::any_cast<string>(m["TableName"]));
    }
  }


  virtual ~GetDoctorHBaseRegionResponseBodyData() = default;
};
class GetDoctorHBaseRegionResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetDoctorHBaseRegionResponseBodyData> data{};
  shared_ptr<string> requestId{};

  GetDoctorHBaseRegionResponseBody() {}

  explicit GetDoctorHBaseRegionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetDoctorHBaseRegionResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetDoctorHBaseRegionResponseBodyData>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetDoctorHBaseRegionResponseBody() = default;
};
class GetDoctorHBaseRegionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetDoctorHBaseRegionResponseBody> body{};

  GetDoctorHBaseRegionResponse() {}

  explicit GetDoctorHBaseRegionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetDoctorHBaseRegionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetDoctorHBaseRegionResponseBody>(model1);
      }
    }
  }


  virtual ~GetDoctorHBaseRegionResponse() = default;
};
class GetDoctorHBaseRegionServerRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> dateTime{};
  shared_ptr<string> regionId{};
  shared_ptr<string> regionServerHost{};

  GetDoctorHBaseRegionServerRequest() {}

  explicit GetDoctorHBaseRegionServerRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (dateTime) {
      res["DateTime"] = boost::any(*dateTime);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (regionServerHost) {
      res["RegionServerHost"] = boost::any(*regionServerHost);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("DateTime") != m.end() && !m["DateTime"].empty()) {
      dateTime = make_shared<string>(boost::any_cast<string>(m["DateTime"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RegionServerHost") != m.end() && !m["RegionServerHost"].empty()) {
      regionServerHost = make_shared<string>(boost::any_cast<string>(m["RegionServerHost"]));
    }
  }


  virtual ~GetDoctorHBaseRegionServerRequest() = default;
};
class GetDoctorHBaseRegionServerResponseBodyDataMetricsAvgGc : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  GetDoctorHBaseRegionServerResponseBodyDataMetricsAvgGc() {}

  explicit GetDoctorHBaseRegionServerResponseBodyDataMetricsAvgGc(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~GetDoctorHBaseRegionServerResponseBodyDataMetricsAvgGc() = default;
};
class GetDoctorHBaseRegionServerResponseBodyDataMetricsCacheRatio : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  GetDoctorHBaseRegionServerResponseBodyDataMetricsCacheRatio() {}

  explicit GetDoctorHBaseRegionServerResponseBodyDataMetricsCacheRatio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~GetDoctorHBaseRegionServerResponseBodyDataMetricsCacheRatio() = default;
};
class GetDoctorHBaseRegionServerResponseBodyDataMetricsDailyReadRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  GetDoctorHBaseRegionServerResponseBodyDataMetricsDailyReadRequest() {}

  explicit GetDoctorHBaseRegionServerResponseBodyDataMetricsDailyReadRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~GetDoctorHBaseRegionServerResponseBodyDataMetricsDailyReadRequest() = default;
};
class GetDoctorHBaseRegionServerResponseBodyDataMetricsDailyReadRequestDayGrowthRatio : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  GetDoctorHBaseRegionServerResponseBodyDataMetricsDailyReadRequestDayGrowthRatio() {}

  explicit GetDoctorHBaseRegionServerResponseBodyDataMetricsDailyReadRequestDayGrowthRatio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~GetDoctorHBaseRegionServerResponseBodyDataMetricsDailyReadRequestDayGrowthRatio() = default;
};
class GetDoctorHBaseRegionServerResponseBodyDataMetricsDailyWriteRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  GetDoctorHBaseRegionServerResponseBodyDataMetricsDailyWriteRequest() {}

  explicit GetDoctorHBaseRegionServerResponseBodyDataMetricsDailyWriteRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~GetDoctorHBaseRegionServerResponseBodyDataMetricsDailyWriteRequest() = default;
};
class GetDoctorHBaseRegionServerResponseBodyDataMetricsDailyWriteRequestDayGrowthRatio : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  GetDoctorHBaseRegionServerResponseBodyDataMetricsDailyWriteRequestDayGrowthRatio() {}

  explicit GetDoctorHBaseRegionServerResponseBodyDataMetricsDailyWriteRequestDayGrowthRatio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~GetDoctorHBaseRegionServerResponseBodyDataMetricsDailyWriteRequestDayGrowthRatio() = default;
};
class GetDoctorHBaseRegionServerResponseBodyDataMetricsRegionCount : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  GetDoctorHBaseRegionServerResponseBodyDataMetricsRegionCount() {}

  explicit GetDoctorHBaseRegionServerResponseBodyDataMetricsRegionCount(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~GetDoctorHBaseRegionServerResponseBodyDataMetricsRegionCount() = default;
};
class GetDoctorHBaseRegionServerResponseBodyDataMetricsTotalReadRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  GetDoctorHBaseRegionServerResponseBodyDataMetricsTotalReadRequest() {}

  explicit GetDoctorHBaseRegionServerResponseBodyDataMetricsTotalReadRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~GetDoctorHBaseRegionServerResponseBodyDataMetricsTotalReadRequest() = default;
};
class GetDoctorHBaseRegionServerResponseBodyDataMetricsTotalRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  GetDoctorHBaseRegionServerResponseBodyDataMetricsTotalRequest() {}

  explicit GetDoctorHBaseRegionServerResponseBodyDataMetricsTotalRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~GetDoctorHBaseRegionServerResponseBodyDataMetricsTotalRequest() = default;
};
class GetDoctorHBaseRegionServerResponseBodyDataMetricsTotalWriteRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  GetDoctorHBaseRegionServerResponseBodyDataMetricsTotalWriteRequest() {}

  explicit GetDoctorHBaseRegionServerResponseBodyDataMetricsTotalWriteRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~GetDoctorHBaseRegionServerResponseBodyDataMetricsTotalWriteRequest() = default;
};
class GetDoctorHBaseRegionServerResponseBodyDataMetrics : public Darabonba::Model {
public:
  shared_ptr<GetDoctorHBaseRegionServerResponseBodyDataMetricsAvgGc> avgGc{};
  shared_ptr<GetDoctorHBaseRegionServerResponseBodyDataMetricsCacheRatio> cacheRatio{};
  shared_ptr<GetDoctorHBaseRegionServerResponseBodyDataMetricsDailyReadRequest> dailyReadRequest{};
  shared_ptr<GetDoctorHBaseRegionServerResponseBodyDataMetricsDailyReadRequestDayGrowthRatio> dailyReadRequestDayGrowthRatio{};
  shared_ptr<GetDoctorHBaseRegionServerResponseBodyDataMetricsDailyWriteRequest> dailyWriteRequest{};
  shared_ptr<GetDoctorHBaseRegionServerResponseBodyDataMetricsDailyWriteRequestDayGrowthRatio> dailyWriteRequestDayGrowthRatio{};
  shared_ptr<GetDoctorHBaseRegionServerResponseBodyDataMetricsRegionCount> regionCount{};
  shared_ptr<GetDoctorHBaseRegionServerResponseBodyDataMetricsTotalReadRequest> totalReadRequest{};
  shared_ptr<GetDoctorHBaseRegionServerResponseBodyDataMetricsTotalRequest> totalRequest{};
  shared_ptr<GetDoctorHBaseRegionServerResponseBodyDataMetricsTotalWriteRequest> totalWriteRequest{};

  GetDoctorHBaseRegionServerResponseBodyDataMetrics() {}

  explicit GetDoctorHBaseRegionServerResponseBodyDataMetrics(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (avgGc) {
      res["AvgGc"] = avgGc ? boost::any(avgGc->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (cacheRatio) {
      res["CacheRatio"] = cacheRatio ? boost::any(cacheRatio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (dailyReadRequest) {
      res["DailyReadRequest"] = dailyReadRequest ? boost::any(dailyReadRequest->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (dailyReadRequestDayGrowthRatio) {
      res["DailyReadRequestDayGrowthRatio"] = dailyReadRequestDayGrowthRatio ? boost::any(dailyReadRequestDayGrowthRatio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (dailyWriteRequest) {
      res["DailyWriteRequest"] = dailyWriteRequest ? boost::any(dailyWriteRequest->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (dailyWriteRequestDayGrowthRatio) {
      res["DailyWriteRequestDayGrowthRatio"] = dailyWriteRequestDayGrowthRatio ? boost::any(dailyWriteRequestDayGrowthRatio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (regionCount) {
      res["RegionCount"] = regionCount ? boost::any(regionCount->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (totalReadRequest) {
      res["TotalReadRequest"] = totalReadRequest ? boost::any(totalReadRequest->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (totalRequest) {
      res["TotalRequest"] = totalRequest ? boost::any(totalRequest->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (totalWriteRequest) {
      res["TotalWriteRequest"] = totalWriteRequest ? boost::any(totalWriteRequest->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AvgGc") != m.end() && !m["AvgGc"].empty()) {
      if (typeid(map<string, boost::any>) == m["AvgGc"].type()) {
        GetDoctorHBaseRegionServerResponseBodyDataMetricsAvgGc model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AvgGc"]));
        avgGc = make_shared<GetDoctorHBaseRegionServerResponseBodyDataMetricsAvgGc>(model1);
      }
    }
    if (m.find("CacheRatio") != m.end() && !m["CacheRatio"].empty()) {
      if (typeid(map<string, boost::any>) == m["CacheRatio"].type()) {
        GetDoctorHBaseRegionServerResponseBodyDataMetricsCacheRatio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CacheRatio"]));
        cacheRatio = make_shared<GetDoctorHBaseRegionServerResponseBodyDataMetricsCacheRatio>(model1);
      }
    }
    if (m.find("DailyReadRequest") != m.end() && !m["DailyReadRequest"].empty()) {
      if (typeid(map<string, boost::any>) == m["DailyReadRequest"].type()) {
        GetDoctorHBaseRegionServerResponseBodyDataMetricsDailyReadRequest model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DailyReadRequest"]));
        dailyReadRequest = make_shared<GetDoctorHBaseRegionServerResponseBodyDataMetricsDailyReadRequest>(model1);
      }
    }
    if (m.find("DailyReadRequestDayGrowthRatio") != m.end() && !m["DailyReadRequestDayGrowthRatio"].empty()) {
      if (typeid(map<string, boost::any>) == m["DailyReadRequestDayGrowthRatio"].type()) {
        GetDoctorHBaseRegionServerResponseBodyDataMetricsDailyReadRequestDayGrowthRatio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DailyReadRequestDayGrowthRatio"]));
        dailyReadRequestDayGrowthRatio = make_shared<GetDoctorHBaseRegionServerResponseBodyDataMetricsDailyReadRequestDayGrowthRatio>(model1);
      }
    }
    if (m.find("DailyWriteRequest") != m.end() && !m["DailyWriteRequest"].empty()) {
      if (typeid(map<string, boost::any>) == m["DailyWriteRequest"].type()) {
        GetDoctorHBaseRegionServerResponseBodyDataMetricsDailyWriteRequest model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DailyWriteRequest"]));
        dailyWriteRequest = make_shared<GetDoctorHBaseRegionServerResponseBodyDataMetricsDailyWriteRequest>(model1);
      }
    }
    if (m.find("DailyWriteRequestDayGrowthRatio") != m.end() && !m["DailyWriteRequestDayGrowthRatio"].empty()) {
      if (typeid(map<string, boost::any>) == m["DailyWriteRequestDayGrowthRatio"].type()) {
        GetDoctorHBaseRegionServerResponseBodyDataMetricsDailyWriteRequestDayGrowthRatio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DailyWriteRequestDayGrowthRatio"]));
        dailyWriteRequestDayGrowthRatio = make_shared<GetDoctorHBaseRegionServerResponseBodyDataMetricsDailyWriteRequestDayGrowthRatio>(model1);
      }
    }
    if (m.find("RegionCount") != m.end() && !m["RegionCount"].empty()) {
      if (typeid(map<string, boost::any>) == m["RegionCount"].type()) {
        GetDoctorHBaseRegionServerResponseBodyDataMetricsRegionCount model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RegionCount"]));
        regionCount = make_shared<GetDoctorHBaseRegionServerResponseBodyDataMetricsRegionCount>(model1);
      }
    }
    if (m.find("TotalReadRequest") != m.end() && !m["TotalReadRequest"].empty()) {
      if (typeid(map<string, boost::any>) == m["TotalReadRequest"].type()) {
        GetDoctorHBaseRegionServerResponseBodyDataMetricsTotalReadRequest model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TotalReadRequest"]));
        totalReadRequest = make_shared<GetDoctorHBaseRegionServerResponseBodyDataMetricsTotalReadRequest>(model1);
      }
    }
    if (m.find("TotalRequest") != m.end() && !m["TotalRequest"].empty()) {
      if (typeid(map<string, boost::any>) == m["TotalRequest"].type()) {
        GetDoctorHBaseRegionServerResponseBodyDataMetricsTotalRequest model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TotalRequest"]));
        totalRequest = make_shared<GetDoctorHBaseRegionServerResponseBodyDataMetricsTotalRequest>(model1);
      }
    }
    if (m.find("TotalWriteRequest") != m.end() && !m["TotalWriteRequest"].empty()) {
      if (typeid(map<string, boost::any>) == m["TotalWriteRequest"].type()) {
        GetDoctorHBaseRegionServerResponseBodyDataMetricsTotalWriteRequest model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TotalWriteRequest"]));
        totalWriteRequest = make_shared<GetDoctorHBaseRegionServerResponseBodyDataMetricsTotalWriteRequest>(model1);
      }
    }
  }


  virtual ~GetDoctorHBaseRegionServerResponseBodyDataMetrics() = default;
};
class GetDoctorHBaseRegionServerResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<GetDoctorHBaseRegionServerResponseBodyDataMetrics> metrics{};

  GetDoctorHBaseRegionServerResponseBodyData() {}

  explicit GetDoctorHBaseRegionServerResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (metrics) {
      res["Metrics"] = metrics ? boost::any(metrics->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Metrics") != m.end() && !m["Metrics"].empty()) {
      if (typeid(map<string, boost::any>) == m["Metrics"].type()) {
        GetDoctorHBaseRegionServerResponseBodyDataMetrics model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Metrics"]));
        metrics = make_shared<GetDoctorHBaseRegionServerResponseBodyDataMetrics>(model1);
      }
    }
  }


  virtual ~GetDoctorHBaseRegionServerResponseBodyData() = default;
};
class GetDoctorHBaseRegionServerResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetDoctorHBaseRegionServerResponseBodyData> data{};
  shared_ptr<string> requestId{};

  GetDoctorHBaseRegionServerResponseBody() {}

  explicit GetDoctorHBaseRegionServerResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetDoctorHBaseRegionServerResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetDoctorHBaseRegionServerResponseBodyData>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetDoctorHBaseRegionServerResponseBody() = default;
};
class GetDoctorHBaseRegionServerResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetDoctorHBaseRegionServerResponseBody> body{};

  GetDoctorHBaseRegionServerResponse() {}

  explicit GetDoctorHBaseRegionServerResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetDoctorHBaseRegionServerResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetDoctorHBaseRegionServerResponseBody>(model1);
      }
    }
  }


  virtual ~GetDoctorHBaseRegionServerResponse() = default;
};
class GetDoctorHBaseTableRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> dateTime{};
  shared_ptr<string> regionId{};
  shared_ptr<string> tableName{};

  GetDoctorHBaseTableRequest() {}

  explicit GetDoctorHBaseTableRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (dateTime) {
      res["DateTime"] = boost::any(*dateTime);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (tableName) {
      res["TableName"] = boost::any(*tableName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("DateTime") != m.end() && !m["DateTime"].empty()) {
      dateTime = make_shared<string>(boost::any_cast<string>(m["DateTime"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("TableName") != m.end() && !m["TableName"].empty()) {
      tableName = make_shared<string>(boost::any_cast<string>(m["TableName"]));
    }
  }


  virtual ~GetDoctorHBaseTableRequest() = default;
};
class GetDoctorHBaseTableResponseBodyDataAnalysis : public Darabonba::Model {
public:
  shared_ptr<vector<string>> readRequestHotspotRegionList{};
  shared_ptr<string> readRequestUnbalanceSuggestion{};
  shared_ptr<vector<string>> requestHotspotRegionList{};
  shared_ptr<string> requestUnbalanceSuggestion{};
  shared_ptr<long> tableScore{};
  shared_ptr<vector<string>> writeRequestHotspotRegionList{};
  shared_ptr<string> writeRequestUnbalanceSuggestion{};

  GetDoctorHBaseTableResponseBodyDataAnalysis() {}

  explicit GetDoctorHBaseTableResponseBodyDataAnalysis(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (readRequestHotspotRegionList) {
      res["ReadRequestHotspotRegionList"] = boost::any(*readRequestHotspotRegionList);
    }
    if (readRequestUnbalanceSuggestion) {
      res["ReadRequestUnbalanceSuggestion"] = boost::any(*readRequestUnbalanceSuggestion);
    }
    if (requestHotspotRegionList) {
      res["RequestHotspotRegionList"] = boost::any(*requestHotspotRegionList);
    }
    if (requestUnbalanceSuggestion) {
      res["RequestUnbalanceSuggestion"] = boost::any(*requestUnbalanceSuggestion);
    }
    if (tableScore) {
      res["TableScore"] = boost::any(*tableScore);
    }
    if (writeRequestHotspotRegionList) {
      res["WriteRequestHotspotRegionList"] = boost::any(*writeRequestHotspotRegionList);
    }
    if (writeRequestUnbalanceSuggestion) {
      res["WriteRequestUnbalanceSuggestion"] = boost::any(*writeRequestUnbalanceSuggestion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ReadRequestHotspotRegionList") != m.end() && !m["ReadRequestHotspotRegionList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ReadRequestHotspotRegionList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ReadRequestHotspotRegionList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      readRequestHotspotRegionList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ReadRequestUnbalanceSuggestion") != m.end() && !m["ReadRequestUnbalanceSuggestion"].empty()) {
      readRequestUnbalanceSuggestion = make_shared<string>(boost::any_cast<string>(m["ReadRequestUnbalanceSuggestion"]));
    }
    if (m.find("RequestHotspotRegionList") != m.end() && !m["RequestHotspotRegionList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RequestHotspotRegionList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RequestHotspotRegionList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      requestHotspotRegionList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestUnbalanceSuggestion") != m.end() && !m["RequestUnbalanceSuggestion"].empty()) {
      requestUnbalanceSuggestion = make_shared<string>(boost::any_cast<string>(m["RequestUnbalanceSuggestion"]));
    }
    if (m.find("TableScore") != m.end() && !m["TableScore"].empty()) {
      tableScore = make_shared<long>(boost::any_cast<long>(m["TableScore"]));
    }
    if (m.find("WriteRequestHotspotRegionList") != m.end() && !m["WriteRequestHotspotRegionList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["WriteRequestHotspotRegionList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["WriteRequestHotspotRegionList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      writeRequestHotspotRegionList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("WriteRequestUnbalanceSuggestion") != m.end() && !m["WriteRequestUnbalanceSuggestion"].empty()) {
      writeRequestUnbalanceSuggestion = make_shared<string>(boost::any_cast<string>(m["WriteRequestUnbalanceSuggestion"]));
    }
  }


  virtual ~GetDoctorHBaseTableResponseBodyDataAnalysis() = default;
};
class GetDoctorHBaseTableResponseBodyDataMetricsColdAccessDay : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  GetDoctorHBaseTableResponseBodyDataMetricsColdAccessDay() {}

  explicit GetDoctorHBaseTableResponseBodyDataMetricsColdAccessDay(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~GetDoctorHBaseTableResponseBodyDataMetricsColdAccessDay() = default;
};
class GetDoctorHBaseTableResponseBodyDataMetricsColdConfigDay : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  GetDoctorHBaseTableResponseBodyDataMetricsColdConfigDay() {}

  explicit GetDoctorHBaseTableResponseBodyDataMetricsColdConfigDay(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~GetDoctorHBaseTableResponseBodyDataMetricsColdConfigDay() = default;
};
class GetDoctorHBaseTableResponseBodyDataMetricsColdDataSize : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  GetDoctorHBaseTableResponseBodyDataMetricsColdDataSize() {}

  explicit GetDoctorHBaseTableResponseBodyDataMetricsColdDataSize(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~GetDoctorHBaseTableResponseBodyDataMetricsColdDataSize() = default;
};
class GetDoctorHBaseTableResponseBodyDataMetricsDailyReadRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  GetDoctorHBaseTableResponseBodyDataMetricsDailyReadRequest() {}

  explicit GetDoctorHBaseTableResponseBodyDataMetricsDailyReadRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~GetDoctorHBaseTableResponseBodyDataMetricsDailyReadRequest() = default;
};
class GetDoctorHBaseTableResponseBodyDataMetricsDailyReadRequestDayGrowthRatio : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  GetDoctorHBaseTableResponseBodyDataMetricsDailyReadRequestDayGrowthRatio() {}

  explicit GetDoctorHBaseTableResponseBodyDataMetricsDailyReadRequestDayGrowthRatio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~GetDoctorHBaseTableResponseBodyDataMetricsDailyReadRequestDayGrowthRatio() = default;
};
class GetDoctorHBaseTableResponseBodyDataMetricsDailyWriteRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  GetDoctorHBaseTableResponseBodyDataMetricsDailyWriteRequest() {}

  explicit GetDoctorHBaseTableResponseBodyDataMetricsDailyWriteRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~GetDoctorHBaseTableResponseBodyDataMetricsDailyWriteRequest() = default;
};
class GetDoctorHBaseTableResponseBodyDataMetricsDailyWriteRequestDayGrowthRatio : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  GetDoctorHBaseTableResponseBodyDataMetricsDailyWriteRequestDayGrowthRatio() {}

  explicit GetDoctorHBaseTableResponseBodyDataMetricsDailyWriteRequestDayGrowthRatio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~GetDoctorHBaseTableResponseBodyDataMetricsDailyWriteRequestDayGrowthRatio() = default;
};
class GetDoctorHBaseTableResponseBodyDataMetricsFreezeConfigDay : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  GetDoctorHBaseTableResponseBodyDataMetricsFreezeConfigDay() {}

  explicit GetDoctorHBaseTableResponseBodyDataMetricsFreezeConfigDay(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~GetDoctorHBaseTableResponseBodyDataMetricsFreezeConfigDay() = default;
};
class GetDoctorHBaseTableResponseBodyDataMetricsFreezeDataSize : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  GetDoctorHBaseTableResponseBodyDataMetricsFreezeDataSize() {}

  explicit GetDoctorHBaseTableResponseBodyDataMetricsFreezeDataSize(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~GetDoctorHBaseTableResponseBodyDataMetricsFreezeDataSize() = default;
};
class GetDoctorHBaseTableResponseBodyDataMetricsHotDataSize : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  GetDoctorHBaseTableResponseBodyDataMetricsHotDataSize() {}

  explicit GetDoctorHBaseTableResponseBodyDataMetricsHotDataSize(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~GetDoctorHBaseTableResponseBodyDataMetricsHotDataSize() = default;
};
class GetDoctorHBaseTableResponseBodyDataMetricsLocality : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  GetDoctorHBaseTableResponseBodyDataMetricsLocality() {}

  explicit GetDoctorHBaseTableResponseBodyDataMetricsLocality(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~GetDoctorHBaseTableResponseBodyDataMetricsLocality() = default;
};
class GetDoctorHBaseTableResponseBodyDataMetricsReadRequestBalance : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  GetDoctorHBaseTableResponseBodyDataMetricsReadRequestBalance() {}

  explicit GetDoctorHBaseTableResponseBodyDataMetricsReadRequestBalance(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~GetDoctorHBaseTableResponseBodyDataMetricsReadRequestBalance() = default;
};
class GetDoctorHBaseTableResponseBodyDataMetricsRegionBalance : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  GetDoctorHBaseTableResponseBodyDataMetricsRegionBalance() {}

  explicit GetDoctorHBaseTableResponseBodyDataMetricsRegionBalance(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~GetDoctorHBaseTableResponseBodyDataMetricsRegionBalance() = default;
};
class GetDoctorHBaseTableResponseBodyDataMetricsRegionCount : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  GetDoctorHBaseTableResponseBodyDataMetricsRegionCount() {}

  explicit GetDoctorHBaseTableResponseBodyDataMetricsRegionCount(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~GetDoctorHBaseTableResponseBodyDataMetricsRegionCount() = default;
};
class GetDoctorHBaseTableResponseBodyDataMetricsRegionCountDayGrowthRatio : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  GetDoctorHBaseTableResponseBodyDataMetricsRegionCountDayGrowthRatio() {}

  explicit GetDoctorHBaseTableResponseBodyDataMetricsRegionCountDayGrowthRatio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~GetDoctorHBaseTableResponseBodyDataMetricsRegionCountDayGrowthRatio() = default;
};
class GetDoctorHBaseTableResponseBodyDataMetricsRegionServerCount : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  GetDoctorHBaseTableResponseBodyDataMetricsRegionServerCount() {}

  explicit GetDoctorHBaseTableResponseBodyDataMetricsRegionServerCount(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~GetDoctorHBaseTableResponseBodyDataMetricsRegionServerCount() = default;
};
class GetDoctorHBaseTableResponseBodyDataMetricsRequestBalance : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  GetDoctorHBaseTableResponseBodyDataMetricsRequestBalance() {}

  explicit GetDoctorHBaseTableResponseBodyDataMetricsRequestBalance(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~GetDoctorHBaseTableResponseBodyDataMetricsRequestBalance() = default;
};
class GetDoctorHBaseTableResponseBodyDataMetricsStoreFileCount : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  GetDoctorHBaseTableResponseBodyDataMetricsStoreFileCount() {}

  explicit GetDoctorHBaseTableResponseBodyDataMetricsStoreFileCount(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~GetDoctorHBaseTableResponseBodyDataMetricsStoreFileCount() = default;
};
class GetDoctorHBaseTableResponseBodyDataMetricsStoreFileCountDayGrowthRatio : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  GetDoctorHBaseTableResponseBodyDataMetricsStoreFileCountDayGrowthRatio() {}

  explicit GetDoctorHBaseTableResponseBodyDataMetricsStoreFileCountDayGrowthRatio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~GetDoctorHBaseTableResponseBodyDataMetricsStoreFileCountDayGrowthRatio() = default;
};
class GetDoctorHBaseTableResponseBodyDataMetricsTableSize : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  GetDoctorHBaseTableResponseBodyDataMetricsTableSize() {}

  explicit GetDoctorHBaseTableResponseBodyDataMetricsTableSize(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~GetDoctorHBaseTableResponseBodyDataMetricsTableSize() = default;
};
class GetDoctorHBaseTableResponseBodyDataMetricsTableSizeDayGrowthRatio : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  GetDoctorHBaseTableResponseBodyDataMetricsTableSizeDayGrowthRatio() {}

  explicit GetDoctorHBaseTableResponseBodyDataMetricsTableSizeDayGrowthRatio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~GetDoctorHBaseTableResponseBodyDataMetricsTableSizeDayGrowthRatio() = default;
};
class GetDoctorHBaseTableResponseBodyDataMetricsWarmConfigDay : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  GetDoctorHBaseTableResponseBodyDataMetricsWarmConfigDay() {}

  explicit GetDoctorHBaseTableResponseBodyDataMetricsWarmConfigDay(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~GetDoctorHBaseTableResponseBodyDataMetricsWarmConfigDay() = default;
};
class GetDoctorHBaseTableResponseBodyDataMetricsWarmDataSize : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  GetDoctorHBaseTableResponseBodyDataMetricsWarmDataSize() {}

  explicit GetDoctorHBaseTableResponseBodyDataMetricsWarmDataSize(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~GetDoctorHBaseTableResponseBodyDataMetricsWarmDataSize() = default;
};
class GetDoctorHBaseTableResponseBodyDataMetricsWriteRequestBalance : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  GetDoctorHBaseTableResponseBodyDataMetricsWriteRequestBalance() {}

  explicit GetDoctorHBaseTableResponseBodyDataMetricsWriteRequestBalance(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~GetDoctorHBaseTableResponseBodyDataMetricsWriteRequestBalance() = default;
};
class GetDoctorHBaseTableResponseBodyDataMetrics : public Darabonba::Model {
public:
  shared_ptr<GetDoctorHBaseTableResponseBodyDataMetricsColdAccessDay> coldAccessDay{};
  shared_ptr<GetDoctorHBaseTableResponseBodyDataMetricsColdConfigDay> coldConfigDay{};
  shared_ptr<GetDoctorHBaseTableResponseBodyDataMetricsColdDataSize> coldDataSize{};
  shared_ptr<GetDoctorHBaseTableResponseBodyDataMetricsDailyReadRequest> dailyReadRequest{};
  shared_ptr<GetDoctorHBaseTableResponseBodyDataMetricsDailyReadRequestDayGrowthRatio> dailyReadRequestDayGrowthRatio{};
  shared_ptr<GetDoctorHBaseTableResponseBodyDataMetricsDailyWriteRequest> dailyWriteRequest{};
  shared_ptr<GetDoctorHBaseTableResponseBodyDataMetricsDailyWriteRequestDayGrowthRatio> dailyWriteRequestDayGrowthRatio{};
  shared_ptr<GetDoctorHBaseTableResponseBodyDataMetricsFreezeConfigDay> freezeConfigDay{};
  shared_ptr<GetDoctorHBaseTableResponseBodyDataMetricsFreezeDataSize> freezeDataSize{};
  shared_ptr<GetDoctorHBaseTableResponseBodyDataMetricsHotDataSize> hotDataSize{};
  shared_ptr<GetDoctorHBaseTableResponseBodyDataMetricsLocality> locality{};
  shared_ptr<GetDoctorHBaseTableResponseBodyDataMetricsReadRequestBalance> readRequestBalance{};
  shared_ptr<GetDoctorHBaseTableResponseBodyDataMetricsRegionBalance> regionBalance{};
  shared_ptr<GetDoctorHBaseTableResponseBodyDataMetricsRegionCount> regionCount{};
  shared_ptr<GetDoctorHBaseTableResponseBodyDataMetricsRegionCountDayGrowthRatio> regionCountDayGrowthRatio{};
  shared_ptr<GetDoctorHBaseTableResponseBodyDataMetricsRegionServerCount> regionServerCount{};
  shared_ptr<GetDoctorHBaseTableResponseBodyDataMetricsRequestBalance> requestBalance{};
  shared_ptr<GetDoctorHBaseTableResponseBodyDataMetricsStoreFileCount> storeFileCount{};
  shared_ptr<GetDoctorHBaseTableResponseBodyDataMetricsStoreFileCountDayGrowthRatio> storeFileCountDayGrowthRatio{};
  shared_ptr<GetDoctorHBaseTableResponseBodyDataMetricsTableSize> tableSize{};
  shared_ptr<GetDoctorHBaseTableResponseBodyDataMetricsTableSizeDayGrowthRatio> tableSizeDayGrowthRatio{};
  shared_ptr<GetDoctorHBaseTableResponseBodyDataMetricsWarmConfigDay> warmConfigDay{};
  shared_ptr<GetDoctorHBaseTableResponseBodyDataMetricsWarmDataSize> warmDataSize{};
  shared_ptr<GetDoctorHBaseTableResponseBodyDataMetricsWriteRequestBalance> writeRequestBalance{};

  GetDoctorHBaseTableResponseBodyDataMetrics() {}

  explicit GetDoctorHBaseTableResponseBodyDataMetrics(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (coldAccessDay) {
      res["ColdAccessDay"] = coldAccessDay ? boost::any(coldAccessDay->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (coldConfigDay) {
      res["ColdConfigDay"] = coldConfigDay ? boost::any(coldConfigDay->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (coldDataSize) {
      res["ColdDataSize"] = coldDataSize ? boost::any(coldDataSize->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (dailyReadRequest) {
      res["DailyReadRequest"] = dailyReadRequest ? boost::any(dailyReadRequest->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (dailyReadRequestDayGrowthRatio) {
      res["DailyReadRequestDayGrowthRatio"] = dailyReadRequestDayGrowthRatio ? boost::any(dailyReadRequestDayGrowthRatio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (dailyWriteRequest) {
      res["DailyWriteRequest"] = dailyWriteRequest ? boost::any(dailyWriteRequest->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (dailyWriteRequestDayGrowthRatio) {
      res["DailyWriteRequestDayGrowthRatio"] = dailyWriteRequestDayGrowthRatio ? boost::any(dailyWriteRequestDayGrowthRatio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (freezeConfigDay) {
      res["FreezeConfigDay"] = freezeConfigDay ? boost::any(freezeConfigDay->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (freezeDataSize) {
      res["FreezeDataSize"] = freezeDataSize ? boost::any(freezeDataSize->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (hotDataSize) {
      res["HotDataSize"] = hotDataSize ? boost::any(hotDataSize->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (locality) {
      res["Locality"] = locality ? boost::any(locality->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (readRequestBalance) {
      res["ReadRequestBalance"] = readRequestBalance ? boost::any(readRequestBalance->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (regionBalance) {
      res["RegionBalance"] = regionBalance ? boost::any(regionBalance->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (regionCount) {
      res["RegionCount"] = regionCount ? boost::any(regionCount->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (regionCountDayGrowthRatio) {
      res["RegionCountDayGrowthRatio"] = regionCountDayGrowthRatio ? boost::any(regionCountDayGrowthRatio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (regionServerCount) {
      res["RegionServerCount"] = regionServerCount ? boost::any(regionServerCount->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestBalance) {
      res["RequestBalance"] = requestBalance ? boost::any(requestBalance->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (storeFileCount) {
      res["StoreFileCount"] = storeFileCount ? boost::any(storeFileCount->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (storeFileCountDayGrowthRatio) {
      res["StoreFileCountDayGrowthRatio"] = storeFileCountDayGrowthRatio ? boost::any(storeFileCountDayGrowthRatio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tableSize) {
      res["TableSize"] = tableSize ? boost::any(tableSize->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tableSizeDayGrowthRatio) {
      res["TableSizeDayGrowthRatio"] = tableSizeDayGrowthRatio ? boost::any(tableSizeDayGrowthRatio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (warmConfigDay) {
      res["WarmConfigDay"] = warmConfigDay ? boost::any(warmConfigDay->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (warmDataSize) {
      res["WarmDataSize"] = warmDataSize ? boost::any(warmDataSize->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (writeRequestBalance) {
      res["WriteRequestBalance"] = writeRequestBalance ? boost::any(writeRequestBalance->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ColdAccessDay") != m.end() && !m["ColdAccessDay"].empty()) {
      if (typeid(map<string, boost::any>) == m["ColdAccessDay"].type()) {
        GetDoctorHBaseTableResponseBodyDataMetricsColdAccessDay model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ColdAccessDay"]));
        coldAccessDay = make_shared<GetDoctorHBaseTableResponseBodyDataMetricsColdAccessDay>(model1);
      }
    }
    if (m.find("ColdConfigDay") != m.end() && !m["ColdConfigDay"].empty()) {
      if (typeid(map<string, boost::any>) == m["ColdConfigDay"].type()) {
        GetDoctorHBaseTableResponseBodyDataMetricsColdConfigDay model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ColdConfigDay"]));
        coldConfigDay = make_shared<GetDoctorHBaseTableResponseBodyDataMetricsColdConfigDay>(model1);
      }
    }
    if (m.find("ColdDataSize") != m.end() && !m["ColdDataSize"].empty()) {
      if (typeid(map<string, boost::any>) == m["ColdDataSize"].type()) {
        GetDoctorHBaseTableResponseBodyDataMetricsColdDataSize model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ColdDataSize"]));
        coldDataSize = make_shared<GetDoctorHBaseTableResponseBodyDataMetricsColdDataSize>(model1);
      }
    }
    if (m.find("DailyReadRequest") != m.end() && !m["DailyReadRequest"].empty()) {
      if (typeid(map<string, boost::any>) == m["DailyReadRequest"].type()) {
        GetDoctorHBaseTableResponseBodyDataMetricsDailyReadRequest model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DailyReadRequest"]));
        dailyReadRequest = make_shared<GetDoctorHBaseTableResponseBodyDataMetricsDailyReadRequest>(model1);
      }
    }
    if (m.find("DailyReadRequestDayGrowthRatio") != m.end() && !m["DailyReadRequestDayGrowthRatio"].empty()) {
      if (typeid(map<string, boost::any>) == m["DailyReadRequestDayGrowthRatio"].type()) {
        GetDoctorHBaseTableResponseBodyDataMetricsDailyReadRequestDayGrowthRatio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DailyReadRequestDayGrowthRatio"]));
        dailyReadRequestDayGrowthRatio = make_shared<GetDoctorHBaseTableResponseBodyDataMetricsDailyReadRequestDayGrowthRatio>(model1);
      }
    }
    if (m.find("DailyWriteRequest") != m.end() && !m["DailyWriteRequest"].empty()) {
      if (typeid(map<string, boost::any>) == m["DailyWriteRequest"].type()) {
        GetDoctorHBaseTableResponseBodyDataMetricsDailyWriteRequest model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DailyWriteRequest"]));
        dailyWriteRequest = make_shared<GetDoctorHBaseTableResponseBodyDataMetricsDailyWriteRequest>(model1);
      }
    }
    if (m.find("DailyWriteRequestDayGrowthRatio") != m.end() && !m["DailyWriteRequestDayGrowthRatio"].empty()) {
      if (typeid(map<string, boost::any>) == m["DailyWriteRequestDayGrowthRatio"].type()) {
        GetDoctorHBaseTableResponseBodyDataMetricsDailyWriteRequestDayGrowthRatio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DailyWriteRequestDayGrowthRatio"]));
        dailyWriteRequestDayGrowthRatio = make_shared<GetDoctorHBaseTableResponseBodyDataMetricsDailyWriteRequestDayGrowthRatio>(model1);
      }
    }
    if (m.find("FreezeConfigDay") != m.end() && !m["FreezeConfigDay"].empty()) {
      if (typeid(map<string, boost::any>) == m["FreezeConfigDay"].type()) {
        GetDoctorHBaseTableResponseBodyDataMetricsFreezeConfigDay model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FreezeConfigDay"]));
        freezeConfigDay = make_shared<GetDoctorHBaseTableResponseBodyDataMetricsFreezeConfigDay>(model1);
      }
    }
    if (m.find("FreezeDataSize") != m.end() && !m["FreezeDataSize"].empty()) {
      if (typeid(map<string, boost::any>) == m["FreezeDataSize"].type()) {
        GetDoctorHBaseTableResponseBodyDataMetricsFreezeDataSize model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FreezeDataSize"]));
        freezeDataSize = make_shared<GetDoctorHBaseTableResponseBodyDataMetricsFreezeDataSize>(model1);
      }
    }
    if (m.find("HotDataSize") != m.end() && !m["HotDataSize"].empty()) {
      if (typeid(map<string, boost::any>) == m["HotDataSize"].type()) {
        GetDoctorHBaseTableResponseBodyDataMetricsHotDataSize model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["HotDataSize"]));
        hotDataSize = make_shared<GetDoctorHBaseTableResponseBodyDataMetricsHotDataSize>(model1);
      }
    }
    if (m.find("Locality") != m.end() && !m["Locality"].empty()) {
      if (typeid(map<string, boost::any>) == m["Locality"].type()) {
        GetDoctorHBaseTableResponseBodyDataMetricsLocality model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Locality"]));
        locality = make_shared<GetDoctorHBaseTableResponseBodyDataMetricsLocality>(model1);
      }
    }
    if (m.find("ReadRequestBalance") != m.end() && !m["ReadRequestBalance"].empty()) {
      if (typeid(map<string, boost::any>) == m["ReadRequestBalance"].type()) {
        GetDoctorHBaseTableResponseBodyDataMetricsReadRequestBalance model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ReadRequestBalance"]));
        readRequestBalance = make_shared<GetDoctorHBaseTableResponseBodyDataMetricsReadRequestBalance>(model1);
      }
    }
    if (m.find("RegionBalance") != m.end() && !m["RegionBalance"].empty()) {
      if (typeid(map<string, boost::any>) == m["RegionBalance"].type()) {
        GetDoctorHBaseTableResponseBodyDataMetricsRegionBalance model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RegionBalance"]));
        regionBalance = make_shared<GetDoctorHBaseTableResponseBodyDataMetricsRegionBalance>(model1);
      }
    }
    if (m.find("RegionCount") != m.end() && !m["RegionCount"].empty()) {
      if (typeid(map<string, boost::any>) == m["RegionCount"].type()) {
        GetDoctorHBaseTableResponseBodyDataMetricsRegionCount model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RegionCount"]));
        regionCount = make_shared<GetDoctorHBaseTableResponseBodyDataMetricsRegionCount>(model1);
      }
    }
    if (m.find("RegionCountDayGrowthRatio") != m.end() && !m["RegionCountDayGrowthRatio"].empty()) {
      if (typeid(map<string, boost::any>) == m["RegionCountDayGrowthRatio"].type()) {
        GetDoctorHBaseTableResponseBodyDataMetricsRegionCountDayGrowthRatio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RegionCountDayGrowthRatio"]));
        regionCountDayGrowthRatio = make_shared<GetDoctorHBaseTableResponseBodyDataMetricsRegionCountDayGrowthRatio>(model1);
      }
    }
    if (m.find("RegionServerCount") != m.end() && !m["RegionServerCount"].empty()) {
      if (typeid(map<string, boost::any>) == m["RegionServerCount"].type()) {
        GetDoctorHBaseTableResponseBodyDataMetricsRegionServerCount model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RegionServerCount"]));
        regionServerCount = make_shared<GetDoctorHBaseTableResponseBodyDataMetricsRegionServerCount>(model1);
      }
    }
    if (m.find("RequestBalance") != m.end() && !m["RequestBalance"].empty()) {
      if (typeid(map<string, boost::any>) == m["RequestBalance"].type()) {
        GetDoctorHBaseTableResponseBodyDataMetricsRequestBalance model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RequestBalance"]));
        requestBalance = make_shared<GetDoctorHBaseTableResponseBodyDataMetricsRequestBalance>(model1);
      }
    }
    if (m.find("StoreFileCount") != m.end() && !m["StoreFileCount"].empty()) {
      if (typeid(map<string, boost::any>) == m["StoreFileCount"].type()) {
        GetDoctorHBaseTableResponseBodyDataMetricsStoreFileCount model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["StoreFileCount"]));
        storeFileCount = make_shared<GetDoctorHBaseTableResponseBodyDataMetricsStoreFileCount>(model1);
      }
    }
    if (m.find("StoreFileCountDayGrowthRatio") != m.end() && !m["StoreFileCountDayGrowthRatio"].empty()) {
      if (typeid(map<string, boost::any>) == m["StoreFileCountDayGrowthRatio"].type()) {
        GetDoctorHBaseTableResponseBodyDataMetricsStoreFileCountDayGrowthRatio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["StoreFileCountDayGrowthRatio"]));
        storeFileCountDayGrowthRatio = make_shared<GetDoctorHBaseTableResponseBodyDataMetricsStoreFileCountDayGrowthRatio>(model1);
      }
    }
    if (m.find("TableSize") != m.end() && !m["TableSize"].empty()) {
      if (typeid(map<string, boost::any>) == m["TableSize"].type()) {
        GetDoctorHBaseTableResponseBodyDataMetricsTableSize model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TableSize"]));
        tableSize = make_shared<GetDoctorHBaseTableResponseBodyDataMetricsTableSize>(model1);
      }
    }
    if (m.find("TableSizeDayGrowthRatio") != m.end() && !m["TableSizeDayGrowthRatio"].empty()) {
      if (typeid(map<string, boost::any>) == m["TableSizeDayGrowthRatio"].type()) {
        GetDoctorHBaseTableResponseBodyDataMetricsTableSizeDayGrowthRatio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TableSizeDayGrowthRatio"]));
        tableSizeDayGrowthRatio = make_shared<GetDoctorHBaseTableResponseBodyDataMetricsTableSizeDayGrowthRatio>(model1);
      }
    }
    if (m.find("WarmConfigDay") != m.end() && !m["WarmConfigDay"].empty()) {
      if (typeid(map<string, boost::any>) == m["WarmConfigDay"].type()) {
        GetDoctorHBaseTableResponseBodyDataMetricsWarmConfigDay model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["WarmConfigDay"]));
        warmConfigDay = make_shared<GetDoctorHBaseTableResponseBodyDataMetricsWarmConfigDay>(model1);
      }
    }
    if (m.find("WarmDataSize") != m.end() && !m["WarmDataSize"].empty()) {
      if (typeid(map<string, boost::any>) == m["WarmDataSize"].type()) {
        GetDoctorHBaseTableResponseBodyDataMetricsWarmDataSize model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["WarmDataSize"]));
        warmDataSize = make_shared<GetDoctorHBaseTableResponseBodyDataMetricsWarmDataSize>(model1);
      }
    }
    if (m.find("WriteRequestBalance") != m.end() && !m["WriteRequestBalance"].empty()) {
      if (typeid(map<string, boost::any>) == m["WriteRequestBalance"].type()) {
        GetDoctorHBaseTableResponseBodyDataMetricsWriteRequestBalance model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["WriteRequestBalance"]));
        writeRequestBalance = make_shared<GetDoctorHBaseTableResponseBodyDataMetricsWriteRequestBalance>(model1);
      }
    }
  }


  virtual ~GetDoctorHBaseTableResponseBodyDataMetrics() = default;
};
class GetDoctorHBaseTableResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<GetDoctorHBaseTableResponseBodyDataAnalysis> analysis{};
  shared_ptr<GetDoctorHBaseTableResponseBodyDataMetrics> metrics{};

  GetDoctorHBaseTableResponseBodyData() {}

  explicit GetDoctorHBaseTableResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (analysis) {
      res["Analysis"] = analysis ? boost::any(analysis->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (metrics) {
      res["Metrics"] = metrics ? boost::any(metrics->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Analysis") != m.end() && !m["Analysis"].empty()) {
      if (typeid(map<string, boost::any>) == m["Analysis"].type()) {
        GetDoctorHBaseTableResponseBodyDataAnalysis model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Analysis"]));
        analysis = make_shared<GetDoctorHBaseTableResponseBodyDataAnalysis>(model1);
      }
    }
    if (m.find("Metrics") != m.end() && !m["Metrics"].empty()) {
      if (typeid(map<string, boost::any>) == m["Metrics"].type()) {
        GetDoctorHBaseTableResponseBodyDataMetrics model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Metrics"]));
        metrics = make_shared<GetDoctorHBaseTableResponseBodyDataMetrics>(model1);
      }
    }
  }


  virtual ~GetDoctorHBaseTableResponseBodyData() = default;
};
class GetDoctorHBaseTableResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetDoctorHBaseTableResponseBodyData> data{};
  shared_ptr<string> requestId{};

  GetDoctorHBaseTableResponseBody() {}

  explicit GetDoctorHBaseTableResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetDoctorHBaseTableResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetDoctorHBaseTableResponseBodyData>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetDoctorHBaseTableResponseBody() = default;
};
class GetDoctorHBaseTableResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetDoctorHBaseTableResponseBody> body{};

  GetDoctorHBaseTableResponse() {}

  explicit GetDoctorHBaseTableResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetDoctorHBaseTableResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetDoctorHBaseTableResponseBody>(model1);
      }
    }
  }


  virtual ~GetDoctorHBaseTableResponse() = default;
};
class GetDoctorHDFSClusterRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> dateTime{};
  shared_ptr<string> regionId{};

  GetDoctorHDFSClusterRequest() {}

  explicit GetDoctorHDFSClusterRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (dateTime) {
      res["DateTime"] = boost::any(*dateTime);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("DateTime") != m.end() && !m["DateTime"].empty()) {
      dateTime = make_shared<string>(boost::any_cast<string>(m["DateTime"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~GetDoctorHDFSClusterRequest() = default;
};
class GetDoctorHDFSClusterResponseBodyDataAnalysis : public Darabonba::Model {
public:
  shared_ptr<long> hdfsScore{};

  GetDoctorHDFSClusterResponseBodyDataAnalysis() {}

  explicit GetDoctorHDFSClusterResponseBodyDataAnalysis(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hdfsScore) {
      res["HdfsScore"] = boost::any(*hdfsScore);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HdfsScore") != m.end() && !m["HdfsScore"].empty()) {
      hdfsScore = make_shared<long>(boost::any_cast<long>(m["HdfsScore"]));
    }
  }


  virtual ~GetDoctorHDFSClusterResponseBodyDataAnalysis() = default;
};
class GetDoctorHDFSClusterResponseBodyDataMetricsColdDataDayGrowthSize : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  GetDoctorHDFSClusterResponseBodyDataMetricsColdDataDayGrowthSize() {}

  explicit GetDoctorHDFSClusterResponseBodyDataMetricsColdDataDayGrowthSize(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~GetDoctorHDFSClusterResponseBodyDataMetricsColdDataDayGrowthSize() = default;
};
class GetDoctorHDFSClusterResponseBodyDataMetricsColdDataRatio : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  GetDoctorHDFSClusterResponseBodyDataMetricsColdDataRatio() {}

  explicit GetDoctorHDFSClusterResponseBodyDataMetricsColdDataRatio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~GetDoctorHDFSClusterResponseBodyDataMetricsColdDataRatio() = default;
};
class GetDoctorHDFSClusterResponseBodyDataMetricsColdDataSize : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  GetDoctorHDFSClusterResponseBodyDataMetricsColdDataSize() {}

  explicit GetDoctorHDFSClusterResponseBodyDataMetricsColdDataSize(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~GetDoctorHDFSClusterResponseBodyDataMetricsColdDataSize() = default;
};
class GetDoctorHDFSClusterResponseBodyDataMetricsColdDataSizeDayGrowthRatio : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  GetDoctorHDFSClusterResponseBodyDataMetricsColdDataSizeDayGrowthRatio() {}

  explicit GetDoctorHDFSClusterResponseBodyDataMetricsColdDataSizeDayGrowthRatio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~GetDoctorHDFSClusterResponseBodyDataMetricsColdDataSizeDayGrowthRatio() = default;
};
class GetDoctorHDFSClusterResponseBodyDataMetricsEmptyFileCount : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  GetDoctorHDFSClusterResponseBodyDataMetricsEmptyFileCount() {}

  explicit GetDoctorHDFSClusterResponseBodyDataMetricsEmptyFileCount(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~GetDoctorHDFSClusterResponseBodyDataMetricsEmptyFileCount() = default;
};
class GetDoctorHDFSClusterResponseBodyDataMetricsEmptyFileCountDayGrowthRatio : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  GetDoctorHDFSClusterResponseBodyDataMetricsEmptyFileCountDayGrowthRatio() {}

  explicit GetDoctorHDFSClusterResponseBodyDataMetricsEmptyFileCountDayGrowthRatio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~GetDoctorHDFSClusterResponseBodyDataMetricsEmptyFileCountDayGrowthRatio() = default;
};
class GetDoctorHDFSClusterResponseBodyDataMetricsEmptyFileDayGrowthCount : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  GetDoctorHDFSClusterResponseBodyDataMetricsEmptyFileDayGrowthCount() {}

  explicit GetDoctorHDFSClusterResponseBodyDataMetricsEmptyFileDayGrowthCount(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~GetDoctorHDFSClusterResponseBodyDataMetricsEmptyFileDayGrowthCount() = default;
};
class GetDoctorHDFSClusterResponseBodyDataMetricsEmptyFileRatio : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  GetDoctorHDFSClusterResponseBodyDataMetricsEmptyFileRatio() {}

  explicit GetDoctorHDFSClusterResponseBodyDataMetricsEmptyFileRatio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~GetDoctorHDFSClusterResponseBodyDataMetricsEmptyFileRatio() = default;
};
class GetDoctorHDFSClusterResponseBodyDataMetricsFreezeDataDayGrowthSize : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  GetDoctorHDFSClusterResponseBodyDataMetricsFreezeDataDayGrowthSize() {}

  explicit GetDoctorHDFSClusterResponseBodyDataMetricsFreezeDataDayGrowthSize(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~GetDoctorHDFSClusterResponseBodyDataMetricsFreezeDataDayGrowthSize() = default;
};
class GetDoctorHDFSClusterResponseBodyDataMetricsFreezeDataRatio : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  GetDoctorHDFSClusterResponseBodyDataMetricsFreezeDataRatio() {}

  explicit GetDoctorHDFSClusterResponseBodyDataMetricsFreezeDataRatio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~GetDoctorHDFSClusterResponseBodyDataMetricsFreezeDataRatio() = default;
};
class GetDoctorHDFSClusterResponseBodyDataMetricsFreezeDataSize : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  GetDoctorHDFSClusterResponseBodyDataMetricsFreezeDataSize() {}

  explicit GetDoctorHDFSClusterResponseBodyDataMetricsFreezeDataSize(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~GetDoctorHDFSClusterResponseBodyDataMetricsFreezeDataSize() = default;
};
class GetDoctorHDFSClusterResponseBodyDataMetricsFreezeDataSizeDayGrowthRatio : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  GetDoctorHDFSClusterResponseBodyDataMetricsFreezeDataSizeDayGrowthRatio() {}

  explicit GetDoctorHDFSClusterResponseBodyDataMetricsFreezeDataSizeDayGrowthRatio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~GetDoctorHDFSClusterResponseBodyDataMetricsFreezeDataSizeDayGrowthRatio() = default;
};
class GetDoctorHDFSClusterResponseBodyDataMetricsHotDataDayGrowthSize : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  GetDoctorHDFSClusterResponseBodyDataMetricsHotDataDayGrowthSize() {}

  explicit GetDoctorHDFSClusterResponseBodyDataMetricsHotDataDayGrowthSize(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~GetDoctorHDFSClusterResponseBodyDataMetricsHotDataDayGrowthSize() = default;
};
class GetDoctorHDFSClusterResponseBodyDataMetricsHotDataRatio : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  GetDoctorHDFSClusterResponseBodyDataMetricsHotDataRatio() {}

  explicit GetDoctorHDFSClusterResponseBodyDataMetricsHotDataRatio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~GetDoctorHDFSClusterResponseBodyDataMetricsHotDataRatio() = default;
};
class GetDoctorHDFSClusterResponseBodyDataMetricsHotDataSize : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  GetDoctorHDFSClusterResponseBodyDataMetricsHotDataSize() {}

  explicit GetDoctorHDFSClusterResponseBodyDataMetricsHotDataSize(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~GetDoctorHDFSClusterResponseBodyDataMetricsHotDataSize() = default;
};
class GetDoctorHDFSClusterResponseBodyDataMetricsHotDataSizeDayGrowthRatio : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  GetDoctorHDFSClusterResponseBodyDataMetricsHotDataSizeDayGrowthRatio() {}

  explicit GetDoctorHDFSClusterResponseBodyDataMetricsHotDataSizeDayGrowthRatio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~GetDoctorHDFSClusterResponseBodyDataMetricsHotDataSizeDayGrowthRatio() = default;
};
class GetDoctorHDFSClusterResponseBodyDataMetricsLargeFileCount : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  GetDoctorHDFSClusterResponseBodyDataMetricsLargeFileCount() {}

  explicit GetDoctorHDFSClusterResponseBodyDataMetricsLargeFileCount(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~GetDoctorHDFSClusterResponseBodyDataMetricsLargeFileCount() = default;
};
class GetDoctorHDFSClusterResponseBodyDataMetricsLargeFileCountDayGrowthRatio : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  GetDoctorHDFSClusterResponseBodyDataMetricsLargeFileCountDayGrowthRatio() {}

  explicit GetDoctorHDFSClusterResponseBodyDataMetricsLargeFileCountDayGrowthRatio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~GetDoctorHDFSClusterResponseBodyDataMetricsLargeFileCountDayGrowthRatio() = default;
};
class GetDoctorHDFSClusterResponseBodyDataMetricsLargeFileDayGrowthCount : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  GetDoctorHDFSClusterResponseBodyDataMetricsLargeFileDayGrowthCount() {}

  explicit GetDoctorHDFSClusterResponseBodyDataMetricsLargeFileDayGrowthCount(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~GetDoctorHDFSClusterResponseBodyDataMetricsLargeFileDayGrowthCount() = default;
};
class GetDoctorHDFSClusterResponseBodyDataMetricsLargeFileRatio : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  GetDoctorHDFSClusterResponseBodyDataMetricsLargeFileRatio() {}

  explicit GetDoctorHDFSClusterResponseBodyDataMetricsLargeFileRatio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~GetDoctorHDFSClusterResponseBodyDataMetricsLargeFileRatio() = default;
};
class GetDoctorHDFSClusterResponseBodyDataMetricsMediumFileCount : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  GetDoctorHDFSClusterResponseBodyDataMetricsMediumFileCount() {}

  explicit GetDoctorHDFSClusterResponseBodyDataMetricsMediumFileCount(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~GetDoctorHDFSClusterResponseBodyDataMetricsMediumFileCount() = default;
};
class GetDoctorHDFSClusterResponseBodyDataMetricsMediumFileCountDayGrowthRatio : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  GetDoctorHDFSClusterResponseBodyDataMetricsMediumFileCountDayGrowthRatio() {}

  explicit GetDoctorHDFSClusterResponseBodyDataMetricsMediumFileCountDayGrowthRatio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~GetDoctorHDFSClusterResponseBodyDataMetricsMediumFileCountDayGrowthRatio() = default;
};
class GetDoctorHDFSClusterResponseBodyDataMetricsMediumFileDayGrowthCount : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  GetDoctorHDFSClusterResponseBodyDataMetricsMediumFileDayGrowthCount() {}

  explicit GetDoctorHDFSClusterResponseBodyDataMetricsMediumFileDayGrowthCount(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~GetDoctorHDFSClusterResponseBodyDataMetricsMediumFileDayGrowthCount() = default;
};
class GetDoctorHDFSClusterResponseBodyDataMetricsMediumFileRatio : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  GetDoctorHDFSClusterResponseBodyDataMetricsMediumFileRatio() {}

  explicit GetDoctorHDFSClusterResponseBodyDataMetricsMediumFileRatio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~GetDoctorHDFSClusterResponseBodyDataMetricsMediumFileRatio() = default;
};
class GetDoctorHDFSClusterResponseBodyDataMetricsSmallFileCount : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  GetDoctorHDFSClusterResponseBodyDataMetricsSmallFileCount() {}

  explicit GetDoctorHDFSClusterResponseBodyDataMetricsSmallFileCount(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~GetDoctorHDFSClusterResponseBodyDataMetricsSmallFileCount() = default;
};
class GetDoctorHDFSClusterResponseBodyDataMetricsSmallFileCountDayGrowthRatio : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  GetDoctorHDFSClusterResponseBodyDataMetricsSmallFileCountDayGrowthRatio() {}

  explicit GetDoctorHDFSClusterResponseBodyDataMetricsSmallFileCountDayGrowthRatio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~GetDoctorHDFSClusterResponseBodyDataMetricsSmallFileCountDayGrowthRatio() = default;
};
class GetDoctorHDFSClusterResponseBodyDataMetricsSmallFileDayGrowthCount : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  GetDoctorHDFSClusterResponseBodyDataMetricsSmallFileDayGrowthCount() {}

  explicit GetDoctorHDFSClusterResponseBodyDataMetricsSmallFileDayGrowthCount(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~GetDoctorHDFSClusterResponseBodyDataMetricsSmallFileDayGrowthCount() = default;
};
class GetDoctorHDFSClusterResponseBodyDataMetricsSmallFileRatio : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  GetDoctorHDFSClusterResponseBodyDataMetricsSmallFileRatio() {}

  explicit GetDoctorHDFSClusterResponseBodyDataMetricsSmallFileRatio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~GetDoctorHDFSClusterResponseBodyDataMetricsSmallFileRatio() = default;
};
class GetDoctorHDFSClusterResponseBodyDataMetricsTinyFileCount : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  GetDoctorHDFSClusterResponseBodyDataMetricsTinyFileCount() {}

  explicit GetDoctorHDFSClusterResponseBodyDataMetricsTinyFileCount(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~GetDoctorHDFSClusterResponseBodyDataMetricsTinyFileCount() = default;
};
class GetDoctorHDFSClusterResponseBodyDataMetricsTinyFileCountDayGrowthRatio : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  GetDoctorHDFSClusterResponseBodyDataMetricsTinyFileCountDayGrowthRatio() {}

  explicit GetDoctorHDFSClusterResponseBodyDataMetricsTinyFileCountDayGrowthRatio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~GetDoctorHDFSClusterResponseBodyDataMetricsTinyFileCountDayGrowthRatio() = default;
};
class GetDoctorHDFSClusterResponseBodyDataMetricsTinyFileDayGrowthCount : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  GetDoctorHDFSClusterResponseBodyDataMetricsTinyFileDayGrowthCount() {}

  explicit GetDoctorHDFSClusterResponseBodyDataMetricsTinyFileDayGrowthCount(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~GetDoctorHDFSClusterResponseBodyDataMetricsTinyFileDayGrowthCount() = default;
};
class GetDoctorHDFSClusterResponseBodyDataMetricsTinyFileRatio : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  GetDoctorHDFSClusterResponseBodyDataMetricsTinyFileRatio() {}

  explicit GetDoctorHDFSClusterResponseBodyDataMetricsTinyFileRatio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~GetDoctorHDFSClusterResponseBodyDataMetricsTinyFileRatio() = default;
};
class GetDoctorHDFSClusterResponseBodyDataMetricsTotalDataDayGrowthSize : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  GetDoctorHDFSClusterResponseBodyDataMetricsTotalDataDayGrowthSize() {}

  explicit GetDoctorHDFSClusterResponseBodyDataMetricsTotalDataDayGrowthSize(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~GetDoctorHDFSClusterResponseBodyDataMetricsTotalDataDayGrowthSize() = default;
};
class GetDoctorHDFSClusterResponseBodyDataMetricsTotalDataSize : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  GetDoctorHDFSClusterResponseBodyDataMetricsTotalDataSize() {}

  explicit GetDoctorHDFSClusterResponseBodyDataMetricsTotalDataSize(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~GetDoctorHDFSClusterResponseBodyDataMetricsTotalDataSize() = default;
};
class GetDoctorHDFSClusterResponseBodyDataMetricsTotalDataSizeDayGrowthRatio : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  GetDoctorHDFSClusterResponseBodyDataMetricsTotalDataSizeDayGrowthRatio() {}

  explicit GetDoctorHDFSClusterResponseBodyDataMetricsTotalDataSizeDayGrowthRatio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~GetDoctorHDFSClusterResponseBodyDataMetricsTotalDataSizeDayGrowthRatio() = default;
};
class GetDoctorHDFSClusterResponseBodyDataMetricsTotalFileCount : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  GetDoctorHDFSClusterResponseBodyDataMetricsTotalFileCount() {}

  explicit GetDoctorHDFSClusterResponseBodyDataMetricsTotalFileCount(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~GetDoctorHDFSClusterResponseBodyDataMetricsTotalFileCount() = default;
};
class GetDoctorHDFSClusterResponseBodyDataMetricsTotalFileCountDayGrowthRatio : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  GetDoctorHDFSClusterResponseBodyDataMetricsTotalFileCountDayGrowthRatio() {}

  explicit GetDoctorHDFSClusterResponseBodyDataMetricsTotalFileCountDayGrowthRatio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~GetDoctorHDFSClusterResponseBodyDataMetricsTotalFileCountDayGrowthRatio() = default;
};
class GetDoctorHDFSClusterResponseBodyDataMetricsTotalFileDayGrowthCount : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  GetDoctorHDFSClusterResponseBodyDataMetricsTotalFileDayGrowthCount() {}

  explicit GetDoctorHDFSClusterResponseBodyDataMetricsTotalFileDayGrowthCount(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~GetDoctorHDFSClusterResponseBodyDataMetricsTotalFileDayGrowthCount() = default;
};
class GetDoctorHDFSClusterResponseBodyDataMetricsWarmDataDayGrowthSize : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  GetDoctorHDFSClusterResponseBodyDataMetricsWarmDataDayGrowthSize() {}

  explicit GetDoctorHDFSClusterResponseBodyDataMetricsWarmDataDayGrowthSize(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~GetDoctorHDFSClusterResponseBodyDataMetricsWarmDataDayGrowthSize() = default;
};
class GetDoctorHDFSClusterResponseBodyDataMetricsWarmDataRatio : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  GetDoctorHDFSClusterResponseBodyDataMetricsWarmDataRatio() {}

  explicit GetDoctorHDFSClusterResponseBodyDataMetricsWarmDataRatio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~GetDoctorHDFSClusterResponseBodyDataMetricsWarmDataRatio() = default;
};
class GetDoctorHDFSClusterResponseBodyDataMetricsWarmDataSize : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  GetDoctorHDFSClusterResponseBodyDataMetricsWarmDataSize() {}

  explicit GetDoctorHDFSClusterResponseBodyDataMetricsWarmDataSize(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~GetDoctorHDFSClusterResponseBodyDataMetricsWarmDataSize() = default;
};
class GetDoctorHDFSClusterResponseBodyDataMetricsWarmDataSizeDayGrowthRatio : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  GetDoctorHDFSClusterResponseBodyDataMetricsWarmDataSizeDayGrowthRatio() {}

  explicit GetDoctorHDFSClusterResponseBodyDataMetricsWarmDataSizeDayGrowthRatio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~GetDoctorHDFSClusterResponseBodyDataMetricsWarmDataSizeDayGrowthRatio() = default;
};
class GetDoctorHDFSClusterResponseBodyDataMetrics : public Darabonba::Model {
public:
  shared_ptr<GetDoctorHDFSClusterResponseBodyDataMetricsColdDataDayGrowthSize> coldDataDayGrowthSize{};
  shared_ptr<GetDoctorHDFSClusterResponseBodyDataMetricsColdDataRatio> coldDataRatio{};
  shared_ptr<GetDoctorHDFSClusterResponseBodyDataMetricsColdDataSize> coldDataSize{};
  shared_ptr<GetDoctorHDFSClusterResponseBodyDataMetricsColdDataSizeDayGrowthRatio> coldDataSizeDayGrowthRatio{};
  shared_ptr<GetDoctorHDFSClusterResponseBodyDataMetricsEmptyFileCount> emptyFileCount{};
  shared_ptr<GetDoctorHDFSClusterResponseBodyDataMetricsEmptyFileCountDayGrowthRatio> emptyFileCountDayGrowthRatio{};
  shared_ptr<GetDoctorHDFSClusterResponseBodyDataMetricsEmptyFileDayGrowthCount> emptyFileDayGrowthCount{};
  shared_ptr<GetDoctorHDFSClusterResponseBodyDataMetricsEmptyFileRatio> emptyFileRatio{};
  shared_ptr<GetDoctorHDFSClusterResponseBodyDataMetricsFreezeDataDayGrowthSize> freezeDataDayGrowthSize{};
  shared_ptr<GetDoctorHDFSClusterResponseBodyDataMetricsFreezeDataRatio> freezeDataRatio{};
  shared_ptr<GetDoctorHDFSClusterResponseBodyDataMetricsFreezeDataSize> freezeDataSize{};
  shared_ptr<GetDoctorHDFSClusterResponseBodyDataMetricsFreezeDataSizeDayGrowthRatio> freezeDataSizeDayGrowthRatio{};
  shared_ptr<GetDoctorHDFSClusterResponseBodyDataMetricsHotDataDayGrowthSize> hotDataDayGrowthSize{};
  shared_ptr<GetDoctorHDFSClusterResponseBodyDataMetricsHotDataRatio> hotDataRatio{};
  shared_ptr<GetDoctorHDFSClusterResponseBodyDataMetricsHotDataSize> hotDataSize{};
  shared_ptr<GetDoctorHDFSClusterResponseBodyDataMetricsHotDataSizeDayGrowthRatio> hotDataSizeDayGrowthRatio{};
  shared_ptr<GetDoctorHDFSClusterResponseBodyDataMetricsLargeFileCount> largeFileCount{};
  shared_ptr<GetDoctorHDFSClusterResponseBodyDataMetricsLargeFileCountDayGrowthRatio> largeFileCountDayGrowthRatio{};
  shared_ptr<GetDoctorHDFSClusterResponseBodyDataMetricsLargeFileDayGrowthCount> largeFileDayGrowthCount{};
  shared_ptr<GetDoctorHDFSClusterResponseBodyDataMetricsLargeFileRatio> largeFileRatio{};
  shared_ptr<GetDoctorHDFSClusterResponseBodyDataMetricsMediumFileCount> mediumFileCount{};
  shared_ptr<GetDoctorHDFSClusterResponseBodyDataMetricsMediumFileCountDayGrowthRatio> mediumFileCountDayGrowthRatio{};
  shared_ptr<GetDoctorHDFSClusterResponseBodyDataMetricsMediumFileDayGrowthCount> mediumFileDayGrowthCount{};
  shared_ptr<GetDoctorHDFSClusterResponseBodyDataMetricsMediumFileRatio> mediumFileRatio{};
  shared_ptr<GetDoctorHDFSClusterResponseBodyDataMetricsSmallFileCount> smallFileCount{};
  shared_ptr<GetDoctorHDFSClusterResponseBodyDataMetricsSmallFileCountDayGrowthRatio> smallFileCountDayGrowthRatio{};
  shared_ptr<GetDoctorHDFSClusterResponseBodyDataMetricsSmallFileDayGrowthCount> smallFileDayGrowthCount{};
  shared_ptr<GetDoctorHDFSClusterResponseBodyDataMetricsSmallFileRatio> smallFileRatio{};
  shared_ptr<GetDoctorHDFSClusterResponseBodyDataMetricsTinyFileCount> tinyFileCount{};
  shared_ptr<GetDoctorHDFSClusterResponseBodyDataMetricsTinyFileCountDayGrowthRatio> tinyFileCountDayGrowthRatio{};
  shared_ptr<GetDoctorHDFSClusterResponseBodyDataMetricsTinyFileDayGrowthCount> tinyFileDayGrowthCount{};
  shared_ptr<GetDoctorHDFSClusterResponseBodyDataMetricsTinyFileRatio> tinyFileRatio{};
  shared_ptr<GetDoctorHDFSClusterResponseBodyDataMetricsTotalDataDayGrowthSize> totalDataDayGrowthSize{};
  shared_ptr<GetDoctorHDFSClusterResponseBodyDataMetricsTotalDataSize> totalDataSize{};
  shared_ptr<GetDoctorHDFSClusterResponseBodyDataMetricsTotalDataSizeDayGrowthRatio> totalDataSizeDayGrowthRatio{};
  shared_ptr<GetDoctorHDFSClusterResponseBodyDataMetricsTotalFileCount> totalFileCount{};
  shared_ptr<GetDoctorHDFSClusterResponseBodyDataMetricsTotalFileCountDayGrowthRatio> totalFileCountDayGrowthRatio{};
  shared_ptr<GetDoctorHDFSClusterResponseBodyDataMetricsTotalFileDayGrowthCount> totalFileDayGrowthCount{};
  shared_ptr<GetDoctorHDFSClusterResponseBodyDataMetricsWarmDataDayGrowthSize> warmDataDayGrowthSize{};
  shared_ptr<GetDoctorHDFSClusterResponseBodyDataMetricsWarmDataRatio> warmDataRatio{};
  shared_ptr<GetDoctorHDFSClusterResponseBodyDataMetricsWarmDataSize> warmDataSize{};
  shared_ptr<GetDoctorHDFSClusterResponseBodyDataMetricsWarmDataSizeDayGrowthRatio> warmDataSizeDayGrowthRatio{};

  GetDoctorHDFSClusterResponseBodyDataMetrics() {}

  explicit GetDoctorHDFSClusterResponseBodyDataMetrics(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (coldDataDayGrowthSize) {
      res["ColdDataDayGrowthSize"] = coldDataDayGrowthSize ? boost::any(coldDataDayGrowthSize->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (coldDataRatio) {
      res["ColdDataRatio"] = coldDataRatio ? boost::any(coldDataRatio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (coldDataSize) {
      res["ColdDataSize"] = coldDataSize ? boost::any(coldDataSize->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (coldDataSizeDayGrowthRatio) {
      res["ColdDataSizeDayGrowthRatio"] = coldDataSizeDayGrowthRatio ? boost::any(coldDataSizeDayGrowthRatio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (emptyFileCount) {
      res["EmptyFileCount"] = emptyFileCount ? boost::any(emptyFileCount->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (emptyFileCountDayGrowthRatio) {
      res["EmptyFileCountDayGrowthRatio"] = emptyFileCountDayGrowthRatio ? boost::any(emptyFileCountDayGrowthRatio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (emptyFileDayGrowthCount) {
      res["EmptyFileDayGrowthCount"] = emptyFileDayGrowthCount ? boost::any(emptyFileDayGrowthCount->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (emptyFileRatio) {
      res["EmptyFileRatio"] = emptyFileRatio ? boost::any(emptyFileRatio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (freezeDataDayGrowthSize) {
      res["FreezeDataDayGrowthSize"] = freezeDataDayGrowthSize ? boost::any(freezeDataDayGrowthSize->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (freezeDataRatio) {
      res["FreezeDataRatio"] = freezeDataRatio ? boost::any(freezeDataRatio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (freezeDataSize) {
      res["FreezeDataSize"] = freezeDataSize ? boost::any(freezeDataSize->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (freezeDataSizeDayGrowthRatio) {
      res["FreezeDataSizeDayGrowthRatio"] = freezeDataSizeDayGrowthRatio ? boost::any(freezeDataSizeDayGrowthRatio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (hotDataDayGrowthSize) {
      res["HotDataDayGrowthSize"] = hotDataDayGrowthSize ? boost::any(hotDataDayGrowthSize->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (hotDataRatio) {
      res["HotDataRatio"] = hotDataRatio ? boost::any(hotDataRatio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (hotDataSize) {
      res["HotDataSize"] = hotDataSize ? boost::any(hotDataSize->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (hotDataSizeDayGrowthRatio) {
      res["HotDataSizeDayGrowthRatio"] = hotDataSizeDayGrowthRatio ? boost::any(hotDataSizeDayGrowthRatio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (largeFileCount) {
      res["LargeFileCount"] = largeFileCount ? boost::any(largeFileCount->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (largeFileCountDayGrowthRatio) {
      res["LargeFileCountDayGrowthRatio"] = largeFileCountDayGrowthRatio ? boost::any(largeFileCountDayGrowthRatio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (largeFileDayGrowthCount) {
      res["LargeFileDayGrowthCount"] = largeFileDayGrowthCount ? boost::any(largeFileDayGrowthCount->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (largeFileRatio) {
      res["LargeFileRatio"] = largeFileRatio ? boost::any(largeFileRatio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (mediumFileCount) {
      res["MediumFileCount"] = mediumFileCount ? boost::any(mediumFileCount->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (mediumFileCountDayGrowthRatio) {
      res["MediumFileCountDayGrowthRatio"] = mediumFileCountDayGrowthRatio ? boost::any(mediumFileCountDayGrowthRatio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (mediumFileDayGrowthCount) {
      res["MediumFileDayGrowthCount"] = mediumFileDayGrowthCount ? boost::any(mediumFileDayGrowthCount->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (mediumFileRatio) {
      res["MediumFileRatio"] = mediumFileRatio ? boost::any(mediumFileRatio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (smallFileCount) {
      res["SmallFileCount"] = smallFileCount ? boost::any(smallFileCount->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (smallFileCountDayGrowthRatio) {
      res["SmallFileCountDayGrowthRatio"] = smallFileCountDayGrowthRatio ? boost::any(smallFileCountDayGrowthRatio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (smallFileDayGrowthCount) {
      res["SmallFileDayGrowthCount"] = smallFileDayGrowthCount ? boost::any(smallFileDayGrowthCount->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (smallFileRatio) {
      res["SmallFileRatio"] = smallFileRatio ? boost::any(smallFileRatio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tinyFileCount) {
      res["TinyFileCount"] = tinyFileCount ? boost::any(tinyFileCount->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tinyFileCountDayGrowthRatio) {
      res["TinyFileCountDayGrowthRatio"] = tinyFileCountDayGrowthRatio ? boost::any(tinyFileCountDayGrowthRatio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tinyFileDayGrowthCount) {
      res["TinyFileDayGrowthCount"] = tinyFileDayGrowthCount ? boost::any(tinyFileDayGrowthCount->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tinyFileRatio) {
      res["TinyFileRatio"] = tinyFileRatio ? boost::any(tinyFileRatio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (totalDataDayGrowthSize) {
      res["TotalDataDayGrowthSize"] = totalDataDayGrowthSize ? boost::any(totalDataDayGrowthSize->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (totalDataSize) {
      res["TotalDataSize"] = totalDataSize ? boost::any(totalDataSize->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (totalDataSizeDayGrowthRatio) {
      res["TotalDataSizeDayGrowthRatio"] = totalDataSizeDayGrowthRatio ? boost::any(totalDataSizeDayGrowthRatio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (totalFileCount) {
      res["TotalFileCount"] = totalFileCount ? boost::any(totalFileCount->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (totalFileCountDayGrowthRatio) {
      res["TotalFileCountDayGrowthRatio"] = totalFileCountDayGrowthRatio ? boost::any(totalFileCountDayGrowthRatio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (totalFileDayGrowthCount) {
      res["TotalFileDayGrowthCount"] = totalFileDayGrowthCount ? boost::any(totalFileDayGrowthCount->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (warmDataDayGrowthSize) {
      res["WarmDataDayGrowthSize"] = warmDataDayGrowthSize ? boost::any(warmDataDayGrowthSize->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (warmDataRatio) {
      res["WarmDataRatio"] = warmDataRatio ? boost::any(warmDataRatio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (warmDataSize) {
      res["WarmDataSize"] = warmDataSize ? boost::any(warmDataSize->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (warmDataSizeDayGrowthRatio) {
      res["WarmDataSizeDayGrowthRatio"] = warmDataSizeDayGrowthRatio ? boost::any(warmDataSizeDayGrowthRatio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ColdDataDayGrowthSize") != m.end() && !m["ColdDataDayGrowthSize"].empty()) {
      if (typeid(map<string, boost::any>) == m["ColdDataDayGrowthSize"].type()) {
        GetDoctorHDFSClusterResponseBodyDataMetricsColdDataDayGrowthSize model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ColdDataDayGrowthSize"]));
        coldDataDayGrowthSize = make_shared<GetDoctorHDFSClusterResponseBodyDataMetricsColdDataDayGrowthSize>(model1);
      }
    }
    if (m.find("ColdDataRatio") != m.end() && !m["ColdDataRatio"].empty()) {
      if (typeid(map<string, boost::any>) == m["ColdDataRatio"].type()) {
        GetDoctorHDFSClusterResponseBodyDataMetricsColdDataRatio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ColdDataRatio"]));
        coldDataRatio = make_shared<GetDoctorHDFSClusterResponseBodyDataMetricsColdDataRatio>(model1);
      }
    }
    if (m.find("ColdDataSize") != m.end() && !m["ColdDataSize"].empty()) {
      if (typeid(map<string, boost::any>) == m["ColdDataSize"].type()) {
        GetDoctorHDFSClusterResponseBodyDataMetricsColdDataSize model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ColdDataSize"]));
        coldDataSize = make_shared<GetDoctorHDFSClusterResponseBodyDataMetricsColdDataSize>(model1);
      }
    }
    if (m.find("ColdDataSizeDayGrowthRatio") != m.end() && !m["ColdDataSizeDayGrowthRatio"].empty()) {
      if (typeid(map<string, boost::any>) == m["ColdDataSizeDayGrowthRatio"].type()) {
        GetDoctorHDFSClusterResponseBodyDataMetricsColdDataSizeDayGrowthRatio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ColdDataSizeDayGrowthRatio"]));
        coldDataSizeDayGrowthRatio = make_shared<GetDoctorHDFSClusterResponseBodyDataMetricsColdDataSizeDayGrowthRatio>(model1);
      }
    }
    if (m.find("EmptyFileCount") != m.end() && !m["EmptyFileCount"].empty()) {
      if (typeid(map<string, boost::any>) == m["EmptyFileCount"].type()) {
        GetDoctorHDFSClusterResponseBodyDataMetricsEmptyFileCount model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EmptyFileCount"]));
        emptyFileCount = make_shared<GetDoctorHDFSClusterResponseBodyDataMetricsEmptyFileCount>(model1);
      }
    }
    if (m.find("EmptyFileCountDayGrowthRatio") != m.end() && !m["EmptyFileCountDayGrowthRatio"].empty()) {
      if (typeid(map<string, boost::any>) == m["EmptyFileCountDayGrowthRatio"].type()) {
        GetDoctorHDFSClusterResponseBodyDataMetricsEmptyFileCountDayGrowthRatio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EmptyFileCountDayGrowthRatio"]));
        emptyFileCountDayGrowthRatio = make_shared<GetDoctorHDFSClusterResponseBodyDataMetricsEmptyFileCountDayGrowthRatio>(model1);
      }
    }
    if (m.find("EmptyFileDayGrowthCount") != m.end() && !m["EmptyFileDayGrowthCount"].empty()) {
      if (typeid(map<string, boost::any>) == m["EmptyFileDayGrowthCount"].type()) {
        GetDoctorHDFSClusterResponseBodyDataMetricsEmptyFileDayGrowthCount model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EmptyFileDayGrowthCount"]));
        emptyFileDayGrowthCount = make_shared<GetDoctorHDFSClusterResponseBodyDataMetricsEmptyFileDayGrowthCount>(model1);
      }
    }
    if (m.find("EmptyFileRatio") != m.end() && !m["EmptyFileRatio"].empty()) {
      if (typeid(map<string, boost::any>) == m["EmptyFileRatio"].type()) {
        GetDoctorHDFSClusterResponseBodyDataMetricsEmptyFileRatio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EmptyFileRatio"]));
        emptyFileRatio = make_shared<GetDoctorHDFSClusterResponseBodyDataMetricsEmptyFileRatio>(model1);
      }
    }
    if (m.find("FreezeDataDayGrowthSize") != m.end() && !m["FreezeDataDayGrowthSize"].empty()) {
      if (typeid(map<string, boost::any>) == m["FreezeDataDayGrowthSize"].type()) {
        GetDoctorHDFSClusterResponseBodyDataMetricsFreezeDataDayGrowthSize model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FreezeDataDayGrowthSize"]));
        freezeDataDayGrowthSize = make_shared<GetDoctorHDFSClusterResponseBodyDataMetricsFreezeDataDayGrowthSize>(model1);
      }
    }
    if (m.find("FreezeDataRatio") != m.end() && !m["FreezeDataRatio"].empty()) {
      if (typeid(map<string, boost::any>) == m["FreezeDataRatio"].type()) {
        GetDoctorHDFSClusterResponseBodyDataMetricsFreezeDataRatio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FreezeDataRatio"]));
        freezeDataRatio = make_shared<GetDoctorHDFSClusterResponseBodyDataMetricsFreezeDataRatio>(model1);
      }
    }
    if (m.find("FreezeDataSize") != m.end() && !m["FreezeDataSize"].empty()) {
      if (typeid(map<string, boost::any>) == m["FreezeDataSize"].type()) {
        GetDoctorHDFSClusterResponseBodyDataMetricsFreezeDataSize model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FreezeDataSize"]));
        freezeDataSize = make_shared<GetDoctorHDFSClusterResponseBodyDataMetricsFreezeDataSize>(model1);
      }
    }
    if (m.find("FreezeDataSizeDayGrowthRatio") != m.end() && !m["FreezeDataSizeDayGrowthRatio"].empty()) {
      if (typeid(map<string, boost::any>) == m["FreezeDataSizeDayGrowthRatio"].type()) {
        GetDoctorHDFSClusterResponseBodyDataMetricsFreezeDataSizeDayGrowthRatio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FreezeDataSizeDayGrowthRatio"]));
        freezeDataSizeDayGrowthRatio = make_shared<GetDoctorHDFSClusterResponseBodyDataMetricsFreezeDataSizeDayGrowthRatio>(model1);
      }
    }
    if (m.find("HotDataDayGrowthSize") != m.end() && !m["HotDataDayGrowthSize"].empty()) {
      if (typeid(map<string, boost::any>) == m["HotDataDayGrowthSize"].type()) {
        GetDoctorHDFSClusterResponseBodyDataMetricsHotDataDayGrowthSize model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["HotDataDayGrowthSize"]));
        hotDataDayGrowthSize = make_shared<GetDoctorHDFSClusterResponseBodyDataMetricsHotDataDayGrowthSize>(model1);
      }
    }
    if (m.find("HotDataRatio") != m.end() && !m["HotDataRatio"].empty()) {
      if (typeid(map<string, boost::any>) == m["HotDataRatio"].type()) {
        GetDoctorHDFSClusterResponseBodyDataMetricsHotDataRatio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["HotDataRatio"]));
        hotDataRatio = make_shared<GetDoctorHDFSClusterResponseBodyDataMetricsHotDataRatio>(model1);
      }
    }
    if (m.find("HotDataSize") != m.end() && !m["HotDataSize"].empty()) {
      if (typeid(map<string, boost::any>) == m["HotDataSize"].type()) {
        GetDoctorHDFSClusterResponseBodyDataMetricsHotDataSize model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["HotDataSize"]));
        hotDataSize = make_shared<GetDoctorHDFSClusterResponseBodyDataMetricsHotDataSize>(model1);
      }
    }
    if (m.find("HotDataSizeDayGrowthRatio") != m.end() && !m["HotDataSizeDayGrowthRatio"].empty()) {
      if (typeid(map<string, boost::any>) == m["HotDataSizeDayGrowthRatio"].type()) {
        GetDoctorHDFSClusterResponseBodyDataMetricsHotDataSizeDayGrowthRatio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["HotDataSizeDayGrowthRatio"]));
        hotDataSizeDayGrowthRatio = make_shared<GetDoctorHDFSClusterResponseBodyDataMetricsHotDataSizeDayGrowthRatio>(model1);
      }
    }
    if (m.find("LargeFileCount") != m.end() && !m["LargeFileCount"].empty()) {
      if (typeid(map<string, boost::any>) == m["LargeFileCount"].type()) {
        GetDoctorHDFSClusterResponseBodyDataMetricsLargeFileCount model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LargeFileCount"]));
        largeFileCount = make_shared<GetDoctorHDFSClusterResponseBodyDataMetricsLargeFileCount>(model1);
      }
    }
    if (m.find("LargeFileCountDayGrowthRatio") != m.end() && !m["LargeFileCountDayGrowthRatio"].empty()) {
      if (typeid(map<string, boost::any>) == m["LargeFileCountDayGrowthRatio"].type()) {
        GetDoctorHDFSClusterResponseBodyDataMetricsLargeFileCountDayGrowthRatio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LargeFileCountDayGrowthRatio"]));
        largeFileCountDayGrowthRatio = make_shared<GetDoctorHDFSClusterResponseBodyDataMetricsLargeFileCountDayGrowthRatio>(model1);
      }
    }
    if (m.find("LargeFileDayGrowthCount") != m.end() && !m["LargeFileDayGrowthCount"].empty()) {
      if (typeid(map<string, boost::any>) == m["LargeFileDayGrowthCount"].type()) {
        GetDoctorHDFSClusterResponseBodyDataMetricsLargeFileDayGrowthCount model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LargeFileDayGrowthCount"]));
        largeFileDayGrowthCount = make_shared<GetDoctorHDFSClusterResponseBodyDataMetricsLargeFileDayGrowthCount>(model1);
      }
    }
    if (m.find("LargeFileRatio") != m.end() && !m["LargeFileRatio"].empty()) {
      if (typeid(map<string, boost::any>) == m["LargeFileRatio"].type()) {
        GetDoctorHDFSClusterResponseBodyDataMetricsLargeFileRatio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LargeFileRatio"]));
        largeFileRatio = make_shared<GetDoctorHDFSClusterResponseBodyDataMetricsLargeFileRatio>(model1);
      }
    }
    if (m.find("MediumFileCount") != m.end() && !m["MediumFileCount"].empty()) {
      if (typeid(map<string, boost::any>) == m["MediumFileCount"].type()) {
        GetDoctorHDFSClusterResponseBodyDataMetricsMediumFileCount model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MediumFileCount"]));
        mediumFileCount = make_shared<GetDoctorHDFSClusterResponseBodyDataMetricsMediumFileCount>(model1);
      }
    }
    if (m.find("MediumFileCountDayGrowthRatio") != m.end() && !m["MediumFileCountDayGrowthRatio"].empty()) {
      if (typeid(map<string, boost::any>) == m["MediumFileCountDayGrowthRatio"].type()) {
        GetDoctorHDFSClusterResponseBodyDataMetricsMediumFileCountDayGrowthRatio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MediumFileCountDayGrowthRatio"]));
        mediumFileCountDayGrowthRatio = make_shared<GetDoctorHDFSClusterResponseBodyDataMetricsMediumFileCountDayGrowthRatio>(model1);
      }
    }
    if (m.find("MediumFileDayGrowthCount") != m.end() && !m["MediumFileDayGrowthCount"].empty()) {
      if (typeid(map<string, boost::any>) == m["MediumFileDayGrowthCount"].type()) {
        GetDoctorHDFSClusterResponseBodyDataMetricsMediumFileDayGrowthCount model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MediumFileDayGrowthCount"]));
        mediumFileDayGrowthCount = make_shared<GetDoctorHDFSClusterResponseBodyDataMetricsMediumFileDayGrowthCount>(model1);
      }
    }
    if (m.find("MediumFileRatio") != m.end() && !m["MediumFileRatio"].empty()) {
      if (typeid(map<string, boost::any>) == m["MediumFileRatio"].type()) {
        GetDoctorHDFSClusterResponseBodyDataMetricsMediumFileRatio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MediumFileRatio"]));
        mediumFileRatio = make_shared<GetDoctorHDFSClusterResponseBodyDataMetricsMediumFileRatio>(model1);
      }
    }
    if (m.find("SmallFileCount") != m.end() && !m["SmallFileCount"].empty()) {
      if (typeid(map<string, boost::any>) == m["SmallFileCount"].type()) {
        GetDoctorHDFSClusterResponseBodyDataMetricsSmallFileCount model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SmallFileCount"]));
        smallFileCount = make_shared<GetDoctorHDFSClusterResponseBodyDataMetricsSmallFileCount>(model1);
      }
    }
    if (m.find("SmallFileCountDayGrowthRatio") != m.end() && !m["SmallFileCountDayGrowthRatio"].empty()) {
      if (typeid(map<string, boost::any>) == m["SmallFileCountDayGrowthRatio"].type()) {
        GetDoctorHDFSClusterResponseBodyDataMetricsSmallFileCountDayGrowthRatio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SmallFileCountDayGrowthRatio"]));
        smallFileCountDayGrowthRatio = make_shared<GetDoctorHDFSClusterResponseBodyDataMetricsSmallFileCountDayGrowthRatio>(model1);
      }
    }
    if (m.find("SmallFileDayGrowthCount") != m.end() && !m["SmallFileDayGrowthCount"].empty()) {
      if (typeid(map<string, boost::any>) == m["SmallFileDayGrowthCount"].type()) {
        GetDoctorHDFSClusterResponseBodyDataMetricsSmallFileDayGrowthCount model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SmallFileDayGrowthCount"]));
        smallFileDayGrowthCount = make_shared<GetDoctorHDFSClusterResponseBodyDataMetricsSmallFileDayGrowthCount>(model1);
      }
    }
    if (m.find("SmallFileRatio") != m.end() && !m["SmallFileRatio"].empty()) {
      if (typeid(map<string, boost::any>) == m["SmallFileRatio"].type()) {
        GetDoctorHDFSClusterResponseBodyDataMetricsSmallFileRatio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SmallFileRatio"]));
        smallFileRatio = make_shared<GetDoctorHDFSClusterResponseBodyDataMetricsSmallFileRatio>(model1);
      }
    }
    if (m.find("TinyFileCount") != m.end() && !m["TinyFileCount"].empty()) {
      if (typeid(map<string, boost::any>) == m["TinyFileCount"].type()) {
        GetDoctorHDFSClusterResponseBodyDataMetricsTinyFileCount model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TinyFileCount"]));
        tinyFileCount = make_shared<GetDoctorHDFSClusterResponseBodyDataMetricsTinyFileCount>(model1);
      }
    }
    if (m.find("TinyFileCountDayGrowthRatio") != m.end() && !m["TinyFileCountDayGrowthRatio"].empty()) {
      if (typeid(map<string, boost::any>) == m["TinyFileCountDayGrowthRatio"].type()) {
        GetDoctorHDFSClusterResponseBodyDataMetricsTinyFileCountDayGrowthRatio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TinyFileCountDayGrowthRatio"]));
        tinyFileCountDayGrowthRatio = make_shared<GetDoctorHDFSClusterResponseBodyDataMetricsTinyFileCountDayGrowthRatio>(model1);
      }
    }
    if (m.find("TinyFileDayGrowthCount") != m.end() && !m["TinyFileDayGrowthCount"].empty()) {
      if (typeid(map<string, boost::any>) == m["TinyFileDayGrowthCount"].type()) {
        GetDoctorHDFSClusterResponseBodyDataMetricsTinyFileDayGrowthCount model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TinyFileDayGrowthCount"]));
        tinyFileDayGrowthCount = make_shared<GetDoctorHDFSClusterResponseBodyDataMetricsTinyFileDayGrowthCount>(model1);
      }
    }
    if (m.find("TinyFileRatio") != m.end() && !m["TinyFileRatio"].empty()) {
      if (typeid(map<string, boost::any>) == m["TinyFileRatio"].type()) {
        GetDoctorHDFSClusterResponseBodyDataMetricsTinyFileRatio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TinyFileRatio"]));
        tinyFileRatio = make_shared<GetDoctorHDFSClusterResponseBodyDataMetricsTinyFileRatio>(model1);
      }
    }
    if (m.find("TotalDataDayGrowthSize") != m.end() && !m["TotalDataDayGrowthSize"].empty()) {
      if (typeid(map<string, boost::any>) == m["TotalDataDayGrowthSize"].type()) {
        GetDoctorHDFSClusterResponseBodyDataMetricsTotalDataDayGrowthSize model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TotalDataDayGrowthSize"]));
        totalDataDayGrowthSize = make_shared<GetDoctorHDFSClusterResponseBodyDataMetricsTotalDataDayGrowthSize>(model1);
      }
    }
    if (m.find("TotalDataSize") != m.end() && !m["TotalDataSize"].empty()) {
      if (typeid(map<string, boost::any>) == m["TotalDataSize"].type()) {
        GetDoctorHDFSClusterResponseBodyDataMetricsTotalDataSize model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TotalDataSize"]));
        totalDataSize = make_shared<GetDoctorHDFSClusterResponseBodyDataMetricsTotalDataSize>(model1);
      }
    }
    if (m.find("TotalDataSizeDayGrowthRatio") != m.end() && !m["TotalDataSizeDayGrowthRatio"].empty()) {
      if (typeid(map<string, boost::any>) == m["TotalDataSizeDayGrowthRatio"].type()) {
        GetDoctorHDFSClusterResponseBodyDataMetricsTotalDataSizeDayGrowthRatio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TotalDataSizeDayGrowthRatio"]));
        totalDataSizeDayGrowthRatio = make_shared<GetDoctorHDFSClusterResponseBodyDataMetricsTotalDataSizeDayGrowthRatio>(model1);
      }
    }
    if (m.find("TotalFileCount") != m.end() && !m["TotalFileCount"].empty()) {
      if (typeid(map<string, boost::any>) == m["TotalFileCount"].type()) {
        GetDoctorHDFSClusterResponseBodyDataMetricsTotalFileCount model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TotalFileCount"]));
        totalFileCount = make_shared<GetDoctorHDFSClusterResponseBodyDataMetricsTotalFileCount>(model1);
      }
    }
    if (m.find("TotalFileCountDayGrowthRatio") != m.end() && !m["TotalFileCountDayGrowthRatio"].empty()) {
      if (typeid(map<string, boost::any>) == m["TotalFileCountDayGrowthRatio"].type()) {
        GetDoctorHDFSClusterResponseBodyDataMetricsTotalFileCountDayGrowthRatio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TotalFileCountDayGrowthRatio"]));
        totalFileCountDayGrowthRatio = make_shared<GetDoctorHDFSClusterResponseBodyDataMetricsTotalFileCountDayGrowthRatio>(model1);
      }
    }
    if (m.find("TotalFileDayGrowthCount") != m.end() && !m["TotalFileDayGrowthCount"].empty()) {
      if (typeid(map<string, boost::any>) == m["TotalFileDayGrowthCount"].type()) {
        GetDoctorHDFSClusterResponseBodyDataMetricsTotalFileDayGrowthCount model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TotalFileDayGrowthCount"]));
        totalFileDayGrowthCount = make_shared<GetDoctorHDFSClusterResponseBodyDataMetricsTotalFileDayGrowthCount>(model1);
      }
    }
    if (m.find("WarmDataDayGrowthSize") != m.end() && !m["WarmDataDayGrowthSize"].empty()) {
      if (typeid(map<string, boost::any>) == m["WarmDataDayGrowthSize"].type()) {
        GetDoctorHDFSClusterResponseBodyDataMetricsWarmDataDayGrowthSize model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["WarmDataDayGrowthSize"]));
        warmDataDayGrowthSize = make_shared<GetDoctorHDFSClusterResponseBodyDataMetricsWarmDataDayGrowthSize>(model1);
      }
    }
    if (m.find("WarmDataRatio") != m.end() && !m["WarmDataRatio"].empty()) {
      if (typeid(map<string, boost::any>) == m["WarmDataRatio"].type()) {
        GetDoctorHDFSClusterResponseBodyDataMetricsWarmDataRatio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["WarmDataRatio"]));
        warmDataRatio = make_shared<GetDoctorHDFSClusterResponseBodyDataMetricsWarmDataRatio>(model1);
      }
    }
    if (m.find("WarmDataSize") != m.end() && !m["WarmDataSize"].empty()) {
      if (typeid(map<string, boost::any>) == m["WarmDataSize"].type()) {
        GetDoctorHDFSClusterResponseBodyDataMetricsWarmDataSize model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["WarmDataSize"]));
        warmDataSize = make_shared<GetDoctorHDFSClusterResponseBodyDataMetricsWarmDataSize>(model1);
      }
    }
    if (m.find("WarmDataSizeDayGrowthRatio") != m.end() && !m["WarmDataSizeDayGrowthRatio"].empty()) {
      if (typeid(map<string, boost::any>) == m["WarmDataSizeDayGrowthRatio"].type()) {
        GetDoctorHDFSClusterResponseBodyDataMetricsWarmDataSizeDayGrowthRatio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["WarmDataSizeDayGrowthRatio"]));
        warmDataSizeDayGrowthRatio = make_shared<GetDoctorHDFSClusterResponseBodyDataMetricsWarmDataSizeDayGrowthRatio>(model1);
      }
    }
  }


  virtual ~GetDoctorHDFSClusterResponseBodyDataMetrics() = default;
};
class GetDoctorHDFSClusterResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<GetDoctorHDFSClusterResponseBodyDataAnalysis> analysis{};
  shared_ptr<GetDoctorHDFSClusterResponseBodyDataMetrics> metrics{};

  GetDoctorHDFSClusterResponseBodyData() {}

  explicit GetDoctorHDFSClusterResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (analysis) {
      res["Analysis"] = analysis ? boost::any(analysis->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (metrics) {
      res["Metrics"] = metrics ? boost::any(metrics->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Analysis") != m.end() && !m["Analysis"].empty()) {
      if (typeid(map<string, boost::any>) == m["Analysis"].type()) {
        GetDoctorHDFSClusterResponseBodyDataAnalysis model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Analysis"]));
        analysis = make_shared<GetDoctorHDFSClusterResponseBodyDataAnalysis>(model1);
      }
    }
    if (m.find("Metrics") != m.end() && !m["Metrics"].empty()) {
      if (typeid(map<string, boost::any>) == m["Metrics"].type()) {
        GetDoctorHDFSClusterResponseBodyDataMetrics model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Metrics"]));
        metrics = make_shared<GetDoctorHDFSClusterResponseBodyDataMetrics>(model1);
      }
    }
  }


  virtual ~GetDoctorHDFSClusterResponseBodyData() = default;
};
class GetDoctorHDFSClusterResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetDoctorHDFSClusterResponseBodyData> data{};
  shared_ptr<string> requestId{};

  GetDoctorHDFSClusterResponseBody() {}

  explicit GetDoctorHDFSClusterResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetDoctorHDFSClusterResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetDoctorHDFSClusterResponseBodyData>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetDoctorHDFSClusterResponseBody() = default;
};
class GetDoctorHDFSClusterResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetDoctorHDFSClusterResponseBody> body{};

  GetDoctorHDFSClusterResponse() {}

  explicit GetDoctorHDFSClusterResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetDoctorHDFSClusterResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetDoctorHDFSClusterResponseBody>(model1);
      }
    }
  }


  virtual ~GetDoctorHDFSClusterResponse() = default;
};
class GetDoctorHDFSDirectoryRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> dateTime{};
  shared_ptr<string> dirPath{};
  shared_ptr<string> regionId{};

  GetDoctorHDFSDirectoryRequest() {}

  explicit GetDoctorHDFSDirectoryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (dateTime) {
      res["DateTime"] = boost::any(*dateTime);
    }
    if (dirPath) {
      res["DirPath"] = boost::any(*dirPath);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("DateTime") != m.end() && !m["DateTime"].empty()) {
      dateTime = make_shared<string>(boost::any_cast<string>(m["DateTime"]));
    }
    if (m.find("DirPath") != m.end() && !m["DirPath"].empty()) {
      dirPath = make_shared<string>(boost::any_cast<string>(m["DirPath"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~GetDoctorHDFSDirectoryRequest() = default;
};
class GetDoctorHDFSDirectoryResponseBodyDataMetricsColdDataDayGrowthSize : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  GetDoctorHDFSDirectoryResponseBodyDataMetricsColdDataDayGrowthSize() {}

  explicit GetDoctorHDFSDirectoryResponseBodyDataMetricsColdDataDayGrowthSize(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~GetDoctorHDFSDirectoryResponseBodyDataMetricsColdDataDayGrowthSize() = default;
};
class GetDoctorHDFSDirectoryResponseBodyDataMetricsColdDataSize : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  GetDoctorHDFSDirectoryResponseBodyDataMetricsColdDataSize() {}

  explicit GetDoctorHDFSDirectoryResponseBodyDataMetricsColdDataSize(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~GetDoctorHDFSDirectoryResponseBodyDataMetricsColdDataSize() = default;
};
class GetDoctorHDFSDirectoryResponseBodyDataMetricsColdDataSizeDayGrowthRatio : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  GetDoctorHDFSDirectoryResponseBodyDataMetricsColdDataSizeDayGrowthRatio() {}

  explicit GetDoctorHDFSDirectoryResponseBodyDataMetricsColdDataSizeDayGrowthRatio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~GetDoctorHDFSDirectoryResponseBodyDataMetricsColdDataSizeDayGrowthRatio() = default;
};
class GetDoctorHDFSDirectoryResponseBodyDataMetricsEmptyFileCount : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  GetDoctorHDFSDirectoryResponseBodyDataMetricsEmptyFileCount() {}

  explicit GetDoctorHDFSDirectoryResponseBodyDataMetricsEmptyFileCount(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~GetDoctorHDFSDirectoryResponseBodyDataMetricsEmptyFileCount() = default;
};
class GetDoctorHDFSDirectoryResponseBodyDataMetricsEmptyFileCountDayGrowthRatio : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  GetDoctorHDFSDirectoryResponseBodyDataMetricsEmptyFileCountDayGrowthRatio() {}

  explicit GetDoctorHDFSDirectoryResponseBodyDataMetricsEmptyFileCountDayGrowthRatio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~GetDoctorHDFSDirectoryResponseBodyDataMetricsEmptyFileCountDayGrowthRatio() = default;
};
class GetDoctorHDFSDirectoryResponseBodyDataMetricsEmptyFileDayGrowthCount : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  GetDoctorHDFSDirectoryResponseBodyDataMetricsEmptyFileDayGrowthCount() {}

  explicit GetDoctorHDFSDirectoryResponseBodyDataMetricsEmptyFileDayGrowthCount(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~GetDoctorHDFSDirectoryResponseBodyDataMetricsEmptyFileDayGrowthCount() = default;
};
class GetDoctorHDFSDirectoryResponseBodyDataMetricsFreezeDataDayGrowthSize : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  GetDoctorHDFSDirectoryResponseBodyDataMetricsFreezeDataDayGrowthSize() {}

  explicit GetDoctorHDFSDirectoryResponseBodyDataMetricsFreezeDataDayGrowthSize(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~GetDoctorHDFSDirectoryResponseBodyDataMetricsFreezeDataDayGrowthSize() = default;
};
class GetDoctorHDFSDirectoryResponseBodyDataMetricsFreezeDataSize : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  GetDoctorHDFSDirectoryResponseBodyDataMetricsFreezeDataSize() {}

  explicit GetDoctorHDFSDirectoryResponseBodyDataMetricsFreezeDataSize(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~GetDoctorHDFSDirectoryResponseBodyDataMetricsFreezeDataSize() = default;
};
class GetDoctorHDFSDirectoryResponseBodyDataMetricsFreezeDataSizeDayGrowthRatio : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  GetDoctorHDFSDirectoryResponseBodyDataMetricsFreezeDataSizeDayGrowthRatio() {}

  explicit GetDoctorHDFSDirectoryResponseBodyDataMetricsFreezeDataSizeDayGrowthRatio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~GetDoctorHDFSDirectoryResponseBodyDataMetricsFreezeDataSizeDayGrowthRatio() = default;
};
class GetDoctorHDFSDirectoryResponseBodyDataMetricsHotDataDayGrowthSize : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  GetDoctorHDFSDirectoryResponseBodyDataMetricsHotDataDayGrowthSize() {}

  explicit GetDoctorHDFSDirectoryResponseBodyDataMetricsHotDataDayGrowthSize(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~GetDoctorHDFSDirectoryResponseBodyDataMetricsHotDataDayGrowthSize() = default;
};
class GetDoctorHDFSDirectoryResponseBodyDataMetricsHotDataSize : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  GetDoctorHDFSDirectoryResponseBodyDataMetricsHotDataSize() {}

  explicit GetDoctorHDFSDirectoryResponseBodyDataMetricsHotDataSize(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~GetDoctorHDFSDirectoryResponseBodyDataMetricsHotDataSize() = default;
};
class GetDoctorHDFSDirectoryResponseBodyDataMetricsHotDataSizeDayGrowthRatio : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  GetDoctorHDFSDirectoryResponseBodyDataMetricsHotDataSizeDayGrowthRatio() {}

  explicit GetDoctorHDFSDirectoryResponseBodyDataMetricsHotDataSizeDayGrowthRatio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~GetDoctorHDFSDirectoryResponseBodyDataMetricsHotDataSizeDayGrowthRatio() = default;
};
class GetDoctorHDFSDirectoryResponseBodyDataMetricsLargeFileCount : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  GetDoctorHDFSDirectoryResponseBodyDataMetricsLargeFileCount() {}

  explicit GetDoctorHDFSDirectoryResponseBodyDataMetricsLargeFileCount(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~GetDoctorHDFSDirectoryResponseBodyDataMetricsLargeFileCount() = default;
};
class GetDoctorHDFSDirectoryResponseBodyDataMetricsLargeFileCountDayGrowthRatio : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  GetDoctorHDFSDirectoryResponseBodyDataMetricsLargeFileCountDayGrowthRatio() {}

  explicit GetDoctorHDFSDirectoryResponseBodyDataMetricsLargeFileCountDayGrowthRatio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~GetDoctorHDFSDirectoryResponseBodyDataMetricsLargeFileCountDayGrowthRatio() = default;
};
class GetDoctorHDFSDirectoryResponseBodyDataMetricsLargeFileDayGrowthCount : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  GetDoctorHDFSDirectoryResponseBodyDataMetricsLargeFileDayGrowthCount() {}

  explicit GetDoctorHDFSDirectoryResponseBodyDataMetricsLargeFileDayGrowthCount(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~GetDoctorHDFSDirectoryResponseBodyDataMetricsLargeFileDayGrowthCount() = default;
};
class GetDoctorHDFSDirectoryResponseBodyDataMetricsMediumFileCount : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  GetDoctorHDFSDirectoryResponseBodyDataMetricsMediumFileCount() {}

  explicit GetDoctorHDFSDirectoryResponseBodyDataMetricsMediumFileCount(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~GetDoctorHDFSDirectoryResponseBodyDataMetricsMediumFileCount() = default;
};
class GetDoctorHDFSDirectoryResponseBodyDataMetricsMediumFileCountDayGrowthRatio : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  GetDoctorHDFSDirectoryResponseBodyDataMetricsMediumFileCountDayGrowthRatio() {}

  explicit GetDoctorHDFSDirectoryResponseBodyDataMetricsMediumFileCountDayGrowthRatio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~GetDoctorHDFSDirectoryResponseBodyDataMetricsMediumFileCountDayGrowthRatio() = default;
};
class GetDoctorHDFSDirectoryResponseBodyDataMetricsMediumFileDayGrowthCount : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  GetDoctorHDFSDirectoryResponseBodyDataMetricsMediumFileDayGrowthCount() {}

  explicit GetDoctorHDFSDirectoryResponseBodyDataMetricsMediumFileDayGrowthCount(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~GetDoctorHDFSDirectoryResponseBodyDataMetricsMediumFileDayGrowthCount() = default;
};
class GetDoctorHDFSDirectoryResponseBodyDataMetricsSmallFileCount : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  GetDoctorHDFSDirectoryResponseBodyDataMetricsSmallFileCount() {}

  explicit GetDoctorHDFSDirectoryResponseBodyDataMetricsSmallFileCount(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~GetDoctorHDFSDirectoryResponseBodyDataMetricsSmallFileCount() = default;
};
class GetDoctorHDFSDirectoryResponseBodyDataMetricsSmallFileCountDayGrowthRatio : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  GetDoctorHDFSDirectoryResponseBodyDataMetricsSmallFileCountDayGrowthRatio() {}

  explicit GetDoctorHDFSDirectoryResponseBodyDataMetricsSmallFileCountDayGrowthRatio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~GetDoctorHDFSDirectoryResponseBodyDataMetricsSmallFileCountDayGrowthRatio() = default;
};
class GetDoctorHDFSDirectoryResponseBodyDataMetricsSmallFileDayGrowthCount : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  GetDoctorHDFSDirectoryResponseBodyDataMetricsSmallFileDayGrowthCount() {}

  explicit GetDoctorHDFSDirectoryResponseBodyDataMetricsSmallFileDayGrowthCount(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~GetDoctorHDFSDirectoryResponseBodyDataMetricsSmallFileDayGrowthCount() = default;
};
class GetDoctorHDFSDirectoryResponseBodyDataMetricsTinyFileCount : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  GetDoctorHDFSDirectoryResponseBodyDataMetricsTinyFileCount() {}

  explicit GetDoctorHDFSDirectoryResponseBodyDataMetricsTinyFileCount(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~GetDoctorHDFSDirectoryResponseBodyDataMetricsTinyFileCount() = default;
};
class GetDoctorHDFSDirectoryResponseBodyDataMetricsTinyFileCountDayGrowthRatio : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  GetDoctorHDFSDirectoryResponseBodyDataMetricsTinyFileCountDayGrowthRatio() {}

  explicit GetDoctorHDFSDirectoryResponseBodyDataMetricsTinyFileCountDayGrowthRatio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~GetDoctorHDFSDirectoryResponseBodyDataMetricsTinyFileCountDayGrowthRatio() = default;
};
class GetDoctorHDFSDirectoryResponseBodyDataMetricsTinyFileDayGrowthCount : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  GetDoctorHDFSDirectoryResponseBodyDataMetricsTinyFileDayGrowthCount() {}

  explicit GetDoctorHDFSDirectoryResponseBodyDataMetricsTinyFileDayGrowthCount(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~GetDoctorHDFSDirectoryResponseBodyDataMetricsTinyFileDayGrowthCount() = default;
};
class GetDoctorHDFSDirectoryResponseBodyDataMetricsTotalDataDayGrowthSize : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  GetDoctorHDFSDirectoryResponseBodyDataMetricsTotalDataDayGrowthSize() {}

  explicit GetDoctorHDFSDirectoryResponseBodyDataMetricsTotalDataDayGrowthSize(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~GetDoctorHDFSDirectoryResponseBodyDataMetricsTotalDataDayGrowthSize() = default;
};
class GetDoctorHDFSDirectoryResponseBodyDataMetricsTotalDataSize : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  GetDoctorHDFSDirectoryResponseBodyDataMetricsTotalDataSize() {}

  explicit GetDoctorHDFSDirectoryResponseBodyDataMetricsTotalDataSize(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~GetDoctorHDFSDirectoryResponseBodyDataMetricsTotalDataSize() = default;
};
class GetDoctorHDFSDirectoryResponseBodyDataMetricsTotalDataSizeDayGrowthRatio : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  GetDoctorHDFSDirectoryResponseBodyDataMetricsTotalDataSizeDayGrowthRatio() {}

  explicit GetDoctorHDFSDirectoryResponseBodyDataMetricsTotalDataSizeDayGrowthRatio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~GetDoctorHDFSDirectoryResponseBodyDataMetricsTotalDataSizeDayGrowthRatio() = default;
};
class GetDoctorHDFSDirectoryResponseBodyDataMetricsTotalFileCount : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  GetDoctorHDFSDirectoryResponseBodyDataMetricsTotalFileCount() {}

  explicit GetDoctorHDFSDirectoryResponseBodyDataMetricsTotalFileCount(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~GetDoctorHDFSDirectoryResponseBodyDataMetricsTotalFileCount() = default;
};
class GetDoctorHDFSDirectoryResponseBodyDataMetricsTotalFileCountDayGrowthRatio : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  GetDoctorHDFSDirectoryResponseBodyDataMetricsTotalFileCountDayGrowthRatio() {}

  explicit GetDoctorHDFSDirectoryResponseBodyDataMetricsTotalFileCountDayGrowthRatio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~GetDoctorHDFSDirectoryResponseBodyDataMetricsTotalFileCountDayGrowthRatio() = default;
};
class GetDoctorHDFSDirectoryResponseBodyDataMetricsTotalFileDayGrowthCount : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  GetDoctorHDFSDirectoryResponseBodyDataMetricsTotalFileDayGrowthCount() {}

  explicit GetDoctorHDFSDirectoryResponseBodyDataMetricsTotalFileDayGrowthCount(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~GetDoctorHDFSDirectoryResponseBodyDataMetricsTotalFileDayGrowthCount() = default;
};
class GetDoctorHDFSDirectoryResponseBodyDataMetricsWarmDataDayGrowthSize : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  GetDoctorHDFSDirectoryResponseBodyDataMetricsWarmDataDayGrowthSize() {}

  explicit GetDoctorHDFSDirectoryResponseBodyDataMetricsWarmDataDayGrowthSize(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~GetDoctorHDFSDirectoryResponseBodyDataMetricsWarmDataDayGrowthSize() = default;
};
class GetDoctorHDFSDirectoryResponseBodyDataMetricsWarmDataSize : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  GetDoctorHDFSDirectoryResponseBodyDataMetricsWarmDataSize() {}

  explicit GetDoctorHDFSDirectoryResponseBodyDataMetricsWarmDataSize(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~GetDoctorHDFSDirectoryResponseBodyDataMetricsWarmDataSize() = default;
};
class GetDoctorHDFSDirectoryResponseBodyDataMetricsWarmDataSizeDayGrowthRatio : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  GetDoctorHDFSDirectoryResponseBodyDataMetricsWarmDataSizeDayGrowthRatio() {}

  explicit GetDoctorHDFSDirectoryResponseBodyDataMetricsWarmDataSizeDayGrowthRatio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~GetDoctorHDFSDirectoryResponseBodyDataMetricsWarmDataSizeDayGrowthRatio() = default;
};
class GetDoctorHDFSDirectoryResponseBodyDataMetrics : public Darabonba::Model {
public:
  shared_ptr<GetDoctorHDFSDirectoryResponseBodyDataMetricsColdDataDayGrowthSize> coldDataDayGrowthSize{};
  shared_ptr<GetDoctorHDFSDirectoryResponseBodyDataMetricsColdDataSize> coldDataSize{};
  shared_ptr<GetDoctorHDFSDirectoryResponseBodyDataMetricsColdDataSizeDayGrowthRatio> coldDataSizeDayGrowthRatio{};
  shared_ptr<GetDoctorHDFSDirectoryResponseBodyDataMetricsEmptyFileCount> emptyFileCount{};
  shared_ptr<GetDoctorHDFSDirectoryResponseBodyDataMetricsEmptyFileCountDayGrowthRatio> emptyFileCountDayGrowthRatio{};
  shared_ptr<GetDoctorHDFSDirectoryResponseBodyDataMetricsEmptyFileDayGrowthCount> emptyFileDayGrowthCount{};
  shared_ptr<GetDoctorHDFSDirectoryResponseBodyDataMetricsFreezeDataDayGrowthSize> freezeDataDayGrowthSize{};
  shared_ptr<GetDoctorHDFSDirectoryResponseBodyDataMetricsFreezeDataSize> freezeDataSize{};
  shared_ptr<GetDoctorHDFSDirectoryResponseBodyDataMetricsFreezeDataSizeDayGrowthRatio> freezeDataSizeDayGrowthRatio{};
  shared_ptr<GetDoctorHDFSDirectoryResponseBodyDataMetricsHotDataDayGrowthSize> hotDataDayGrowthSize{};
  shared_ptr<GetDoctorHDFSDirectoryResponseBodyDataMetricsHotDataSize> hotDataSize{};
  shared_ptr<GetDoctorHDFSDirectoryResponseBodyDataMetricsHotDataSizeDayGrowthRatio> hotDataSizeDayGrowthRatio{};
  shared_ptr<GetDoctorHDFSDirectoryResponseBodyDataMetricsLargeFileCount> largeFileCount{};
  shared_ptr<GetDoctorHDFSDirectoryResponseBodyDataMetricsLargeFileCountDayGrowthRatio> largeFileCountDayGrowthRatio{};
  shared_ptr<GetDoctorHDFSDirectoryResponseBodyDataMetricsLargeFileDayGrowthCount> largeFileDayGrowthCount{};
  shared_ptr<GetDoctorHDFSDirectoryResponseBodyDataMetricsMediumFileCount> mediumFileCount{};
  shared_ptr<GetDoctorHDFSDirectoryResponseBodyDataMetricsMediumFileCountDayGrowthRatio> mediumFileCountDayGrowthRatio{};
  shared_ptr<GetDoctorHDFSDirectoryResponseBodyDataMetricsMediumFileDayGrowthCount> mediumFileDayGrowthCount{};
  shared_ptr<GetDoctorHDFSDirectoryResponseBodyDataMetricsSmallFileCount> smallFileCount{};
  shared_ptr<GetDoctorHDFSDirectoryResponseBodyDataMetricsSmallFileCountDayGrowthRatio> smallFileCountDayGrowthRatio{};
  shared_ptr<GetDoctorHDFSDirectoryResponseBodyDataMetricsSmallFileDayGrowthCount> smallFileDayGrowthCount{};
  shared_ptr<GetDoctorHDFSDirectoryResponseBodyDataMetricsTinyFileCount> tinyFileCount{};
  shared_ptr<GetDoctorHDFSDirectoryResponseBodyDataMetricsTinyFileCountDayGrowthRatio> tinyFileCountDayGrowthRatio{};
  shared_ptr<GetDoctorHDFSDirectoryResponseBodyDataMetricsTinyFileDayGrowthCount> tinyFileDayGrowthCount{};
  shared_ptr<GetDoctorHDFSDirectoryResponseBodyDataMetricsTotalDataDayGrowthSize> totalDataDayGrowthSize{};
  shared_ptr<GetDoctorHDFSDirectoryResponseBodyDataMetricsTotalDataSize> totalDataSize{};
  shared_ptr<GetDoctorHDFSDirectoryResponseBodyDataMetricsTotalDataSizeDayGrowthRatio> totalDataSizeDayGrowthRatio{};
  shared_ptr<GetDoctorHDFSDirectoryResponseBodyDataMetricsTotalFileCount> totalFileCount{};
  shared_ptr<GetDoctorHDFSDirectoryResponseBodyDataMetricsTotalFileCountDayGrowthRatio> totalFileCountDayGrowthRatio{};
  shared_ptr<GetDoctorHDFSDirectoryResponseBodyDataMetricsTotalFileDayGrowthCount> totalFileDayGrowthCount{};
  shared_ptr<GetDoctorHDFSDirectoryResponseBodyDataMetricsWarmDataDayGrowthSize> warmDataDayGrowthSize{};
  shared_ptr<GetDoctorHDFSDirectoryResponseBodyDataMetricsWarmDataSize> warmDataSize{};
  shared_ptr<GetDoctorHDFSDirectoryResponseBodyDataMetricsWarmDataSizeDayGrowthRatio> warmDataSizeDayGrowthRatio{};

  GetDoctorHDFSDirectoryResponseBodyDataMetrics() {}

  explicit GetDoctorHDFSDirectoryResponseBodyDataMetrics(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (coldDataDayGrowthSize) {
      res["ColdDataDayGrowthSize"] = coldDataDayGrowthSize ? boost::any(coldDataDayGrowthSize->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (coldDataSize) {
      res["ColdDataSize"] = coldDataSize ? boost::any(coldDataSize->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (coldDataSizeDayGrowthRatio) {
      res["ColdDataSizeDayGrowthRatio"] = coldDataSizeDayGrowthRatio ? boost::any(coldDataSizeDayGrowthRatio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (emptyFileCount) {
      res["EmptyFileCount"] = emptyFileCount ? boost::any(emptyFileCount->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (emptyFileCountDayGrowthRatio) {
      res["EmptyFileCountDayGrowthRatio"] = emptyFileCountDayGrowthRatio ? boost::any(emptyFileCountDayGrowthRatio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (emptyFileDayGrowthCount) {
      res["EmptyFileDayGrowthCount"] = emptyFileDayGrowthCount ? boost::any(emptyFileDayGrowthCount->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (freezeDataDayGrowthSize) {
      res["FreezeDataDayGrowthSize"] = freezeDataDayGrowthSize ? boost::any(freezeDataDayGrowthSize->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (freezeDataSize) {
      res["FreezeDataSize"] = freezeDataSize ? boost::any(freezeDataSize->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (freezeDataSizeDayGrowthRatio) {
      res["FreezeDataSizeDayGrowthRatio"] = freezeDataSizeDayGrowthRatio ? boost::any(freezeDataSizeDayGrowthRatio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (hotDataDayGrowthSize) {
      res["HotDataDayGrowthSize"] = hotDataDayGrowthSize ? boost::any(hotDataDayGrowthSize->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (hotDataSize) {
      res["HotDataSize"] = hotDataSize ? boost::any(hotDataSize->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (hotDataSizeDayGrowthRatio) {
      res["HotDataSizeDayGrowthRatio"] = hotDataSizeDayGrowthRatio ? boost::any(hotDataSizeDayGrowthRatio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (largeFileCount) {
      res["LargeFileCount"] = largeFileCount ? boost::any(largeFileCount->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (largeFileCountDayGrowthRatio) {
      res["LargeFileCountDayGrowthRatio"] = largeFileCountDayGrowthRatio ? boost::any(largeFileCountDayGrowthRatio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (largeFileDayGrowthCount) {
      res["LargeFileDayGrowthCount"] = largeFileDayGrowthCount ? boost::any(largeFileDayGrowthCount->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (mediumFileCount) {
      res["MediumFileCount"] = mediumFileCount ? boost::any(mediumFileCount->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (mediumFileCountDayGrowthRatio) {
      res["MediumFileCountDayGrowthRatio"] = mediumFileCountDayGrowthRatio ? boost::any(mediumFileCountDayGrowthRatio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (mediumFileDayGrowthCount) {
      res["MediumFileDayGrowthCount"] = mediumFileDayGrowthCount ? boost::any(mediumFileDayGrowthCount->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (smallFileCount) {
      res["SmallFileCount"] = smallFileCount ? boost::any(smallFileCount->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (smallFileCountDayGrowthRatio) {
      res["SmallFileCountDayGrowthRatio"] = smallFileCountDayGrowthRatio ? boost::any(smallFileCountDayGrowthRatio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (smallFileDayGrowthCount) {
      res["SmallFileDayGrowthCount"] = smallFileDayGrowthCount ? boost::any(smallFileDayGrowthCount->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tinyFileCount) {
      res["TinyFileCount"] = tinyFileCount ? boost::any(tinyFileCount->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tinyFileCountDayGrowthRatio) {
      res["TinyFileCountDayGrowthRatio"] = tinyFileCountDayGrowthRatio ? boost::any(tinyFileCountDayGrowthRatio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tinyFileDayGrowthCount) {
      res["TinyFileDayGrowthCount"] = tinyFileDayGrowthCount ? boost::any(tinyFileDayGrowthCount->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (totalDataDayGrowthSize) {
      res["TotalDataDayGrowthSize"] = totalDataDayGrowthSize ? boost::any(totalDataDayGrowthSize->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (totalDataSize) {
      res["TotalDataSize"] = totalDataSize ? boost::any(totalDataSize->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (totalDataSizeDayGrowthRatio) {
      res["TotalDataSizeDayGrowthRatio"] = totalDataSizeDayGrowthRatio ? boost::any(totalDataSizeDayGrowthRatio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (totalFileCount) {
      res["TotalFileCount"] = totalFileCount ? boost::any(totalFileCount->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (totalFileCountDayGrowthRatio) {
      res["TotalFileCountDayGrowthRatio"] = totalFileCountDayGrowthRatio ? boost::any(totalFileCountDayGrowthRatio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (totalFileDayGrowthCount) {
      res["TotalFileDayGrowthCount"] = totalFileDayGrowthCount ? boost::any(totalFileDayGrowthCount->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (warmDataDayGrowthSize) {
      res["WarmDataDayGrowthSize"] = warmDataDayGrowthSize ? boost::any(warmDataDayGrowthSize->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (warmDataSize) {
      res["WarmDataSize"] = warmDataSize ? boost::any(warmDataSize->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (warmDataSizeDayGrowthRatio) {
      res["WarmDataSizeDayGrowthRatio"] = warmDataSizeDayGrowthRatio ? boost::any(warmDataSizeDayGrowthRatio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ColdDataDayGrowthSize") != m.end() && !m["ColdDataDayGrowthSize"].empty()) {
      if (typeid(map<string, boost::any>) == m["ColdDataDayGrowthSize"].type()) {
        GetDoctorHDFSDirectoryResponseBodyDataMetricsColdDataDayGrowthSize model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ColdDataDayGrowthSize"]));
        coldDataDayGrowthSize = make_shared<GetDoctorHDFSDirectoryResponseBodyDataMetricsColdDataDayGrowthSize>(model1);
      }
    }
    if (m.find("ColdDataSize") != m.end() && !m["ColdDataSize"].empty()) {
      if (typeid(map<string, boost::any>) == m["ColdDataSize"].type()) {
        GetDoctorHDFSDirectoryResponseBodyDataMetricsColdDataSize model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ColdDataSize"]));
        coldDataSize = make_shared<GetDoctorHDFSDirectoryResponseBodyDataMetricsColdDataSize>(model1);
      }
    }
    if (m.find("ColdDataSizeDayGrowthRatio") != m.end() && !m["ColdDataSizeDayGrowthRatio"].empty()) {
      if (typeid(map<string, boost::any>) == m["ColdDataSizeDayGrowthRatio"].type()) {
        GetDoctorHDFSDirectoryResponseBodyDataMetricsColdDataSizeDayGrowthRatio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ColdDataSizeDayGrowthRatio"]));
        coldDataSizeDayGrowthRatio = make_shared<GetDoctorHDFSDirectoryResponseBodyDataMetricsColdDataSizeDayGrowthRatio>(model1);
      }
    }
    if (m.find("EmptyFileCount") != m.end() && !m["EmptyFileCount"].empty()) {
      if (typeid(map<string, boost::any>) == m["EmptyFileCount"].type()) {
        GetDoctorHDFSDirectoryResponseBodyDataMetricsEmptyFileCount model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EmptyFileCount"]));
        emptyFileCount = make_shared<GetDoctorHDFSDirectoryResponseBodyDataMetricsEmptyFileCount>(model1);
      }
    }
    if (m.find("EmptyFileCountDayGrowthRatio") != m.end() && !m["EmptyFileCountDayGrowthRatio"].empty()) {
      if (typeid(map<string, boost::any>) == m["EmptyFileCountDayGrowthRatio"].type()) {
        GetDoctorHDFSDirectoryResponseBodyDataMetricsEmptyFileCountDayGrowthRatio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EmptyFileCountDayGrowthRatio"]));
        emptyFileCountDayGrowthRatio = make_shared<GetDoctorHDFSDirectoryResponseBodyDataMetricsEmptyFileCountDayGrowthRatio>(model1);
      }
    }
    if (m.find("EmptyFileDayGrowthCount") != m.end() && !m["EmptyFileDayGrowthCount"].empty()) {
      if (typeid(map<string, boost::any>) == m["EmptyFileDayGrowthCount"].type()) {
        GetDoctorHDFSDirectoryResponseBodyDataMetricsEmptyFileDayGrowthCount model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EmptyFileDayGrowthCount"]));
        emptyFileDayGrowthCount = make_shared<GetDoctorHDFSDirectoryResponseBodyDataMetricsEmptyFileDayGrowthCount>(model1);
      }
    }
    if (m.find("FreezeDataDayGrowthSize") != m.end() && !m["FreezeDataDayGrowthSize"].empty()) {
      if (typeid(map<string, boost::any>) == m["FreezeDataDayGrowthSize"].type()) {
        GetDoctorHDFSDirectoryResponseBodyDataMetricsFreezeDataDayGrowthSize model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FreezeDataDayGrowthSize"]));
        freezeDataDayGrowthSize = make_shared<GetDoctorHDFSDirectoryResponseBodyDataMetricsFreezeDataDayGrowthSize>(model1);
      }
    }
    if (m.find("FreezeDataSize") != m.end() && !m["FreezeDataSize"].empty()) {
      if (typeid(map<string, boost::any>) == m["FreezeDataSize"].type()) {
        GetDoctorHDFSDirectoryResponseBodyDataMetricsFreezeDataSize model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FreezeDataSize"]));
        freezeDataSize = make_shared<GetDoctorHDFSDirectoryResponseBodyDataMetricsFreezeDataSize>(model1);
      }
    }
    if (m.find("FreezeDataSizeDayGrowthRatio") != m.end() && !m["FreezeDataSizeDayGrowthRatio"].empty()) {
      if (typeid(map<string, boost::any>) == m["FreezeDataSizeDayGrowthRatio"].type()) {
        GetDoctorHDFSDirectoryResponseBodyDataMetricsFreezeDataSizeDayGrowthRatio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FreezeDataSizeDayGrowthRatio"]));
        freezeDataSizeDayGrowthRatio = make_shared<GetDoctorHDFSDirectoryResponseBodyDataMetricsFreezeDataSizeDayGrowthRatio>(model1);
      }
    }
    if (m.find("HotDataDayGrowthSize") != m.end() && !m["HotDataDayGrowthSize"].empty()) {
      if (typeid(map<string, boost::any>) == m["HotDataDayGrowthSize"].type()) {
        GetDoctorHDFSDirectoryResponseBodyDataMetricsHotDataDayGrowthSize model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["HotDataDayGrowthSize"]));
        hotDataDayGrowthSize = make_shared<GetDoctorHDFSDirectoryResponseBodyDataMetricsHotDataDayGrowthSize>(model1);
      }
    }
    if (m.find("HotDataSize") != m.end() && !m["HotDataSize"].empty()) {
      if (typeid(map<string, boost::any>) == m["HotDataSize"].type()) {
        GetDoctorHDFSDirectoryResponseBodyDataMetricsHotDataSize model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["HotDataSize"]));
        hotDataSize = make_shared<GetDoctorHDFSDirectoryResponseBodyDataMetricsHotDataSize>(model1);
      }
    }
    if (m.find("HotDataSizeDayGrowthRatio") != m.end() && !m["HotDataSizeDayGrowthRatio"].empty()) {
      if (typeid(map<string, boost::any>) == m["HotDataSizeDayGrowthRatio"].type()) {
        GetDoctorHDFSDirectoryResponseBodyDataMetricsHotDataSizeDayGrowthRatio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["HotDataSizeDayGrowthRatio"]));
        hotDataSizeDayGrowthRatio = make_shared<GetDoctorHDFSDirectoryResponseBodyDataMetricsHotDataSizeDayGrowthRatio>(model1);
      }
    }
    if (m.find("LargeFileCount") != m.end() && !m["LargeFileCount"].empty()) {
      if (typeid(map<string, boost::any>) == m["LargeFileCount"].type()) {
        GetDoctorHDFSDirectoryResponseBodyDataMetricsLargeFileCount model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LargeFileCount"]));
        largeFileCount = make_shared<GetDoctorHDFSDirectoryResponseBodyDataMetricsLargeFileCount>(model1);
      }
    }
    if (m.find("LargeFileCountDayGrowthRatio") != m.end() && !m["LargeFileCountDayGrowthRatio"].empty()) {
      if (typeid(map<string, boost::any>) == m["LargeFileCountDayGrowthRatio"].type()) {
        GetDoctorHDFSDirectoryResponseBodyDataMetricsLargeFileCountDayGrowthRatio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LargeFileCountDayGrowthRatio"]));
        largeFileCountDayGrowthRatio = make_shared<GetDoctorHDFSDirectoryResponseBodyDataMetricsLargeFileCountDayGrowthRatio>(model1);
      }
    }
    if (m.find("LargeFileDayGrowthCount") != m.end() && !m["LargeFileDayGrowthCount"].empty()) {
      if (typeid(map<string, boost::any>) == m["LargeFileDayGrowthCount"].type()) {
        GetDoctorHDFSDirectoryResponseBodyDataMetricsLargeFileDayGrowthCount model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LargeFileDayGrowthCount"]));
        largeFileDayGrowthCount = make_shared<GetDoctorHDFSDirectoryResponseBodyDataMetricsLargeFileDayGrowthCount>(model1);
      }
    }
    if (m.find("MediumFileCount") != m.end() && !m["MediumFileCount"].empty()) {
      if (typeid(map<string, boost::any>) == m["MediumFileCount"].type()) {
        GetDoctorHDFSDirectoryResponseBodyDataMetricsMediumFileCount model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MediumFileCount"]));
        mediumFileCount = make_shared<GetDoctorHDFSDirectoryResponseBodyDataMetricsMediumFileCount>(model1);
      }
    }
    if (m.find("MediumFileCountDayGrowthRatio") != m.end() && !m["MediumFileCountDayGrowthRatio"].empty()) {
      if (typeid(map<string, boost::any>) == m["MediumFileCountDayGrowthRatio"].type()) {
        GetDoctorHDFSDirectoryResponseBodyDataMetricsMediumFileCountDayGrowthRatio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MediumFileCountDayGrowthRatio"]));
        mediumFileCountDayGrowthRatio = make_shared<GetDoctorHDFSDirectoryResponseBodyDataMetricsMediumFileCountDayGrowthRatio>(model1);
      }
    }
    if (m.find("MediumFileDayGrowthCount") != m.end() && !m["MediumFileDayGrowthCount"].empty()) {
      if (typeid(map<string, boost::any>) == m["MediumFileDayGrowthCount"].type()) {
        GetDoctorHDFSDirectoryResponseBodyDataMetricsMediumFileDayGrowthCount model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MediumFileDayGrowthCount"]));
        mediumFileDayGrowthCount = make_shared<GetDoctorHDFSDirectoryResponseBodyDataMetricsMediumFileDayGrowthCount>(model1);
      }
    }
    if (m.find("SmallFileCount") != m.end() && !m["SmallFileCount"].empty()) {
      if (typeid(map<string, boost::any>) == m["SmallFileCount"].type()) {
        GetDoctorHDFSDirectoryResponseBodyDataMetricsSmallFileCount model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SmallFileCount"]));
        smallFileCount = make_shared<GetDoctorHDFSDirectoryResponseBodyDataMetricsSmallFileCount>(model1);
      }
    }
    if (m.find("SmallFileCountDayGrowthRatio") != m.end() && !m["SmallFileCountDayGrowthRatio"].empty()) {
      if (typeid(map<string, boost::any>) == m["SmallFileCountDayGrowthRatio"].type()) {
        GetDoctorHDFSDirectoryResponseBodyDataMetricsSmallFileCountDayGrowthRatio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SmallFileCountDayGrowthRatio"]));
        smallFileCountDayGrowthRatio = make_shared<GetDoctorHDFSDirectoryResponseBodyDataMetricsSmallFileCountDayGrowthRatio>(model1);
      }
    }
    if (m.find("SmallFileDayGrowthCount") != m.end() && !m["SmallFileDayGrowthCount"].empty()) {
      if (typeid(map<string, boost::any>) == m["SmallFileDayGrowthCount"].type()) {
        GetDoctorHDFSDirectoryResponseBodyDataMetricsSmallFileDayGrowthCount model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SmallFileDayGrowthCount"]));
        smallFileDayGrowthCount = make_shared<GetDoctorHDFSDirectoryResponseBodyDataMetricsSmallFileDayGrowthCount>(model1);
      }
    }
    if (m.find("TinyFileCount") != m.end() && !m["TinyFileCount"].empty()) {
      if (typeid(map<string, boost::any>) == m["TinyFileCount"].type()) {
        GetDoctorHDFSDirectoryResponseBodyDataMetricsTinyFileCount model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TinyFileCount"]));
        tinyFileCount = make_shared<GetDoctorHDFSDirectoryResponseBodyDataMetricsTinyFileCount>(model1);
      }
    }
    if (m.find("TinyFileCountDayGrowthRatio") != m.end() && !m["TinyFileCountDayGrowthRatio"].empty()) {
      if (typeid(map<string, boost::any>) == m["TinyFileCountDayGrowthRatio"].type()) {
        GetDoctorHDFSDirectoryResponseBodyDataMetricsTinyFileCountDayGrowthRatio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TinyFileCountDayGrowthRatio"]));
        tinyFileCountDayGrowthRatio = make_shared<GetDoctorHDFSDirectoryResponseBodyDataMetricsTinyFileCountDayGrowthRatio>(model1);
      }
    }
    if (m.find("TinyFileDayGrowthCount") != m.end() && !m["TinyFileDayGrowthCount"].empty()) {
      if (typeid(map<string, boost::any>) == m["TinyFileDayGrowthCount"].type()) {
        GetDoctorHDFSDirectoryResponseBodyDataMetricsTinyFileDayGrowthCount model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TinyFileDayGrowthCount"]));
        tinyFileDayGrowthCount = make_shared<GetDoctorHDFSDirectoryResponseBodyDataMetricsTinyFileDayGrowthCount>(model1);
      }
    }
    if (m.find("TotalDataDayGrowthSize") != m.end() && !m["TotalDataDayGrowthSize"].empty()) {
      if (typeid(map<string, boost::any>) == m["TotalDataDayGrowthSize"].type()) {
        GetDoctorHDFSDirectoryResponseBodyDataMetricsTotalDataDayGrowthSize model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TotalDataDayGrowthSize"]));
        totalDataDayGrowthSize = make_shared<GetDoctorHDFSDirectoryResponseBodyDataMetricsTotalDataDayGrowthSize>(model1);
      }
    }
    if (m.find("TotalDataSize") != m.end() && !m["TotalDataSize"].empty()) {
      if (typeid(map<string, boost::any>) == m["TotalDataSize"].type()) {
        GetDoctorHDFSDirectoryResponseBodyDataMetricsTotalDataSize model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TotalDataSize"]));
        totalDataSize = make_shared<GetDoctorHDFSDirectoryResponseBodyDataMetricsTotalDataSize>(model1);
      }
    }
    if (m.find("TotalDataSizeDayGrowthRatio") != m.end() && !m["TotalDataSizeDayGrowthRatio"].empty()) {
      if (typeid(map<string, boost::any>) == m["TotalDataSizeDayGrowthRatio"].type()) {
        GetDoctorHDFSDirectoryResponseBodyDataMetricsTotalDataSizeDayGrowthRatio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TotalDataSizeDayGrowthRatio"]));
        totalDataSizeDayGrowthRatio = make_shared<GetDoctorHDFSDirectoryResponseBodyDataMetricsTotalDataSizeDayGrowthRatio>(model1);
      }
    }
    if (m.find("TotalFileCount") != m.end() && !m["TotalFileCount"].empty()) {
      if (typeid(map<string, boost::any>) == m["TotalFileCount"].type()) {
        GetDoctorHDFSDirectoryResponseBodyDataMetricsTotalFileCount model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TotalFileCount"]));
        totalFileCount = make_shared<GetDoctorHDFSDirectoryResponseBodyDataMetricsTotalFileCount>(model1);
      }
    }
    if (m.find("TotalFileCountDayGrowthRatio") != m.end() && !m["TotalFileCountDayGrowthRatio"].empty()) {
      if (typeid(map<string, boost::any>) == m["TotalFileCountDayGrowthRatio"].type()) {
        GetDoctorHDFSDirectoryResponseBodyDataMetricsTotalFileCountDayGrowthRatio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TotalFileCountDayGrowthRatio"]));
        totalFileCountDayGrowthRatio = make_shared<GetDoctorHDFSDirectoryResponseBodyDataMetricsTotalFileCountDayGrowthRatio>(model1);
      }
    }
    if (m.find("TotalFileDayGrowthCount") != m.end() && !m["TotalFileDayGrowthCount"].empty()) {
      if (typeid(map<string, boost::any>) == m["TotalFileDayGrowthCount"].type()) {
        GetDoctorHDFSDirectoryResponseBodyDataMetricsTotalFileDayGrowthCount model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TotalFileDayGrowthCount"]));
        totalFileDayGrowthCount = make_shared<GetDoctorHDFSDirectoryResponseBodyDataMetricsTotalFileDayGrowthCount>(model1);
      }
    }
    if (m.find("WarmDataDayGrowthSize") != m.end() && !m["WarmDataDayGrowthSize"].empty()) {
      if (typeid(map<string, boost::any>) == m["WarmDataDayGrowthSize"].type()) {
        GetDoctorHDFSDirectoryResponseBodyDataMetricsWarmDataDayGrowthSize model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["WarmDataDayGrowthSize"]));
        warmDataDayGrowthSize = make_shared<GetDoctorHDFSDirectoryResponseBodyDataMetricsWarmDataDayGrowthSize>(model1);
      }
    }
    if (m.find("WarmDataSize") != m.end() && !m["WarmDataSize"].empty()) {
      if (typeid(map<string, boost::any>) == m["WarmDataSize"].type()) {
        GetDoctorHDFSDirectoryResponseBodyDataMetricsWarmDataSize model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["WarmDataSize"]));
        warmDataSize = make_shared<GetDoctorHDFSDirectoryResponseBodyDataMetricsWarmDataSize>(model1);
      }
    }
    if (m.find("WarmDataSizeDayGrowthRatio") != m.end() && !m["WarmDataSizeDayGrowthRatio"].empty()) {
      if (typeid(map<string, boost::any>) == m["WarmDataSizeDayGrowthRatio"].type()) {
        GetDoctorHDFSDirectoryResponseBodyDataMetricsWarmDataSizeDayGrowthRatio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["WarmDataSizeDayGrowthRatio"]));
        warmDataSizeDayGrowthRatio = make_shared<GetDoctorHDFSDirectoryResponseBodyDataMetricsWarmDataSizeDayGrowthRatio>(model1);
      }
    }
  }


  virtual ~GetDoctorHDFSDirectoryResponseBodyDataMetrics() = default;
};
class GetDoctorHDFSDirectoryResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> depth{};
  shared_ptr<string> group{};
  shared_ptr<GetDoctorHDFSDirectoryResponseBodyDataMetrics> metrics{};
  shared_ptr<string> user{};

  GetDoctorHDFSDirectoryResponseBodyData() {}

  explicit GetDoctorHDFSDirectoryResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (depth) {
      res["Depth"] = boost::any(*depth);
    }
    if (group) {
      res["Group"] = boost::any(*group);
    }
    if (metrics) {
      res["Metrics"] = metrics ? boost::any(metrics->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (user) {
      res["User"] = boost::any(*user);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Depth") != m.end() && !m["Depth"].empty()) {
      depth = make_shared<long>(boost::any_cast<long>(m["Depth"]));
    }
    if (m.find("Group") != m.end() && !m["Group"].empty()) {
      group = make_shared<string>(boost::any_cast<string>(m["Group"]));
    }
    if (m.find("Metrics") != m.end() && !m["Metrics"].empty()) {
      if (typeid(map<string, boost::any>) == m["Metrics"].type()) {
        GetDoctorHDFSDirectoryResponseBodyDataMetrics model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Metrics"]));
        metrics = make_shared<GetDoctorHDFSDirectoryResponseBodyDataMetrics>(model1);
      }
    }
    if (m.find("User") != m.end() && !m["User"].empty()) {
      user = make_shared<string>(boost::any_cast<string>(m["User"]));
    }
  }


  virtual ~GetDoctorHDFSDirectoryResponseBodyData() = default;
};
class GetDoctorHDFSDirectoryResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetDoctorHDFSDirectoryResponseBodyData> data{};
  shared_ptr<string> requestId{};

  GetDoctorHDFSDirectoryResponseBody() {}

  explicit GetDoctorHDFSDirectoryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetDoctorHDFSDirectoryResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetDoctorHDFSDirectoryResponseBodyData>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetDoctorHDFSDirectoryResponseBody() = default;
};
class GetDoctorHDFSDirectoryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetDoctorHDFSDirectoryResponseBody> body{};

  GetDoctorHDFSDirectoryResponse() {}

  explicit GetDoctorHDFSDirectoryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetDoctorHDFSDirectoryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetDoctorHDFSDirectoryResponseBody>(model1);
      }
    }
  }


  virtual ~GetDoctorHDFSDirectoryResponse() = default;
};
class GetDoctorHDFSUGIRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> dateTime{};
  shared_ptr<string> name{};
  shared_ptr<string> regionId{};
  shared_ptr<string> type{};

  GetDoctorHDFSUGIRequest() {}

  explicit GetDoctorHDFSUGIRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (dateTime) {
      res["DateTime"] = boost::any(*dateTime);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("DateTime") != m.end() && !m["DateTime"].empty()) {
      dateTime = make_shared<string>(boost::any_cast<string>(m["DateTime"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetDoctorHDFSUGIRequest() = default;
};
class GetDoctorHDFSUGIResponseBodyDataMetricsTotalDataSize : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  GetDoctorHDFSUGIResponseBodyDataMetricsTotalDataSize() {}

  explicit GetDoctorHDFSUGIResponseBodyDataMetricsTotalDataSize(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~GetDoctorHDFSUGIResponseBodyDataMetricsTotalDataSize() = default;
};
class GetDoctorHDFSUGIResponseBodyDataMetricsTotalDirCount : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  GetDoctorHDFSUGIResponseBodyDataMetricsTotalDirCount() {}

  explicit GetDoctorHDFSUGIResponseBodyDataMetricsTotalDirCount(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~GetDoctorHDFSUGIResponseBodyDataMetricsTotalDirCount() = default;
};
class GetDoctorHDFSUGIResponseBodyDataMetricsTotalFileCount : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  GetDoctorHDFSUGIResponseBodyDataMetricsTotalFileCount() {}

  explicit GetDoctorHDFSUGIResponseBodyDataMetricsTotalFileCount(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~GetDoctorHDFSUGIResponseBodyDataMetricsTotalFileCount() = default;
};
class GetDoctorHDFSUGIResponseBodyDataMetrics : public Darabonba::Model {
public:
  shared_ptr<GetDoctorHDFSUGIResponseBodyDataMetricsTotalDataSize> totalDataSize{};
  shared_ptr<GetDoctorHDFSUGIResponseBodyDataMetricsTotalDirCount> totalDirCount{};
  shared_ptr<GetDoctorHDFSUGIResponseBodyDataMetricsTotalFileCount> totalFileCount{};

  GetDoctorHDFSUGIResponseBodyDataMetrics() {}

  explicit GetDoctorHDFSUGIResponseBodyDataMetrics(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (totalDataSize) {
      res["TotalDataSize"] = totalDataSize ? boost::any(totalDataSize->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (totalDirCount) {
      res["TotalDirCount"] = totalDirCount ? boost::any(totalDirCount->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (totalFileCount) {
      res["TotalFileCount"] = totalFileCount ? boost::any(totalFileCount->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TotalDataSize") != m.end() && !m["TotalDataSize"].empty()) {
      if (typeid(map<string, boost::any>) == m["TotalDataSize"].type()) {
        GetDoctorHDFSUGIResponseBodyDataMetricsTotalDataSize model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TotalDataSize"]));
        totalDataSize = make_shared<GetDoctorHDFSUGIResponseBodyDataMetricsTotalDataSize>(model1);
      }
    }
    if (m.find("TotalDirCount") != m.end() && !m["TotalDirCount"].empty()) {
      if (typeid(map<string, boost::any>) == m["TotalDirCount"].type()) {
        GetDoctorHDFSUGIResponseBodyDataMetricsTotalDirCount model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TotalDirCount"]));
        totalDirCount = make_shared<GetDoctorHDFSUGIResponseBodyDataMetricsTotalDirCount>(model1);
      }
    }
    if (m.find("TotalFileCount") != m.end() && !m["TotalFileCount"].empty()) {
      if (typeid(map<string, boost::any>) == m["TotalFileCount"].type()) {
        GetDoctorHDFSUGIResponseBodyDataMetricsTotalFileCount model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TotalFileCount"]));
        totalFileCount = make_shared<GetDoctorHDFSUGIResponseBodyDataMetricsTotalFileCount>(model1);
      }
    }
  }


  virtual ~GetDoctorHDFSUGIResponseBodyDataMetrics() = default;
};
class GetDoctorHDFSUGIResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<GetDoctorHDFSUGIResponseBodyDataMetrics> metrics{};

  GetDoctorHDFSUGIResponseBodyData() {}

  explicit GetDoctorHDFSUGIResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (metrics) {
      res["Metrics"] = metrics ? boost::any(metrics->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Metrics") != m.end() && !m["Metrics"].empty()) {
      if (typeid(map<string, boost::any>) == m["Metrics"].type()) {
        GetDoctorHDFSUGIResponseBodyDataMetrics model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Metrics"]));
        metrics = make_shared<GetDoctorHDFSUGIResponseBodyDataMetrics>(model1);
      }
    }
  }


  virtual ~GetDoctorHDFSUGIResponseBodyData() = default;
};
class GetDoctorHDFSUGIResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetDoctorHDFSUGIResponseBodyData> data{};
  shared_ptr<string> requestId{};

  GetDoctorHDFSUGIResponseBody() {}

  explicit GetDoctorHDFSUGIResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetDoctorHDFSUGIResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetDoctorHDFSUGIResponseBodyData>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetDoctorHDFSUGIResponseBody() = default;
};
class GetDoctorHDFSUGIResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetDoctorHDFSUGIResponseBody> body{};

  GetDoctorHDFSUGIResponse() {}

  explicit GetDoctorHDFSUGIResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetDoctorHDFSUGIResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetDoctorHDFSUGIResponseBody>(model1);
      }
    }
  }


  virtual ~GetDoctorHDFSUGIResponse() = default;
};
class GetDoctorHiveClusterRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> dateTime{};
  shared_ptr<string> regionId{};

  GetDoctorHiveClusterRequest() {}

  explicit GetDoctorHiveClusterRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (dateTime) {
      res["DateTime"] = boost::any(*dateTime);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("DateTime") != m.end() && !m["DateTime"].empty()) {
      dateTime = make_shared<string>(boost::any_cast<string>(m["DateTime"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~GetDoctorHiveClusterRequest() = default;
};
class GetDoctorHiveClusterResponseBodyDataAnalysis : public Darabonba::Model {
public:
  shared_ptr<long> hiveDistributionScore{};
  shared_ptr<long> hiveFormatScore{};
  shared_ptr<long> hiveFrequencyScore{};
  shared_ptr<long> hiveScore{};

  GetDoctorHiveClusterResponseBodyDataAnalysis() {}

  explicit GetDoctorHiveClusterResponseBodyDataAnalysis(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hiveDistributionScore) {
      res["HiveDistributionScore"] = boost::any(*hiveDistributionScore);
    }
    if (hiveFormatScore) {
      res["HiveFormatScore"] = boost::any(*hiveFormatScore);
    }
    if (hiveFrequencyScore) {
      res["HiveFrequencyScore"] = boost::any(*hiveFrequencyScore);
    }
    if (hiveScore) {
      res["HiveScore"] = boost::any(*hiveScore);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HiveDistributionScore") != m.end() && !m["HiveDistributionScore"].empty()) {
      hiveDistributionScore = make_shared<long>(boost::any_cast<long>(m["HiveDistributionScore"]));
    }
    if (m.find("HiveFormatScore") != m.end() && !m["HiveFormatScore"].empty()) {
      hiveFormatScore = make_shared<long>(boost::any_cast<long>(m["HiveFormatScore"]));
    }
    if (m.find("HiveFrequencyScore") != m.end() && !m["HiveFrequencyScore"].empty()) {
      hiveFrequencyScore = make_shared<long>(boost::any_cast<long>(m["HiveFrequencyScore"]));
    }
    if (m.find("HiveScore") != m.end() && !m["HiveScore"].empty()) {
      hiveScore = make_shared<long>(boost::any_cast<long>(m["HiveScore"]));
    }
  }


  virtual ~GetDoctorHiveClusterResponseBodyDataAnalysis() = default;
};
class GetDoctorHiveClusterResponseBodyDataFormats : public Darabonba::Model {
public:
  shared_ptr<string> formatName{};
  shared_ptr<double> formatRatio{};
  shared_ptr<long> formatSize{};
  shared_ptr<string> formatSizeUnit{};

  GetDoctorHiveClusterResponseBodyDataFormats() {}

  explicit GetDoctorHiveClusterResponseBodyDataFormats(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (formatName) {
      res["FormatName"] = boost::any(*formatName);
    }
    if (formatRatio) {
      res["FormatRatio"] = boost::any(*formatRatio);
    }
    if (formatSize) {
      res["FormatSize"] = boost::any(*formatSize);
    }
    if (formatSizeUnit) {
      res["FormatSizeUnit"] = boost::any(*formatSizeUnit);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FormatName") != m.end() && !m["FormatName"].empty()) {
      formatName = make_shared<string>(boost::any_cast<string>(m["FormatName"]));
    }
    if (m.find("FormatRatio") != m.end() && !m["FormatRatio"].empty()) {
      formatRatio = make_shared<double>(boost::any_cast<double>(m["FormatRatio"]));
    }
    if (m.find("FormatSize") != m.end() && !m["FormatSize"].empty()) {
      formatSize = make_shared<long>(boost::any_cast<long>(m["FormatSize"]));
    }
    if (m.find("FormatSizeUnit") != m.end() && !m["FormatSizeUnit"].empty()) {
      formatSizeUnit = make_shared<string>(boost::any_cast<string>(m["FormatSizeUnit"]));
    }
  }


  virtual ~GetDoctorHiveClusterResponseBodyDataFormats() = default;
};
class GetDoctorHiveClusterResponseBodyDataMetricsColdDataDayGrowthSize : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  GetDoctorHiveClusterResponseBodyDataMetricsColdDataDayGrowthSize() {}

  explicit GetDoctorHiveClusterResponseBodyDataMetricsColdDataDayGrowthSize(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~GetDoctorHiveClusterResponseBodyDataMetricsColdDataDayGrowthSize() = default;
};
class GetDoctorHiveClusterResponseBodyDataMetricsColdDataRatio : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  GetDoctorHiveClusterResponseBodyDataMetricsColdDataRatio() {}

  explicit GetDoctorHiveClusterResponseBodyDataMetricsColdDataRatio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~GetDoctorHiveClusterResponseBodyDataMetricsColdDataRatio() = default;
};
class GetDoctorHiveClusterResponseBodyDataMetricsColdDataSize : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  GetDoctorHiveClusterResponseBodyDataMetricsColdDataSize() {}

  explicit GetDoctorHiveClusterResponseBodyDataMetricsColdDataSize(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~GetDoctorHiveClusterResponseBodyDataMetricsColdDataSize() = default;
};
class GetDoctorHiveClusterResponseBodyDataMetricsColdDataSizeDayGrowthRatio : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  GetDoctorHiveClusterResponseBodyDataMetricsColdDataSizeDayGrowthRatio() {}

  explicit GetDoctorHiveClusterResponseBodyDataMetricsColdDataSizeDayGrowthRatio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~GetDoctorHiveClusterResponseBodyDataMetricsColdDataSizeDayGrowthRatio() = default;
};
class GetDoctorHiveClusterResponseBodyDataMetricsDatabaseCount : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  GetDoctorHiveClusterResponseBodyDataMetricsDatabaseCount() {}

  explicit GetDoctorHiveClusterResponseBodyDataMetricsDatabaseCount(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~GetDoctorHiveClusterResponseBodyDataMetricsDatabaseCount() = default;
};
class GetDoctorHiveClusterResponseBodyDataMetricsEmptyFileCount : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  GetDoctorHiveClusterResponseBodyDataMetricsEmptyFileCount() {}

  explicit GetDoctorHiveClusterResponseBodyDataMetricsEmptyFileCount(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~GetDoctorHiveClusterResponseBodyDataMetricsEmptyFileCount() = default;
};
class GetDoctorHiveClusterResponseBodyDataMetricsEmptyFileCountDayGrowthRatio : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  GetDoctorHiveClusterResponseBodyDataMetricsEmptyFileCountDayGrowthRatio() {}

  explicit GetDoctorHiveClusterResponseBodyDataMetricsEmptyFileCountDayGrowthRatio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~GetDoctorHiveClusterResponseBodyDataMetricsEmptyFileCountDayGrowthRatio() = default;
};
class GetDoctorHiveClusterResponseBodyDataMetricsEmptyFileDayGrowthCount : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  GetDoctorHiveClusterResponseBodyDataMetricsEmptyFileDayGrowthCount() {}

  explicit GetDoctorHiveClusterResponseBodyDataMetricsEmptyFileDayGrowthCount(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~GetDoctorHiveClusterResponseBodyDataMetricsEmptyFileDayGrowthCount() = default;
};
class GetDoctorHiveClusterResponseBodyDataMetricsEmptyFileRatio : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  GetDoctorHiveClusterResponseBodyDataMetricsEmptyFileRatio() {}

  explicit GetDoctorHiveClusterResponseBodyDataMetricsEmptyFileRatio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~GetDoctorHiveClusterResponseBodyDataMetricsEmptyFileRatio() = default;
};
class GetDoctorHiveClusterResponseBodyDataMetricsFreezeDataDayGrowthSize : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  GetDoctorHiveClusterResponseBodyDataMetricsFreezeDataDayGrowthSize() {}

  explicit GetDoctorHiveClusterResponseBodyDataMetricsFreezeDataDayGrowthSize(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~GetDoctorHiveClusterResponseBodyDataMetricsFreezeDataDayGrowthSize() = default;
};
class GetDoctorHiveClusterResponseBodyDataMetricsFreezeDataRatio : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  GetDoctorHiveClusterResponseBodyDataMetricsFreezeDataRatio() {}

  explicit GetDoctorHiveClusterResponseBodyDataMetricsFreezeDataRatio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~GetDoctorHiveClusterResponseBodyDataMetricsFreezeDataRatio() = default;
};
class GetDoctorHiveClusterResponseBodyDataMetricsFreezeDataSize : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  GetDoctorHiveClusterResponseBodyDataMetricsFreezeDataSize() {}

  explicit GetDoctorHiveClusterResponseBodyDataMetricsFreezeDataSize(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~GetDoctorHiveClusterResponseBodyDataMetricsFreezeDataSize() = default;
};
class GetDoctorHiveClusterResponseBodyDataMetricsFreezeDataSizeDayGrowthRatio : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  GetDoctorHiveClusterResponseBodyDataMetricsFreezeDataSizeDayGrowthRatio() {}

  explicit GetDoctorHiveClusterResponseBodyDataMetricsFreezeDataSizeDayGrowthRatio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~GetDoctorHiveClusterResponseBodyDataMetricsFreezeDataSizeDayGrowthRatio() = default;
};
class GetDoctorHiveClusterResponseBodyDataMetricsHotDataDayGrowthSize : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  GetDoctorHiveClusterResponseBodyDataMetricsHotDataDayGrowthSize() {}

  explicit GetDoctorHiveClusterResponseBodyDataMetricsHotDataDayGrowthSize(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~GetDoctorHiveClusterResponseBodyDataMetricsHotDataDayGrowthSize() = default;
};
class GetDoctorHiveClusterResponseBodyDataMetricsHotDataRatio : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  GetDoctorHiveClusterResponseBodyDataMetricsHotDataRatio() {}

  explicit GetDoctorHiveClusterResponseBodyDataMetricsHotDataRatio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~GetDoctorHiveClusterResponseBodyDataMetricsHotDataRatio() = default;
};
class GetDoctorHiveClusterResponseBodyDataMetricsHotDataSize : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  GetDoctorHiveClusterResponseBodyDataMetricsHotDataSize() {}

  explicit GetDoctorHiveClusterResponseBodyDataMetricsHotDataSize(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~GetDoctorHiveClusterResponseBodyDataMetricsHotDataSize() = default;
};
class GetDoctorHiveClusterResponseBodyDataMetricsHotDataSizeDayGrowthRatio : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  GetDoctorHiveClusterResponseBodyDataMetricsHotDataSizeDayGrowthRatio() {}

  explicit GetDoctorHiveClusterResponseBodyDataMetricsHotDataSizeDayGrowthRatio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~GetDoctorHiveClusterResponseBodyDataMetricsHotDataSizeDayGrowthRatio() = default;
};
class GetDoctorHiveClusterResponseBodyDataMetricsLargeFileCount : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  GetDoctorHiveClusterResponseBodyDataMetricsLargeFileCount() {}

  explicit GetDoctorHiveClusterResponseBodyDataMetricsLargeFileCount(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~GetDoctorHiveClusterResponseBodyDataMetricsLargeFileCount() = default;
};
class GetDoctorHiveClusterResponseBodyDataMetricsLargeFileCountDayGrowthRatio : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  GetDoctorHiveClusterResponseBodyDataMetricsLargeFileCountDayGrowthRatio() {}

  explicit GetDoctorHiveClusterResponseBodyDataMetricsLargeFileCountDayGrowthRatio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~GetDoctorHiveClusterResponseBodyDataMetricsLargeFileCountDayGrowthRatio() = default;
};
class GetDoctorHiveClusterResponseBodyDataMetricsLargeFileDayGrowthCount : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  GetDoctorHiveClusterResponseBodyDataMetricsLargeFileDayGrowthCount() {}

  explicit GetDoctorHiveClusterResponseBodyDataMetricsLargeFileDayGrowthCount(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~GetDoctorHiveClusterResponseBodyDataMetricsLargeFileDayGrowthCount() = default;
};
class GetDoctorHiveClusterResponseBodyDataMetricsLargeFileRatio : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  GetDoctorHiveClusterResponseBodyDataMetricsLargeFileRatio() {}

  explicit GetDoctorHiveClusterResponseBodyDataMetricsLargeFileRatio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~GetDoctorHiveClusterResponseBodyDataMetricsLargeFileRatio() = default;
};
class GetDoctorHiveClusterResponseBodyDataMetricsMediumFileCount : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  GetDoctorHiveClusterResponseBodyDataMetricsMediumFileCount() {}

  explicit GetDoctorHiveClusterResponseBodyDataMetricsMediumFileCount(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~GetDoctorHiveClusterResponseBodyDataMetricsMediumFileCount() = default;
};
class GetDoctorHiveClusterResponseBodyDataMetricsMediumFileCountDayGrowthRatio : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  GetDoctorHiveClusterResponseBodyDataMetricsMediumFileCountDayGrowthRatio() {}

  explicit GetDoctorHiveClusterResponseBodyDataMetricsMediumFileCountDayGrowthRatio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~GetDoctorHiveClusterResponseBodyDataMetricsMediumFileCountDayGrowthRatio() = default;
};
class GetDoctorHiveClusterResponseBodyDataMetricsMediumFileDayGrowthCount : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  GetDoctorHiveClusterResponseBodyDataMetricsMediumFileDayGrowthCount() {}

  explicit GetDoctorHiveClusterResponseBodyDataMetricsMediumFileDayGrowthCount(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~GetDoctorHiveClusterResponseBodyDataMetricsMediumFileDayGrowthCount() = default;
};
class GetDoctorHiveClusterResponseBodyDataMetricsMediumFileRatio : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  GetDoctorHiveClusterResponseBodyDataMetricsMediumFileRatio() {}

  explicit GetDoctorHiveClusterResponseBodyDataMetricsMediumFileRatio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~GetDoctorHiveClusterResponseBodyDataMetricsMediumFileRatio() = default;
};
class GetDoctorHiveClusterResponseBodyDataMetricsPartitionNum : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  GetDoctorHiveClusterResponseBodyDataMetricsPartitionNum() {}

  explicit GetDoctorHiveClusterResponseBodyDataMetricsPartitionNum(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~GetDoctorHiveClusterResponseBodyDataMetricsPartitionNum() = default;
};
class GetDoctorHiveClusterResponseBodyDataMetricsSmallFileCount : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  GetDoctorHiveClusterResponseBodyDataMetricsSmallFileCount() {}

  explicit GetDoctorHiveClusterResponseBodyDataMetricsSmallFileCount(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~GetDoctorHiveClusterResponseBodyDataMetricsSmallFileCount() = default;
};
class GetDoctorHiveClusterResponseBodyDataMetricsSmallFileCountDayGrowthRatio : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  GetDoctorHiveClusterResponseBodyDataMetricsSmallFileCountDayGrowthRatio() {}

  explicit GetDoctorHiveClusterResponseBodyDataMetricsSmallFileCountDayGrowthRatio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~GetDoctorHiveClusterResponseBodyDataMetricsSmallFileCountDayGrowthRatio() = default;
};
class GetDoctorHiveClusterResponseBodyDataMetricsSmallFileDayGrowthCount : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  GetDoctorHiveClusterResponseBodyDataMetricsSmallFileDayGrowthCount() {}

  explicit GetDoctorHiveClusterResponseBodyDataMetricsSmallFileDayGrowthCount(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~GetDoctorHiveClusterResponseBodyDataMetricsSmallFileDayGrowthCount() = default;
};
class GetDoctorHiveClusterResponseBodyDataMetricsSmallFileRatio : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  GetDoctorHiveClusterResponseBodyDataMetricsSmallFileRatio() {}

  explicit GetDoctorHiveClusterResponseBodyDataMetricsSmallFileRatio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~GetDoctorHiveClusterResponseBodyDataMetricsSmallFileRatio() = default;
};
class GetDoctorHiveClusterResponseBodyDataMetricsTableCount : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  GetDoctorHiveClusterResponseBodyDataMetricsTableCount() {}

  explicit GetDoctorHiveClusterResponseBodyDataMetricsTableCount(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~GetDoctorHiveClusterResponseBodyDataMetricsTableCount() = default;
};
class GetDoctorHiveClusterResponseBodyDataMetricsTinyFileCount : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  GetDoctorHiveClusterResponseBodyDataMetricsTinyFileCount() {}

  explicit GetDoctorHiveClusterResponseBodyDataMetricsTinyFileCount(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~GetDoctorHiveClusterResponseBodyDataMetricsTinyFileCount() = default;
};
class GetDoctorHiveClusterResponseBodyDataMetricsTinyFileCountDayGrowthRatio : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  GetDoctorHiveClusterResponseBodyDataMetricsTinyFileCountDayGrowthRatio() {}

  explicit GetDoctorHiveClusterResponseBodyDataMetricsTinyFileCountDayGrowthRatio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~GetDoctorHiveClusterResponseBodyDataMetricsTinyFileCountDayGrowthRatio() = default;
};
class GetDoctorHiveClusterResponseBodyDataMetricsTinyFileDayGrowthCount : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  GetDoctorHiveClusterResponseBodyDataMetricsTinyFileDayGrowthCount() {}

  explicit GetDoctorHiveClusterResponseBodyDataMetricsTinyFileDayGrowthCount(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~GetDoctorHiveClusterResponseBodyDataMetricsTinyFileDayGrowthCount() = default;
};
class GetDoctorHiveClusterResponseBodyDataMetricsTinyFileRatio : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  GetDoctorHiveClusterResponseBodyDataMetricsTinyFileRatio() {}

  explicit GetDoctorHiveClusterResponseBodyDataMetricsTinyFileRatio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~GetDoctorHiveClusterResponseBodyDataMetricsTinyFileRatio() = default;
};
class GetDoctorHiveClusterResponseBodyDataMetricsTotalDataDayGrowthSize : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  GetDoctorHiveClusterResponseBodyDataMetricsTotalDataDayGrowthSize() {}

  explicit GetDoctorHiveClusterResponseBodyDataMetricsTotalDataDayGrowthSize(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~GetDoctorHiveClusterResponseBodyDataMetricsTotalDataDayGrowthSize() = default;
};
class GetDoctorHiveClusterResponseBodyDataMetricsTotalDataSize : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  GetDoctorHiveClusterResponseBodyDataMetricsTotalDataSize() {}

  explicit GetDoctorHiveClusterResponseBodyDataMetricsTotalDataSize(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~GetDoctorHiveClusterResponseBodyDataMetricsTotalDataSize() = default;
};
class GetDoctorHiveClusterResponseBodyDataMetricsTotalDataSizeDayGrowthRatio : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  GetDoctorHiveClusterResponseBodyDataMetricsTotalDataSizeDayGrowthRatio() {}

  explicit GetDoctorHiveClusterResponseBodyDataMetricsTotalDataSizeDayGrowthRatio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~GetDoctorHiveClusterResponseBodyDataMetricsTotalDataSizeDayGrowthRatio() = default;
};
class GetDoctorHiveClusterResponseBodyDataMetricsTotalFileCount : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  GetDoctorHiveClusterResponseBodyDataMetricsTotalFileCount() {}

  explicit GetDoctorHiveClusterResponseBodyDataMetricsTotalFileCount(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~GetDoctorHiveClusterResponseBodyDataMetricsTotalFileCount() = default;
};
class GetDoctorHiveClusterResponseBodyDataMetricsTotalFileCountDayGrowthRatio : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  GetDoctorHiveClusterResponseBodyDataMetricsTotalFileCountDayGrowthRatio() {}

  explicit GetDoctorHiveClusterResponseBodyDataMetricsTotalFileCountDayGrowthRatio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~GetDoctorHiveClusterResponseBodyDataMetricsTotalFileCountDayGrowthRatio() = default;
};
class GetDoctorHiveClusterResponseBodyDataMetricsTotalFileDayGrowthCount : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  GetDoctorHiveClusterResponseBodyDataMetricsTotalFileDayGrowthCount() {}

  explicit GetDoctorHiveClusterResponseBodyDataMetricsTotalFileDayGrowthCount(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~GetDoctorHiveClusterResponseBodyDataMetricsTotalFileDayGrowthCount() = default;
};
class GetDoctorHiveClusterResponseBodyDataMetricsWarmDataDayGrowthSize : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  GetDoctorHiveClusterResponseBodyDataMetricsWarmDataDayGrowthSize() {}

  explicit GetDoctorHiveClusterResponseBodyDataMetricsWarmDataDayGrowthSize(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~GetDoctorHiveClusterResponseBodyDataMetricsWarmDataDayGrowthSize() = default;
};
class GetDoctorHiveClusterResponseBodyDataMetricsWarmDataRatio : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  GetDoctorHiveClusterResponseBodyDataMetricsWarmDataRatio() {}

  explicit GetDoctorHiveClusterResponseBodyDataMetricsWarmDataRatio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~GetDoctorHiveClusterResponseBodyDataMetricsWarmDataRatio() = default;
};
class GetDoctorHiveClusterResponseBodyDataMetricsWarmDataSize : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  GetDoctorHiveClusterResponseBodyDataMetricsWarmDataSize() {}

  explicit GetDoctorHiveClusterResponseBodyDataMetricsWarmDataSize(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~GetDoctorHiveClusterResponseBodyDataMetricsWarmDataSize() = default;
};
class GetDoctorHiveClusterResponseBodyDataMetricsWarmDataSizeDayGrowthRatio : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  GetDoctorHiveClusterResponseBodyDataMetricsWarmDataSizeDayGrowthRatio() {}

  explicit GetDoctorHiveClusterResponseBodyDataMetricsWarmDataSizeDayGrowthRatio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~GetDoctorHiveClusterResponseBodyDataMetricsWarmDataSizeDayGrowthRatio() = default;
};
class GetDoctorHiveClusterResponseBodyDataMetrics : public Darabonba::Model {
public:
  shared_ptr<GetDoctorHiveClusterResponseBodyDataMetricsColdDataDayGrowthSize> coldDataDayGrowthSize{};
  shared_ptr<GetDoctorHiveClusterResponseBodyDataMetricsColdDataRatio> coldDataRatio{};
  shared_ptr<GetDoctorHiveClusterResponseBodyDataMetricsColdDataSize> coldDataSize{};
  shared_ptr<GetDoctorHiveClusterResponseBodyDataMetricsColdDataSizeDayGrowthRatio> coldDataSizeDayGrowthRatio{};
  shared_ptr<GetDoctorHiveClusterResponseBodyDataMetricsDatabaseCount> databaseCount{};
  shared_ptr<GetDoctorHiveClusterResponseBodyDataMetricsEmptyFileCount> emptyFileCount{};
  shared_ptr<GetDoctorHiveClusterResponseBodyDataMetricsEmptyFileCountDayGrowthRatio> emptyFileCountDayGrowthRatio{};
  shared_ptr<GetDoctorHiveClusterResponseBodyDataMetricsEmptyFileDayGrowthCount> emptyFileDayGrowthCount{};
  shared_ptr<GetDoctorHiveClusterResponseBodyDataMetricsEmptyFileRatio> emptyFileRatio{};
  shared_ptr<GetDoctorHiveClusterResponseBodyDataMetricsFreezeDataDayGrowthSize> freezeDataDayGrowthSize{};
  shared_ptr<GetDoctorHiveClusterResponseBodyDataMetricsFreezeDataRatio> freezeDataRatio{};
  shared_ptr<GetDoctorHiveClusterResponseBodyDataMetricsFreezeDataSize> freezeDataSize{};
  shared_ptr<GetDoctorHiveClusterResponseBodyDataMetricsFreezeDataSizeDayGrowthRatio> freezeDataSizeDayGrowthRatio{};
  shared_ptr<GetDoctorHiveClusterResponseBodyDataMetricsHotDataDayGrowthSize> hotDataDayGrowthSize{};
  shared_ptr<GetDoctorHiveClusterResponseBodyDataMetricsHotDataRatio> hotDataRatio{};
  shared_ptr<GetDoctorHiveClusterResponseBodyDataMetricsHotDataSize> hotDataSize{};
  shared_ptr<GetDoctorHiveClusterResponseBodyDataMetricsHotDataSizeDayGrowthRatio> hotDataSizeDayGrowthRatio{};
  shared_ptr<GetDoctorHiveClusterResponseBodyDataMetricsLargeFileCount> largeFileCount{};
  shared_ptr<GetDoctorHiveClusterResponseBodyDataMetricsLargeFileCountDayGrowthRatio> largeFileCountDayGrowthRatio{};
  shared_ptr<GetDoctorHiveClusterResponseBodyDataMetricsLargeFileDayGrowthCount> largeFileDayGrowthCount{};
  shared_ptr<GetDoctorHiveClusterResponseBodyDataMetricsLargeFileRatio> largeFileRatio{};
  shared_ptr<GetDoctorHiveClusterResponseBodyDataMetricsMediumFileCount> mediumFileCount{};
  shared_ptr<GetDoctorHiveClusterResponseBodyDataMetricsMediumFileCountDayGrowthRatio> mediumFileCountDayGrowthRatio{};
  shared_ptr<GetDoctorHiveClusterResponseBodyDataMetricsMediumFileDayGrowthCount> mediumFileDayGrowthCount{};
  shared_ptr<GetDoctorHiveClusterResponseBodyDataMetricsMediumFileRatio> mediumFileRatio{};
  shared_ptr<GetDoctorHiveClusterResponseBodyDataMetricsPartitionNum> partitionNum{};
  shared_ptr<GetDoctorHiveClusterResponseBodyDataMetricsSmallFileCount> smallFileCount{};
  shared_ptr<GetDoctorHiveClusterResponseBodyDataMetricsSmallFileCountDayGrowthRatio> smallFileCountDayGrowthRatio{};
  shared_ptr<GetDoctorHiveClusterResponseBodyDataMetricsSmallFileDayGrowthCount> smallFileDayGrowthCount{};
  shared_ptr<GetDoctorHiveClusterResponseBodyDataMetricsSmallFileRatio> smallFileRatio{};
  shared_ptr<GetDoctorHiveClusterResponseBodyDataMetricsTableCount> tableCount{};
  shared_ptr<GetDoctorHiveClusterResponseBodyDataMetricsTinyFileCount> tinyFileCount{};
  shared_ptr<GetDoctorHiveClusterResponseBodyDataMetricsTinyFileCountDayGrowthRatio> tinyFileCountDayGrowthRatio{};
  shared_ptr<GetDoctorHiveClusterResponseBodyDataMetricsTinyFileDayGrowthCount> tinyFileDayGrowthCount{};
  shared_ptr<GetDoctorHiveClusterResponseBodyDataMetricsTinyFileRatio> tinyFileRatio{};
  shared_ptr<GetDoctorHiveClusterResponseBodyDataMetricsTotalDataDayGrowthSize> totalDataDayGrowthSize{};
  shared_ptr<GetDoctorHiveClusterResponseBodyDataMetricsTotalDataSize> totalDataSize{};
  shared_ptr<GetDoctorHiveClusterResponseBodyDataMetricsTotalDataSizeDayGrowthRatio> totalDataSizeDayGrowthRatio{};
  shared_ptr<GetDoctorHiveClusterResponseBodyDataMetricsTotalFileCount> totalFileCount{};
  shared_ptr<GetDoctorHiveClusterResponseBodyDataMetricsTotalFileCountDayGrowthRatio> totalFileCountDayGrowthRatio{};
  shared_ptr<GetDoctorHiveClusterResponseBodyDataMetricsTotalFileDayGrowthCount> totalFileDayGrowthCount{};
  shared_ptr<GetDoctorHiveClusterResponseBodyDataMetricsWarmDataDayGrowthSize> warmDataDayGrowthSize{};
  shared_ptr<GetDoctorHiveClusterResponseBodyDataMetricsWarmDataRatio> warmDataRatio{};
  shared_ptr<GetDoctorHiveClusterResponseBodyDataMetricsWarmDataSize> warmDataSize{};
  shared_ptr<GetDoctorHiveClusterResponseBodyDataMetricsWarmDataSizeDayGrowthRatio> warmDataSizeDayGrowthRatio{};

  GetDoctorHiveClusterResponseBodyDataMetrics() {}

  explicit GetDoctorHiveClusterResponseBodyDataMetrics(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (coldDataDayGrowthSize) {
      res["ColdDataDayGrowthSize"] = coldDataDayGrowthSize ? boost::any(coldDataDayGrowthSize->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (coldDataRatio) {
      res["ColdDataRatio"] = coldDataRatio ? boost::any(coldDataRatio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (coldDataSize) {
      res["ColdDataSize"] = coldDataSize ? boost::any(coldDataSize->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (coldDataSizeDayGrowthRatio) {
      res["ColdDataSizeDayGrowthRatio"] = coldDataSizeDayGrowthRatio ? boost::any(coldDataSizeDayGrowthRatio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (databaseCount) {
      res["DatabaseCount"] = databaseCount ? boost::any(databaseCount->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (emptyFileCount) {
      res["EmptyFileCount"] = emptyFileCount ? boost::any(emptyFileCount->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (emptyFileCountDayGrowthRatio) {
      res["EmptyFileCountDayGrowthRatio"] = emptyFileCountDayGrowthRatio ? boost::any(emptyFileCountDayGrowthRatio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (emptyFileDayGrowthCount) {
      res["EmptyFileDayGrowthCount"] = emptyFileDayGrowthCount ? boost::any(emptyFileDayGrowthCount->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (emptyFileRatio) {
      res["EmptyFileRatio"] = emptyFileRatio ? boost::any(emptyFileRatio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (freezeDataDayGrowthSize) {
      res["FreezeDataDayGrowthSize"] = freezeDataDayGrowthSize ? boost::any(freezeDataDayGrowthSize->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (freezeDataRatio) {
      res["FreezeDataRatio"] = freezeDataRatio ? boost::any(freezeDataRatio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (freezeDataSize) {
      res["FreezeDataSize"] = freezeDataSize ? boost::any(freezeDataSize->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (freezeDataSizeDayGrowthRatio) {
      res["FreezeDataSizeDayGrowthRatio"] = freezeDataSizeDayGrowthRatio ? boost::any(freezeDataSizeDayGrowthRatio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (hotDataDayGrowthSize) {
      res["HotDataDayGrowthSize"] = hotDataDayGrowthSize ? boost::any(hotDataDayGrowthSize->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (hotDataRatio) {
      res["HotDataRatio"] = hotDataRatio ? boost::any(hotDataRatio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (hotDataSize) {
      res["HotDataSize"] = hotDataSize ? boost::any(hotDataSize->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (hotDataSizeDayGrowthRatio) {
      res["HotDataSizeDayGrowthRatio"] = hotDataSizeDayGrowthRatio ? boost::any(hotDataSizeDayGrowthRatio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (largeFileCount) {
      res["LargeFileCount"] = largeFileCount ? boost::any(largeFileCount->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (largeFileCountDayGrowthRatio) {
      res["LargeFileCountDayGrowthRatio"] = largeFileCountDayGrowthRatio ? boost::any(largeFileCountDayGrowthRatio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (largeFileDayGrowthCount) {
      res["LargeFileDayGrowthCount"] = largeFileDayGrowthCount ? boost::any(largeFileDayGrowthCount->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (largeFileRatio) {
      res["LargeFileRatio"] = largeFileRatio ? boost::any(largeFileRatio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (mediumFileCount) {
      res["MediumFileCount"] = mediumFileCount ? boost::any(mediumFileCount->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (mediumFileCountDayGrowthRatio) {
      res["MediumFileCountDayGrowthRatio"] = mediumFileCountDayGrowthRatio ? boost::any(mediumFileCountDayGrowthRatio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (mediumFileDayGrowthCount) {
      res["MediumFileDayGrowthCount"] = mediumFileDayGrowthCount ? boost::any(mediumFileDayGrowthCount->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (mediumFileRatio) {
      res["MediumFileRatio"] = mediumFileRatio ? boost::any(mediumFileRatio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (partitionNum) {
      res["PartitionNum"] = partitionNum ? boost::any(partitionNum->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (smallFileCount) {
      res["SmallFileCount"] = smallFileCount ? boost::any(smallFileCount->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (smallFileCountDayGrowthRatio) {
      res["SmallFileCountDayGrowthRatio"] = smallFileCountDayGrowthRatio ? boost::any(smallFileCountDayGrowthRatio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (smallFileDayGrowthCount) {
      res["SmallFileDayGrowthCount"] = smallFileDayGrowthCount ? boost::any(smallFileDayGrowthCount->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (smallFileRatio) {
      res["SmallFileRatio"] = smallFileRatio ? boost::any(smallFileRatio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tableCount) {
      res["TableCount"] = tableCount ? boost::any(tableCount->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tinyFileCount) {
      res["TinyFileCount"] = tinyFileCount ? boost::any(tinyFileCount->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tinyFileCountDayGrowthRatio) {
      res["TinyFileCountDayGrowthRatio"] = tinyFileCountDayGrowthRatio ? boost::any(tinyFileCountDayGrowthRatio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tinyFileDayGrowthCount) {
      res["TinyFileDayGrowthCount"] = tinyFileDayGrowthCount ? boost::any(tinyFileDayGrowthCount->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tinyFileRatio) {
      res["TinyFileRatio"] = tinyFileRatio ? boost::any(tinyFileRatio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (totalDataDayGrowthSize) {
      res["TotalDataDayGrowthSize"] = totalDataDayGrowthSize ? boost::any(totalDataDayGrowthSize->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (totalDataSize) {
      res["TotalDataSize"] = totalDataSize ? boost::any(totalDataSize->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (totalDataSizeDayGrowthRatio) {
      res["TotalDataSizeDayGrowthRatio"] = totalDataSizeDayGrowthRatio ? boost::any(totalDataSizeDayGrowthRatio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (totalFileCount) {
      res["TotalFileCount"] = totalFileCount ? boost::any(totalFileCount->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (totalFileCountDayGrowthRatio) {
      res["TotalFileCountDayGrowthRatio"] = totalFileCountDayGrowthRatio ? boost::any(totalFileCountDayGrowthRatio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (totalFileDayGrowthCount) {
      res["TotalFileDayGrowthCount"] = totalFileDayGrowthCount ? boost::any(totalFileDayGrowthCount->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (warmDataDayGrowthSize) {
      res["WarmDataDayGrowthSize"] = warmDataDayGrowthSize ? boost::any(warmDataDayGrowthSize->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (warmDataRatio) {
      res["WarmDataRatio"] = warmDataRatio ? boost::any(warmDataRatio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (warmDataSize) {
      res["WarmDataSize"] = warmDataSize ? boost::any(warmDataSize->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (warmDataSizeDayGrowthRatio) {
      res["WarmDataSizeDayGrowthRatio"] = warmDataSizeDayGrowthRatio ? boost::any(warmDataSizeDayGrowthRatio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ColdDataDayGrowthSize") != m.end() && !m["ColdDataDayGrowthSize"].empty()) {
      if (typeid(map<string, boost::any>) == m["ColdDataDayGrowthSize"].type()) {
        GetDoctorHiveClusterResponseBodyDataMetricsColdDataDayGrowthSize model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ColdDataDayGrowthSize"]));
        coldDataDayGrowthSize = make_shared<GetDoctorHiveClusterResponseBodyDataMetricsColdDataDayGrowthSize>(model1);
      }
    }
    if (m.find("ColdDataRatio") != m.end() && !m["ColdDataRatio"].empty()) {
      if (typeid(map<string, boost::any>) == m["ColdDataRatio"].type()) {
        GetDoctorHiveClusterResponseBodyDataMetricsColdDataRatio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ColdDataRatio"]));
        coldDataRatio = make_shared<GetDoctorHiveClusterResponseBodyDataMetricsColdDataRatio>(model1);
      }
    }
    if (m.find("ColdDataSize") != m.end() && !m["ColdDataSize"].empty()) {
      if (typeid(map<string, boost::any>) == m["ColdDataSize"].type()) {
        GetDoctorHiveClusterResponseBodyDataMetricsColdDataSize model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ColdDataSize"]));
        coldDataSize = make_shared<GetDoctorHiveClusterResponseBodyDataMetricsColdDataSize>(model1);
      }
    }
    if (m.find("ColdDataSizeDayGrowthRatio") != m.end() && !m["ColdDataSizeDayGrowthRatio"].empty()) {
      if (typeid(map<string, boost::any>) == m["ColdDataSizeDayGrowthRatio"].type()) {
        GetDoctorHiveClusterResponseBodyDataMetricsColdDataSizeDayGrowthRatio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ColdDataSizeDayGrowthRatio"]));
        coldDataSizeDayGrowthRatio = make_shared<GetDoctorHiveClusterResponseBodyDataMetricsColdDataSizeDayGrowthRatio>(model1);
      }
    }
    if (m.find("DatabaseCount") != m.end() && !m["DatabaseCount"].empty()) {
      if (typeid(map<string, boost::any>) == m["DatabaseCount"].type()) {
        GetDoctorHiveClusterResponseBodyDataMetricsDatabaseCount model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DatabaseCount"]));
        databaseCount = make_shared<GetDoctorHiveClusterResponseBodyDataMetricsDatabaseCount>(model1);
      }
    }
    if (m.find("EmptyFileCount") != m.end() && !m["EmptyFileCount"].empty()) {
      if (typeid(map<string, boost::any>) == m["EmptyFileCount"].type()) {
        GetDoctorHiveClusterResponseBodyDataMetricsEmptyFileCount model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EmptyFileCount"]));
        emptyFileCount = make_shared<GetDoctorHiveClusterResponseBodyDataMetricsEmptyFileCount>(model1);
      }
    }
    if (m.find("EmptyFileCountDayGrowthRatio") != m.end() && !m["EmptyFileCountDayGrowthRatio"].empty()) {
      if (typeid(map<string, boost::any>) == m["EmptyFileCountDayGrowthRatio"].type()) {
        GetDoctorHiveClusterResponseBodyDataMetricsEmptyFileCountDayGrowthRatio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EmptyFileCountDayGrowthRatio"]));
        emptyFileCountDayGrowthRatio = make_shared<GetDoctorHiveClusterResponseBodyDataMetricsEmptyFileCountDayGrowthRatio>(model1);
      }
    }
    if (m.find("EmptyFileDayGrowthCount") != m.end() && !m["EmptyFileDayGrowthCount"].empty()) {
      if (typeid(map<string, boost::any>) == m["EmptyFileDayGrowthCount"].type()) {
        GetDoctorHiveClusterResponseBodyDataMetricsEmptyFileDayGrowthCount model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EmptyFileDayGrowthCount"]));
        emptyFileDayGrowthCount = make_shared<GetDoctorHiveClusterResponseBodyDataMetricsEmptyFileDayGrowthCount>(model1);
      }
    }
    if (m.find("EmptyFileRatio") != m.end() && !m["EmptyFileRatio"].empty()) {
      if (typeid(map<string, boost::any>) == m["EmptyFileRatio"].type()) {
        GetDoctorHiveClusterResponseBodyDataMetricsEmptyFileRatio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EmptyFileRatio"]));
        emptyFileRatio = make_shared<GetDoctorHiveClusterResponseBodyDataMetricsEmptyFileRatio>(model1);
      }
    }
    if (m.find("FreezeDataDayGrowthSize") != m.end() && !m["FreezeDataDayGrowthSize"].empty()) {
      if (typeid(map<string, boost::any>) == m["FreezeDataDayGrowthSize"].type()) {
        GetDoctorHiveClusterResponseBodyDataMetricsFreezeDataDayGrowthSize model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FreezeDataDayGrowthSize"]));
        freezeDataDayGrowthSize = make_shared<GetDoctorHiveClusterResponseBodyDataMetricsFreezeDataDayGrowthSize>(model1);
      }
    }
    if (m.find("FreezeDataRatio") != m.end() && !m["FreezeDataRatio"].empty()) {
      if (typeid(map<string, boost::any>) == m["FreezeDataRatio"].type()) {
        GetDoctorHiveClusterResponseBodyDataMetricsFreezeDataRatio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FreezeDataRatio"]));
        freezeDataRatio = make_shared<GetDoctorHiveClusterResponseBodyDataMetricsFreezeDataRatio>(model1);
      }
    }
    if (m.find("FreezeDataSize") != m.end() && !m["FreezeDataSize"].empty()) {
      if (typeid(map<string, boost::any>) == m["FreezeDataSize"].type()) {
        GetDoctorHiveClusterResponseBodyDataMetricsFreezeDataSize model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FreezeDataSize"]));
        freezeDataSize = make_shared<GetDoctorHiveClusterResponseBodyDataMetricsFreezeDataSize>(model1);
      }
    }
    if (m.find("FreezeDataSizeDayGrowthRatio") != m.end() && !m["FreezeDataSizeDayGrowthRatio"].empty()) {
      if (typeid(map<string, boost::any>) == m["FreezeDataSizeDayGrowthRatio"].type()) {
        GetDoctorHiveClusterResponseBodyDataMetricsFreezeDataSizeDayGrowthRatio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FreezeDataSizeDayGrowthRatio"]));
        freezeDataSizeDayGrowthRatio = make_shared<GetDoctorHiveClusterResponseBodyDataMetricsFreezeDataSizeDayGrowthRatio>(model1);
      }
    }
    if (m.find("HotDataDayGrowthSize") != m.end() && !m["HotDataDayGrowthSize"].empty()) {
      if (typeid(map<string, boost::any>) == m["HotDataDayGrowthSize"].type()) {
        GetDoctorHiveClusterResponseBodyDataMetricsHotDataDayGrowthSize model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["HotDataDayGrowthSize"]));
        hotDataDayGrowthSize = make_shared<GetDoctorHiveClusterResponseBodyDataMetricsHotDataDayGrowthSize>(model1);
      }
    }
    if (m.find("HotDataRatio") != m.end() && !m["HotDataRatio"].empty()) {
      if (typeid(map<string, boost::any>) == m["HotDataRatio"].type()) {
        GetDoctorHiveClusterResponseBodyDataMetricsHotDataRatio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["HotDataRatio"]));
        hotDataRatio = make_shared<GetDoctorHiveClusterResponseBodyDataMetricsHotDataRatio>(model1);
      }
    }
    if (m.find("HotDataSize") != m.end() && !m["HotDataSize"].empty()) {
      if (typeid(map<string, boost::any>) == m["HotDataSize"].type()) {
        GetDoctorHiveClusterResponseBodyDataMetricsHotDataSize model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["HotDataSize"]));
        hotDataSize = make_shared<GetDoctorHiveClusterResponseBodyDataMetricsHotDataSize>(model1);
      }
    }
    if (m.find("HotDataSizeDayGrowthRatio") != m.end() && !m["HotDataSizeDayGrowthRatio"].empty()) {
      if (typeid(map<string, boost::any>) == m["HotDataSizeDayGrowthRatio"].type()) {
        GetDoctorHiveClusterResponseBodyDataMetricsHotDataSizeDayGrowthRatio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["HotDataSizeDayGrowthRatio"]));
        hotDataSizeDayGrowthRatio = make_shared<GetDoctorHiveClusterResponseBodyDataMetricsHotDataSizeDayGrowthRatio>(model1);
      }
    }
    if (m.find("LargeFileCount") != m.end() && !m["LargeFileCount"].empty()) {
      if (typeid(map<string, boost::any>) == m["LargeFileCount"].type()) {
        GetDoctorHiveClusterResponseBodyDataMetricsLargeFileCount model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LargeFileCount"]));
        largeFileCount = make_shared<GetDoctorHiveClusterResponseBodyDataMetricsLargeFileCount>(model1);
      }
    }
    if (m.find("LargeFileCountDayGrowthRatio") != m.end() && !m["LargeFileCountDayGrowthRatio"].empty()) {
      if (typeid(map<string, boost::any>) == m["LargeFileCountDayGrowthRatio"].type()) {
        GetDoctorHiveClusterResponseBodyDataMetricsLargeFileCountDayGrowthRatio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LargeFileCountDayGrowthRatio"]));
        largeFileCountDayGrowthRatio = make_shared<GetDoctorHiveClusterResponseBodyDataMetricsLargeFileCountDayGrowthRatio>(model1);
      }
    }
    if (m.find("LargeFileDayGrowthCount") != m.end() && !m["LargeFileDayGrowthCount"].empty()) {
      if (typeid(map<string, boost::any>) == m["LargeFileDayGrowthCount"].type()) {
        GetDoctorHiveClusterResponseBodyDataMetricsLargeFileDayGrowthCount model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LargeFileDayGrowthCount"]));
        largeFileDayGrowthCount = make_shared<GetDoctorHiveClusterResponseBodyDataMetricsLargeFileDayGrowthCount>(model1);
      }
    }
    if (m.find("LargeFileRatio") != m.end() && !m["LargeFileRatio"].empty()) {
      if (typeid(map<string, boost::any>) == m["LargeFileRatio"].type()) {
        GetDoctorHiveClusterResponseBodyDataMetricsLargeFileRatio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LargeFileRatio"]));
        largeFileRatio = make_shared<GetDoctorHiveClusterResponseBodyDataMetricsLargeFileRatio>(model1);
      }
    }
    if (m.find("MediumFileCount") != m.end() && !m["MediumFileCount"].empty()) {
      if (typeid(map<string, boost::any>) == m["MediumFileCount"].type()) {
        GetDoctorHiveClusterResponseBodyDataMetricsMediumFileCount model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MediumFileCount"]));
        mediumFileCount = make_shared<GetDoctorHiveClusterResponseBodyDataMetricsMediumFileCount>(model1);
      }
    }
    if (m.find("MediumFileCountDayGrowthRatio") != m.end() && !m["MediumFileCountDayGrowthRatio"].empty()) {
      if (typeid(map<string, boost::any>) == m["MediumFileCountDayGrowthRatio"].type()) {
        GetDoctorHiveClusterResponseBodyDataMetricsMediumFileCountDayGrowthRatio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MediumFileCountDayGrowthRatio"]));
        mediumFileCountDayGrowthRatio = make_shared<GetDoctorHiveClusterResponseBodyDataMetricsMediumFileCountDayGrowthRatio>(model1);
      }
    }
    if (m.find("MediumFileDayGrowthCount") != m.end() && !m["MediumFileDayGrowthCount"].empty()) {
      if (typeid(map<string, boost::any>) == m["MediumFileDayGrowthCount"].type()) {
        GetDoctorHiveClusterResponseBodyDataMetricsMediumFileDayGrowthCount model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MediumFileDayGrowthCount"]));
        mediumFileDayGrowthCount = make_shared<GetDoctorHiveClusterResponseBodyDataMetricsMediumFileDayGrowthCount>(model1);
      }
    }
    if (m.find("MediumFileRatio") != m.end() && !m["MediumFileRatio"].empty()) {
      if (typeid(map<string, boost::any>) == m["MediumFileRatio"].type()) {
        GetDoctorHiveClusterResponseBodyDataMetricsMediumFileRatio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MediumFileRatio"]));
        mediumFileRatio = make_shared<GetDoctorHiveClusterResponseBodyDataMetricsMediumFileRatio>(model1);
      }
    }
    if (m.find("PartitionNum") != m.end() && !m["PartitionNum"].empty()) {
      if (typeid(map<string, boost::any>) == m["PartitionNum"].type()) {
        GetDoctorHiveClusterResponseBodyDataMetricsPartitionNum model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PartitionNum"]));
        partitionNum = make_shared<GetDoctorHiveClusterResponseBodyDataMetricsPartitionNum>(model1);
      }
    }
    if (m.find("SmallFileCount") != m.end() && !m["SmallFileCount"].empty()) {
      if (typeid(map<string, boost::any>) == m["SmallFileCount"].type()) {
        GetDoctorHiveClusterResponseBodyDataMetricsSmallFileCount model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SmallFileCount"]));
        smallFileCount = make_shared<GetDoctorHiveClusterResponseBodyDataMetricsSmallFileCount>(model1);
      }
    }
    if (m.find("SmallFileCountDayGrowthRatio") != m.end() && !m["SmallFileCountDayGrowthRatio"].empty()) {
      if (typeid(map<string, boost::any>) == m["SmallFileCountDayGrowthRatio"].type()) {
        GetDoctorHiveClusterResponseBodyDataMetricsSmallFileCountDayGrowthRatio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SmallFileCountDayGrowthRatio"]));
        smallFileCountDayGrowthRatio = make_shared<GetDoctorHiveClusterResponseBodyDataMetricsSmallFileCountDayGrowthRatio>(model1);
      }
    }
    if (m.find("SmallFileDayGrowthCount") != m.end() && !m["SmallFileDayGrowthCount"].empty()) {
      if (typeid(map<string, boost::any>) == m["SmallFileDayGrowthCount"].type()) {
        GetDoctorHiveClusterResponseBodyDataMetricsSmallFileDayGrowthCount model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SmallFileDayGrowthCount"]));
        smallFileDayGrowthCount = make_shared<GetDoctorHiveClusterResponseBodyDataMetricsSmallFileDayGrowthCount>(model1);
      }
    }
    if (m.find("SmallFileRatio") != m.end() && !m["SmallFileRatio"].empty()) {
      if (typeid(map<string, boost::any>) == m["SmallFileRatio"].type()) {
        GetDoctorHiveClusterResponseBodyDataMetricsSmallFileRatio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SmallFileRatio"]));
        smallFileRatio = make_shared<GetDoctorHiveClusterResponseBodyDataMetricsSmallFileRatio>(model1);
      }
    }
    if (m.find("TableCount") != m.end() && !m["TableCount"].empty()) {
      if (typeid(map<string, boost::any>) == m["TableCount"].type()) {
        GetDoctorHiveClusterResponseBodyDataMetricsTableCount model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TableCount"]));
        tableCount = make_shared<GetDoctorHiveClusterResponseBodyDataMetricsTableCount>(model1);
      }
    }
    if (m.find("TinyFileCount") != m.end() && !m["TinyFileCount"].empty()) {
      if (typeid(map<string, boost::any>) == m["TinyFileCount"].type()) {
        GetDoctorHiveClusterResponseBodyDataMetricsTinyFileCount model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TinyFileCount"]));
        tinyFileCount = make_shared<GetDoctorHiveClusterResponseBodyDataMetricsTinyFileCount>(model1);
      }
    }
    if (m.find("TinyFileCountDayGrowthRatio") != m.end() && !m["TinyFileCountDayGrowthRatio"].empty()) {
      if (typeid(map<string, boost::any>) == m["TinyFileCountDayGrowthRatio"].type()) {
        GetDoctorHiveClusterResponseBodyDataMetricsTinyFileCountDayGrowthRatio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TinyFileCountDayGrowthRatio"]));
        tinyFileCountDayGrowthRatio = make_shared<GetDoctorHiveClusterResponseBodyDataMetricsTinyFileCountDayGrowthRatio>(model1);
      }
    }
    if (m.find("TinyFileDayGrowthCount") != m.end() && !m["TinyFileDayGrowthCount"].empty()) {
      if (typeid(map<string, boost::any>) == m["TinyFileDayGrowthCount"].type()) {
        GetDoctorHiveClusterResponseBodyDataMetricsTinyFileDayGrowthCount model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TinyFileDayGrowthCount"]));
        tinyFileDayGrowthCount = make_shared<GetDoctorHiveClusterResponseBodyDataMetricsTinyFileDayGrowthCount>(model1);
      }
    }
    if (m.find("TinyFileRatio") != m.end() && !m["TinyFileRatio"].empty()) {
      if (typeid(map<string, boost::any>) == m["TinyFileRatio"].type()) {
        GetDoctorHiveClusterResponseBodyDataMetricsTinyFileRatio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TinyFileRatio"]));
        tinyFileRatio = make_shared<GetDoctorHiveClusterResponseBodyDataMetricsTinyFileRatio>(model1);
      }
    }
    if (m.find("TotalDataDayGrowthSize") != m.end() && !m["TotalDataDayGrowthSize"].empty()) {
      if (typeid(map<string, boost::any>) == m["TotalDataDayGrowthSize"].type()) {
        GetDoctorHiveClusterResponseBodyDataMetricsTotalDataDayGrowthSize model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TotalDataDayGrowthSize"]));
        totalDataDayGrowthSize = make_shared<GetDoctorHiveClusterResponseBodyDataMetricsTotalDataDayGrowthSize>(model1);
      }
    }
    if (m.find("TotalDataSize") != m.end() && !m["TotalDataSize"].empty()) {
      if (typeid(map<string, boost::any>) == m["TotalDataSize"].type()) {
        GetDoctorHiveClusterResponseBodyDataMetricsTotalDataSize model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TotalDataSize"]));
        totalDataSize = make_shared<GetDoctorHiveClusterResponseBodyDataMetricsTotalDataSize>(model1);
      }
    }
    if (m.find("TotalDataSizeDayGrowthRatio") != m.end() && !m["TotalDataSizeDayGrowthRatio"].empty()) {
      if (typeid(map<string, boost::any>) == m["TotalDataSizeDayGrowthRatio"].type()) {
        GetDoctorHiveClusterResponseBodyDataMetricsTotalDataSizeDayGrowthRatio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TotalDataSizeDayGrowthRatio"]));
        totalDataSizeDayGrowthRatio = make_shared<GetDoctorHiveClusterResponseBodyDataMetricsTotalDataSizeDayGrowthRatio>(model1);
      }
    }
    if (m.find("TotalFileCount") != m.end() && !m["TotalFileCount"].empty()) {
      if (typeid(map<string, boost::any>) == m["TotalFileCount"].type()) {
        GetDoctorHiveClusterResponseBodyDataMetricsTotalFileCount model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TotalFileCount"]));
        totalFileCount = make_shared<GetDoctorHiveClusterResponseBodyDataMetricsTotalFileCount>(model1);
      }
    }
    if (m.find("TotalFileCountDayGrowthRatio") != m.end() && !m["TotalFileCountDayGrowthRatio"].empty()) {
      if (typeid(map<string, boost::any>) == m["TotalFileCountDayGrowthRatio"].type()) {
        GetDoctorHiveClusterResponseBodyDataMetricsTotalFileCountDayGrowthRatio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TotalFileCountDayGrowthRatio"]));
        totalFileCountDayGrowthRatio = make_shared<GetDoctorHiveClusterResponseBodyDataMetricsTotalFileCountDayGrowthRatio>(model1);
      }
    }
    if (m.find("TotalFileDayGrowthCount") != m.end() && !m["TotalFileDayGrowthCount"].empty()) {
      if (typeid(map<string, boost::any>) == m["TotalFileDayGrowthCount"].type()) {
        GetDoctorHiveClusterResponseBodyDataMetricsTotalFileDayGrowthCount model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TotalFileDayGrowthCount"]));
        totalFileDayGrowthCount = make_shared<GetDoctorHiveClusterResponseBodyDataMetricsTotalFileDayGrowthCount>(model1);
      }
    }
    if (m.find("WarmDataDayGrowthSize") != m.end() && !m["WarmDataDayGrowthSize"].empty()) {
      if (typeid(map<string, boost::any>) == m["WarmDataDayGrowthSize"].type()) {
        GetDoctorHiveClusterResponseBodyDataMetricsWarmDataDayGrowthSize model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["WarmDataDayGrowthSize"]));
        warmDataDayGrowthSize = make_shared<GetDoctorHiveClusterResponseBodyDataMetricsWarmDataDayGrowthSize>(model1);
      }
    }
    if (m.find("WarmDataRatio") != m.end() && !m["WarmDataRatio"].empty()) {
      if (typeid(map<string, boost::any>) == m["WarmDataRatio"].type()) {
        GetDoctorHiveClusterResponseBodyDataMetricsWarmDataRatio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["WarmDataRatio"]));
        warmDataRatio = make_shared<GetDoctorHiveClusterResponseBodyDataMetricsWarmDataRatio>(model1);
      }
    }
    if (m.find("WarmDataSize") != m.end() && !m["WarmDataSize"].empty()) {
      if (typeid(map<string, boost::any>) == m["WarmDataSize"].type()) {
        GetDoctorHiveClusterResponseBodyDataMetricsWarmDataSize model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["WarmDataSize"]));
        warmDataSize = make_shared<GetDoctorHiveClusterResponseBodyDataMetricsWarmDataSize>(model1);
      }
    }
    if (m.find("WarmDataSizeDayGrowthRatio") != m.end() && !m["WarmDataSizeDayGrowthRatio"].empty()) {
      if (typeid(map<string, boost::any>) == m["WarmDataSizeDayGrowthRatio"].type()) {
        GetDoctorHiveClusterResponseBodyDataMetricsWarmDataSizeDayGrowthRatio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["WarmDataSizeDayGrowthRatio"]));
        warmDataSizeDayGrowthRatio = make_shared<GetDoctorHiveClusterResponseBodyDataMetricsWarmDataSizeDayGrowthRatio>(model1);
      }
    }
  }


  virtual ~GetDoctorHiveClusterResponseBodyDataMetrics() = default;
};
class GetDoctorHiveClusterResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<GetDoctorHiveClusterResponseBodyDataAnalysis> analysis{};
  shared_ptr<vector<GetDoctorHiveClusterResponseBodyDataFormats>> formats{};
  shared_ptr<GetDoctorHiveClusterResponseBodyDataMetrics> metrics{};

  GetDoctorHiveClusterResponseBodyData() {}

  explicit GetDoctorHiveClusterResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (analysis) {
      res["Analysis"] = analysis ? boost::any(analysis->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (formats) {
      vector<boost::any> temp1;
      for(auto item1:*formats){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Formats"] = boost::any(temp1);
    }
    if (metrics) {
      res["Metrics"] = metrics ? boost::any(metrics->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Analysis") != m.end() && !m["Analysis"].empty()) {
      if (typeid(map<string, boost::any>) == m["Analysis"].type()) {
        GetDoctorHiveClusterResponseBodyDataAnalysis model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Analysis"]));
        analysis = make_shared<GetDoctorHiveClusterResponseBodyDataAnalysis>(model1);
      }
    }
    if (m.find("Formats") != m.end() && !m["Formats"].empty()) {
      if (typeid(vector<boost::any>) == m["Formats"].type()) {
        vector<GetDoctorHiveClusterResponseBodyDataFormats> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Formats"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetDoctorHiveClusterResponseBodyDataFormats model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        formats = make_shared<vector<GetDoctorHiveClusterResponseBodyDataFormats>>(expect1);
      }
    }
    if (m.find("Metrics") != m.end() && !m["Metrics"].empty()) {
      if (typeid(map<string, boost::any>) == m["Metrics"].type()) {
        GetDoctorHiveClusterResponseBodyDataMetrics model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Metrics"]));
        metrics = make_shared<GetDoctorHiveClusterResponseBodyDataMetrics>(model1);
      }
    }
  }


  virtual ~GetDoctorHiveClusterResponseBodyData() = default;
};
class GetDoctorHiveClusterResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetDoctorHiveClusterResponseBodyData> data{};
  shared_ptr<string> requestId{};

  GetDoctorHiveClusterResponseBody() {}

  explicit GetDoctorHiveClusterResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetDoctorHiveClusterResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetDoctorHiveClusterResponseBodyData>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetDoctorHiveClusterResponseBody() = default;
};
class GetDoctorHiveClusterResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetDoctorHiveClusterResponseBody> body{};

  GetDoctorHiveClusterResponse() {}

  explicit GetDoctorHiveClusterResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetDoctorHiveClusterResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetDoctorHiveClusterResponseBody>(model1);
      }
    }
  }


  virtual ~GetDoctorHiveClusterResponse() = default;
};
class GetDoctorHiveDatabaseRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> databaseName{};
  shared_ptr<string> dateTime{};
  shared_ptr<string> regionId{};

  GetDoctorHiveDatabaseRequest() {}

  explicit GetDoctorHiveDatabaseRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (databaseName) {
      res["DatabaseName"] = boost::any(*databaseName);
    }
    if (dateTime) {
      res["DateTime"] = boost::any(*dateTime);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("DatabaseName") != m.end() && !m["DatabaseName"].empty()) {
      databaseName = make_shared<string>(boost::any_cast<string>(m["DatabaseName"]));
    }
    if (m.find("DateTime") != m.end() && !m["DateTime"].empty()) {
      dateTime = make_shared<string>(boost::any_cast<string>(m["DateTime"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~GetDoctorHiveDatabaseRequest() = default;
};
class GetDoctorHiveDatabaseResponseBodyDataAnalysis : public Darabonba::Model {
public:
  shared_ptr<long> hiveDistributionScore{};
  shared_ptr<long> hiveFormatScore{};
  shared_ptr<long> hiveFrequencyScore{};
  shared_ptr<long> hiveScore{};

  GetDoctorHiveDatabaseResponseBodyDataAnalysis() {}

  explicit GetDoctorHiveDatabaseResponseBodyDataAnalysis(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hiveDistributionScore) {
      res["HiveDistributionScore"] = boost::any(*hiveDistributionScore);
    }
    if (hiveFormatScore) {
      res["HiveFormatScore"] = boost::any(*hiveFormatScore);
    }
    if (hiveFrequencyScore) {
      res["HiveFrequencyScore"] = boost::any(*hiveFrequencyScore);
    }
    if (hiveScore) {
      res["HiveScore"] = boost::any(*hiveScore);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HiveDistributionScore") != m.end() && !m["HiveDistributionScore"].empty()) {
      hiveDistributionScore = make_shared<long>(boost::any_cast<long>(m["HiveDistributionScore"]));
    }
    if (m.find("HiveFormatScore") != m.end() && !m["HiveFormatScore"].empty()) {
      hiveFormatScore = make_shared<long>(boost::any_cast<long>(m["HiveFormatScore"]));
    }
    if (m.find("HiveFrequencyScore") != m.end() && !m["HiveFrequencyScore"].empty()) {
      hiveFrequencyScore = make_shared<long>(boost::any_cast<long>(m["HiveFrequencyScore"]));
    }
    if (m.find("HiveScore") != m.end() && !m["HiveScore"].empty()) {
      hiveScore = make_shared<long>(boost::any_cast<long>(m["HiveScore"]));
    }
  }


  virtual ~GetDoctorHiveDatabaseResponseBodyDataAnalysis() = default;
};
class GetDoctorHiveDatabaseResponseBodyDataFormats : public Darabonba::Model {
public:
  shared_ptr<long> formatDayGrowthSize{};
  shared_ptr<string> formatName{};
  shared_ptr<double> formatRatio{};
  shared_ptr<long> formatSize{};
  shared_ptr<double> formatSizeDayGrowthRatio{};
  shared_ptr<string> formatSizeUnit{};

  GetDoctorHiveDatabaseResponseBodyDataFormats() {}

  explicit GetDoctorHiveDatabaseResponseBodyDataFormats(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (formatDayGrowthSize) {
      res["FormatDayGrowthSize"] = boost::any(*formatDayGrowthSize);
    }
    if (formatName) {
      res["FormatName"] = boost::any(*formatName);
    }
    if (formatRatio) {
      res["FormatRatio"] = boost::any(*formatRatio);
    }
    if (formatSize) {
      res["FormatSize"] = boost::any(*formatSize);
    }
    if (formatSizeDayGrowthRatio) {
      res["FormatSizeDayGrowthRatio"] = boost::any(*formatSizeDayGrowthRatio);
    }
    if (formatSizeUnit) {
      res["FormatSizeUnit"] = boost::any(*formatSizeUnit);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FormatDayGrowthSize") != m.end() && !m["FormatDayGrowthSize"].empty()) {
      formatDayGrowthSize = make_shared<long>(boost::any_cast<long>(m["FormatDayGrowthSize"]));
    }
    if (m.find("FormatName") != m.end() && !m["FormatName"].empty()) {
      formatName = make_shared<string>(boost::any_cast<string>(m["FormatName"]));
    }
    if (m.find("FormatRatio") != m.end() && !m["FormatRatio"].empty()) {
      formatRatio = make_shared<double>(boost::any_cast<double>(m["FormatRatio"]));
    }
    if (m.find("FormatSize") != m.end() && !m["FormatSize"].empty()) {
      formatSize = make_shared<long>(boost::any_cast<long>(m["FormatSize"]));
    }
    if (m.find("FormatSizeDayGrowthRatio") != m.end() && !m["FormatSizeDayGrowthRatio"].empty()) {
      formatSizeDayGrowthRatio = make_shared<double>(boost::any_cast<double>(m["FormatSizeDayGrowthRatio"]));
    }
    if (m.find("FormatSizeUnit") != m.end() && !m["FormatSizeUnit"].empty()) {
      formatSizeUnit = make_shared<string>(boost::any_cast<string>(m["FormatSizeUnit"]));
    }
  }


  virtual ~GetDoctorHiveDatabaseResponseBodyDataFormats() = default;
};
class GetDoctorHiveDatabaseResponseBodyDataMetricsColdDataDayGrowthSize : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  GetDoctorHiveDatabaseResponseBodyDataMetricsColdDataDayGrowthSize() {}

  explicit GetDoctorHiveDatabaseResponseBodyDataMetricsColdDataDayGrowthSize(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~GetDoctorHiveDatabaseResponseBodyDataMetricsColdDataDayGrowthSize() = default;
};
class GetDoctorHiveDatabaseResponseBodyDataMetricsColdDataRatio : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  GetDoctorHiveDatabaseResponseBodyDataMetricsColdDataRatio() {}

  explicit GetDoctorHiveDatabaseResponseBodyDataMetricsColdDataRatio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~GetDoctorHiveDatabaseResponseBodyDataMetricsColdDataRatio() = default;
};
class GetDoctorHiveDatabaseResponseBodyDataMetricsColdDataSize : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  GetDoctorHiveDatabaseResponseBodyDataMetricsColdDataSize() {}

  explicit GetDoctorHiveDatabaseResponseBodyDataMetricsColdDataSize(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~GetDoctorHiveDatabaseResponseBodyDataMetricsColdDataSize() = default;
};
class GetDoctorHiveDatabaseResponseBodyDataMetricsColdDataSizeDayGrowthRatio : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  GetDoctorHiveDatabaseResponseBodyDataMetricsColdDataSizeDayGrowthRatio() {}

  explicit GetDoctorHiveDatabaseResponseBodyDataMetricsColdDataSizeDayGrowthRatio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~GetDoctorHiveDatabaseResponseBodyDataMetricsColdDataSizeDayGrowthRatio() = default;
};
class GetDoctorHiveDatabaseResponseBodyDataMetricsEmptyFileCount : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  GetDoctorHiveDatabaseResponseBodyDataMetricsEmptyFileCount() {}

  explicit GetDoctorHiveDatabaseResponseBodyDataMetricsEmptyFileCount(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~GetDoctorHiveDatabaseResponseBodyDataMetricsEmptyFileCount() = default;
};
class GetDoctorHiveDatabaseResponseBodyDataMetricsEmptyFileCountDayGrowthRatio : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  GetDoctorHiveDatabaseResponseBodyDataMetricsEmptyFileCountDayGrowthRatio() {}

  explicit GetDoctorHiveDatabaseResponseBodyDataMetricsEmptyFileCountDayGrowthRatio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~GetDoctorHiveDatabaseResponseBodyDataMetricsEmptyFileCountDayGrowthRatio() = default;
};
class GetDoctorHiveDatabaseResponseBodyDataMetricsEmptyFileDayGrowthCount : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  GetDoctorHiveDatabaseResponseBodyDataMetricsEmptyFileDayGrowthCount() {}

  explicit GetDoctorHiveDatabaseResponseBodyDataMetricsEmptyFileDayGrowthCount(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~GetDoctorHiveDatabaseResponseBodyDataMetricsEmptyFileDayGrowthCount() = default;
};
class GetDoctorHiveDatabaseResponseBodyDataMetricsEmptyFileRatio : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  GetDoctorHiveDatabaseResponseBodyDataMetricsEmptyFileRatio() {}

  explicit GetDoctorHiveDatabaseResponseBodyDataMetricsEmptyFileRatio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~GetDoctorHiveDatabaseResponseBodyDataMetricsEmptyFileRatio() = default;
};
class GetDoctorHiveDatabaseResponseBodyDataMetricsFreezeDataDayGrowthSize : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  GetDoctorHiveDatabaseResponseBodyDataMetricsFreezeDataDayGrowthSize() {}

  explicit GetDoctorHiveDatabaseResponseBodyDataMetricsFreezeDataDayGrowthSize(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~GetDoctorHiveDatabaseResponseBodyDataMetricsFreezeDataDayGrowthSize() = default;
};
class GetDoctorHiveDatabaseResponseBodyDataMetricsFreezeDataRatio : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  GetDoctorHiveDatabaseResponseBodyDataMetricsFreezeDataRatio() {}

  explicit GetDoctorHiveDatabaseResponseBodyDataMetricsFreezeDataRatio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~GetDoctorHiveDatabaseResponseBodyDataMetricsFreezeDataRatio() = default;
};
class GetDoctorHiveDatabaseResponseBodyDataMetricsFreezeDataSize : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  GetDoctorHiveDatabaseResponseBodyDataMetricsFreezeDataSize() {}

  explicit GetDoctorHiveDatabaseResponseBodyDataMetricsFreezeDataSize(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~GetDoctorHiveDatabaseResponseBodyDataMetricsFreezeDataSize() = default;
};
class GetDoctorHiveDatabaseResponseBodyDataMetricsFreezeDataSizeDayGrowthRatio : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  GetDoctorHiveDatabaseResponseBodyDataMetricsFreezeDataSizeDayGrowthRatio() {}

  explicit GetDoctorHiveDatabaseResponseBodyDataMetricsFreezeDataSizeDayGrowthRatio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~GetDoctorHiveDatabaseResponseBodyDataMetricsFreezeDataSizeDayGrowthRatio() = default;
};
class GetDoctorHiveDatabaseResponseBodyDataMetricsHotDataDayGrowthSize : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  GetDoctorHiveDatabaseResponseBodyDataMetricsHotDataDayGrowthSize() {}

  explicit GetDoctorHiveDatabaseResponseBodyDataMetricsHotDataDayGrowthSize(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~GetDoctorHiveDatabaseResponseBodyDataMetricsHotDataDayGrowthSize() = default;
};
class GetDoctorHiveDatabaseResponseBodyDataMetricsHotDataRatio : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  GetDoctorHiveDatabaseResponseBodyDataMetricsHotDataRatio() {}

  explicit GetDoctorHiveDatabaseResponseBodyDataMetricsHotDataRatio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~GetDoctorHiveDatabaseResponseBodyDataMetricsHotDataRatio() = default;
};
class GetDoctorHiveDatabaseResponseBodyDataMetricsHotDataSize : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  GetDoctorHiveDatabaseResponseBodyDataMetricsHotDataSize() {}

  explicit GetDoctorHiveDatabaseResponseBodyDataMetricsHotDataSize(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~GetDoctorHiveDatabaseResponseBodyDataMetricsHotDataSize() = default;
};
class GetDoctorHiveDatabaseResponseBodyDataMetricsHotDataSizeDayGrowthRatio : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  GetDoctorHiveDatabaseResponseBodyDataMetricsHotDataSizeDayGrowthRatio() {}

  explicit GetDoctorHiveDatabaseResponseBodyDataMetricsHotDataSizeDayGrowthRatio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~GetDoctorHiveDatabaseResponseBodyDataMetricsHotDataSizeDayGrowthRatio() = default;
};
class GetDoctorHiveDatabaseResponseBodyDataMetricsLargeFileCount : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  GetDoctorHiveDatabaseResponseBodyDataMetricsLargeFileCount() {}

  explicit GetDoctorHiveDatabaseResponseBodyDataMetricsLargeFileCount(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~GetDoctorHiveDatabaseResponseBodyDataMetricsLargeFileCount() = default;
};
class GetDoctorHiveDatabaseResponseBodyDataMetricsLargeFileCountDayGrowthRatio : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  GetDoctorHiveDatabaseResponseBodyDataMetricsLargeFileCountDayGrowthRatio() {}

  explicit GetDoctorHiveDatabaseResponseBodyDataMetricsLargeFileCountDayGrowthRatio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~GetDoctorHiveDatabaseResponseBodyDataMetricsLargeFileCountDayGrowthRatio() = default;
};
class GetDoctorHiveDatabaseResponseBodyDataMetricsLargeFileDayGrowthCount : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  GetDoctorHiveDatabaseResponseBodyDataMetricsLargeFileDayGrowthCount() {}

  explicit GetDoctorHiveDatabaseResponseBodyDataMetricsLargeFileDayGrowthCount(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~GetDoctorHiveDatabaseResponseBodyDataMetricsLargeFileDayGrowthCount() = default;
};
class GetDoctorHiveDatabaseResponseBodyDataMetricsLargeFileRatio : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  GetDoctorHiveDatabaseResponseBodyDataMetricsLargeFileRatio() {}

  explicit GetDoctorHiveDatabaseResponseBodyDataMetricsLargeFileRatio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~GetDoctorHiveDatabaseResponseBodyDataMetricsLargeFileRatio() = default;
};
class GetDoctorHiveDatabaseResponseBodyDataMetricsMediumFileCount : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  GetDoctorHiveDatabaseResponseBodyDataMetricsMediumFileCount() {}

  explicit GetDoctorHiveDatabaseResponseBodyDataMetricsMediumFileCount(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~GetDoctorHiveDatabaseResponseBodyDataMetricsMediumFileCount() = default;
};
class GetDoctorHiveDatabaseResponseBodyDataMetricsMediumFileCountDayGrowthRatio : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  GetDoctorHiveDatabaseResponseBodyDataMetricsMediumFileCountDayGrowthRatio() {}

  explicit GetDoctorHiveDatabaseResponseBodyDataMetricsMediumFileCountDayGrowthRatio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~GetDoctorHiveDatabaseResponseBodyDataMetricsMediumFileCountDayGrowthRatio() = default;
};
class GetDoctorHiveDatabaseResponseBodyDataMetricsMediumFileDayGrowthCount : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  GetDoctorHiveDatabaseResponseBodyDataMetricsMediumFileDayGrowthCount() {}

  explicit GetDoctorHiveDatabaseResponseBodyDataMetricsMediumFileDayGrowthCount(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~GetDoctorHiveDatabaseResponseBodyDataMetricsMediumFileDayGrowthCount() = default;
};
class GetDoctorHiveDatabaseResponseBodyDataMetricsMediumFileRatio : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  GetDoctorHiveDatabaseResponseBodyDataMetricsMediumFileRatio() {}

  explicit GetDoctorHiveDatabaseResponseBodyDataMetricsMediumFileRatio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~GetDoctorHiveDatabaseResponseBodyDataMetricsMediumFileRatio() = default;
};
class GetDoctorHiveDatabaseResponseBodyDataMetricsPartitionNum : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  GetDoctorHiveDatabaseResponseBodyDataMetricsPartitionNum() {}

  explicit GetDoctorHiveDatabaseResponseBodyDataMetricsPartitionNum(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~GetDoctorHiveDatabaseResponseBodyDataMetricsPartitionNum() = default;
};
class GetDoctorHiveDatabaseResponseBodyDataMetricsSmallFileCount : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  GetDoctorHiveDatabaseResponseBodyDataMetricsSmallFileCount() {}

  explicit GetDoctorHiveDatabaseResponseBodyDataMetricsSmallFileCount(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~GetDoctorHiveDatabaseResponseBodyDataMetricsSmallFileCount() = default;
};
class GetDoctorHiveDatabaseResponseBodyDataMetricsSmallFileCountDayGrowthRatio : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  GetDoctorHiveDatabaseResponseBodyDataMetricsSmallFileCountDayGrowthRatio() {}

  explicit GetDoctorHiveDatabaseResponseBodyDataMetricsSmallFileCountDayGrowthRatio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~GetDoctorHiveDatabaseResponseBodyDataMetricsSmallFileCountDayGrowthRatio() = default;
};
class GetDoctorHiveDatabaseResponseBodyDataMetricsSmallFileDayGrowthCount : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  GetDoctorHiveDatabaseResponseBodyDataMetricsSmallFileDayGrowthCount() {}

  explicit GetDoctorHiveDatabaseResponseBodyDataMetricsSmallFileDayGrowthCount(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~GetDoctorHiveDatabaseResponseBodyDataMetricsSmallFileDayGrowthCount() = default;
};
class GetDoctorHiveDatabaseResponseBodyDataMetricsSmallFileRatio : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  GetDoctorHiveDatabaseResponseBodyDataMetricsSmallFileRatio() {}

  explicit GetDoctorHiveDatabaseResponseBodyDataMetricsSmallFileRatio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~GetDoctorHiveDatabaseResponseBodyDataMetricsSmallFileRatio() = default;
};
class GetDoctorHiveDatabaseResponseBodyDataMetricsTableCount : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  GetDoctorHiveDatabaseResponseBodyDataMetricsTableCount() {}

  explicit GetDoctorHiveDatabaseResponseBodyDataMetricsTableCount(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~GetDoctorHiveDatabaseResponseBodyDataMetricsTableCount() = default;
};
class GetDoctorHiveDatabaseResponseBodyDataMetricsTinyFileCount : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  GetDoctorHiveDatabaseResponseBodyDataMetricsTinyFileCount() {}

  explicit GetDoctorHiveDatabaseResponseBodyDataMetricsTinyFileCount(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~GetDoctorHiveDatabaseResponseBodyDataMetricsTinyFileCount() = default;
};
class GetDoctorHiveDatabaseResponseBodyDataMetricsTinyFileCountDayGrowthRatio : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  GetDoctorHiveDatabaseResponseBodyDataMetricsTinyFileCountDayGrowthRatio() {}

  explicit GetDoctorHiveDatabaseResponseBodyDataMetricsTinyFileCountDayGrowthRatio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~GetDoctorHiveDatabaseResponseBodyDataMetricsTinyFileCountDayGrowthRatio() = default;
};
class GetDoctorHiveDatabaseResponseBodyDataMetricsTinyFileDayGrowthCount : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  GetDoctorHiveDatabaseResponseBodyDataMetricsTinyFileDayGrowthCount() {}

  explicit GetDoctorHiveDatabaseResponseBodyDataMetricsTinyFileDayGrowthCount(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~GetDoctorHiveDatabaseResponseBodyDataMetricsTinyFileDayGrowthCount() = default;
};
class GetDoctorHiveDatabaseResponseBodyDataMetricsTinyFileRatio : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  GetDoctorHiveDatabaseResponseBodyDataMetricsTinyFileRatio() {}

  explicit GetDoctorHiveDatabaseResponseBodyDataMetricsTinyFileRatio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~GetDoctorHiveDatabaseResponseBodyDataMetricsTinyFileRatio() = default;
};
class GetDoctorHiveDatabaseResponseBodyDataMetricsTotalDataDayGrowthSize : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  GetDoctorHiveDatabaseResponseBodyDataMetricsTotalDataDayGrowthSize() {}

  explicit GetDoctorHiveDatabaseResponseBodyDataMetricsTotalDataDayGrowthSize(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~GetDoctorHiveDatabaseResponseBodyDataMetricsTotalDataDayGrowthSize() = default;
};
class GetDoctorHiveDatabaseResponseBodyDataMetricsTotalDataSize : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  GetDoctorHiveDatabaseResponseBodyDataMetricsTotalDataSize() {}

  explicit GetDoctorHiveDatabaseResponseBodyDataMetricsTotalDataSize(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~GetDoctorHiveDatabaseResponseBodyDataMetricsTotalDataSize() = default;
};
class GetDoctorHiveDatabaseResponseBodyDataMetricsTotalDataSizeDayGrowthRatio : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  GetDoctorHiveDatabaseResponseBodyDataMetricsTotalDataSizeDayGrowthRatio() {}

  explicit GetDoctorHiveDatabaseResponseBodyDataMetricsTotalDataSizeDayGrowthRatio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~GetDoctorHiveDatabaseResponseBodyDataMetricsTotalDataSizeDayGrowthRatio() = default;
};
class GetDoctorHiveDatabaseResponseBodyDataMetricsTotalFileCount : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  GetDoctorHiveDatabaseResponseBodyDataMetricsTotalFileCount() {}

  explicit GetDoctorHiveDatabaseResponseBodyDataMetricsTotalFileCount(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~GetDoctorHiveDatabaseResponseBodyDataMetricsTotalFileCount() = default;
};
class GetDoctorHiveDatabaseResponseBodyDataMetricsTotalFileCountDayGrowthRatio : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  GetDoctorHiveDatabaseResponseBodyDataMetricsTotalFileCountDayGrowthRatio() {}

  explicit GetDoctorHiveDatabaseResponseBodyDataMetricsTotalFileCountDayGrowthRatio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~GetDoctorHiveDatabaseResponseBodyDataMetricsTotalFileCountDayGrowthRatio() = default;
};
class GetDoctorHiveDatabaseResponseBodyDataMetricsTotalFileDayGrowthCount : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  GetDoctorHiveDatabaseResponseBodyDataMetricsTotalFileDayGrowthCount() {}

  explicit GetDoctorHiveDatabaseResponseBodyDataMetricsTotalFileDayGrowthCount(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~GetDoctorHiveDatabaseResponseBodyDataMetricsTotalFileDayGrowthCount() = default;
};
class GetDoctorHiveDatabaseResponseBodyDataMetricsWarmDataDayGrowthSize : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  GetDoctorHiveDatabaseResponseBodyDataMetricsWarmDataDayGrowthSize() {}

  explicit GetDoctorHiveDatabaseResponseBodyDataMetricsWarmDataDayGrowthSize(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~GetDoctorHiveDatabaseResponseBodyDataMetricsWarmDataDayGrowthSize() = default;
};
class GetDoctorHiveDatabaseResponseBodyDataMetricsWarmDataRatio : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  GetDoctorHiveDatabaseResponseBodyDataMetricsWarmDataRatio() {}

  explicit GetDoctorHiveDatabaseResponseBodyDataMetricsWarmDataRatio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~GetDoctorHiveDatabaseResponseBodyDataMetricsWarmDataRatio() = default;
};
class GetDoctorHiveDatabaseResponseBodyDataMetricsWarmDataSize : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  GetDoctorHiveDatabaseResponseBodyDataMetricsWarmDataSize() {}

  explicit GetDoctorHiveDatabaseResponseBodyDataMetricsWarmDataSize(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~GetDoctorHiveDatabaseResponseBodyDataMetricsWarmDataSize() = default;
};
class GetDoctorHiveDatabaseResponseBodyDataMetricsWarmDataSizeDayGrowthRatio : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  GetDoctorHiveDatabaseResponseBodyDataMetricsWarmDataSizeDayGrowthRatio() {}

  explicit GetDoctorHiveDatabaseResponseBodyDataMetricsWarmDataSizeDayGrowthRatio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~GetDoctorHiveDatabaseResponseBodyDataMetricsWarmDataSizeDayGrowthRatio() = default;
};
class GetDoctorHiveDatabaseResponseBodyDataMetrics : public Darabonba::Model {
public:
  shared_ptr<GetDoctorHiveDatabaseResponseBodyDataMetricsColdDataDayGrowthSize> coldDataDayGrowthSize{};
  shared_ptr<GetDoctorHiveDatabaseResponseBodyDataMetricsColdDataRatio> coldDataRatio{};
  shared_ptr<GetDoctorHiveDatabaseResponseBodyDataMetricsColdDataSize> coldDataSize{};
  shared_ptr<GetDoctorHiveDatabaseResponseBodyDataMetricsColdDataSizeDayGrowthRatio> coldDataSizeDayGrowthRatio{};
  shared_ptr<GetDoctorHiveDatabaseResponseBodyDataMetricsEmptyFileCount> emptyFileCount{};
  shared_ptr<GetDoctorHiveDatabaseResponseBodyDataMetricsEmptyFileCountDayGrowthRatio> emptyFileCountDayGrowthRatio{};
  shared_ptr<GetDoctorHiveDatabaseResponseBodyDataMetricsEmptyFileDayGrowthCount> emptyFileDayGrowthCount{};
  shared_ptr<GetDoctorHiveDatabaseResponseBodyDataMetricsEmptyFileRatio> emptyFileRatio{};
  shared_ptr<GetDoctorHiveDatabaseResponseBodyDataMetricsFreezeDataDayGrowthSize> freezeDataDayGrowthSize{};
  shared_ptr<GetDoctorHiveDatabaseResponseBodyDataMetricsFreezeDataRatio> freezeDataRatio{};
  shared_ptr<GetDoctorHiveDatabaseResponseBodyDataMetricsFreezeDataSize> freezeDataSize{};
  shared_ptr<GetDoctorHiveDatabaseResponseBodyDataMetricsFreezeDataSizeDayGrowthRatio> freezeDataSizeDayGrowthRatio{};
  shared_ptr<GetDoctorHiveDatabaseResponseBodyDataMetricsHotDataDayGrowthSize> hotDataDayGrowthSize{};
  shared_ptr<GetDoctorHiveDatabaseResponseBodyDataMetricsHotDataRatio> hotDataRatio{};
  shared_ptr<GetDoctorHiveDatabaseResponseBodyDataMetricsHotDataSize> hotDataSize{};
  shared_ptr<GetDoctorHiveDatabaseResponseBodyDataMetricsHotDataSizeDayGrowthRatio> hotDataSizeDayGrowthRatio{};
  shared_ptr<GetDoctorHiveDatabaseResponseBodyDataMetricsLargeFileCount> largeFileCount{};
  shared_ptr<GetDoctorHiveDatabaseResponseBodyDataMetricsLargeFileCountDayGrowthRatio> largeFileCountDayGrowthRatio{};
  shared_ptr<GetDoctorHiveDatabaseResponseBodyDataMetricsLargeFileDayGrowthCount> largeFileDayGrowthCount{};
  shared_ptr<GetDoctorHiveDatabaseResponseBodyDataMetricsLargeFileRatio> largeFileRatio{};
  shared_ptr<GetDoctorHiveDatabaseResponseBodyDataMetricsMediumFileCount> mediumFileCount{};
  shared_ptr<GetDoctorHiveDatabaseResponseBodyDataMetricsMediumFileCountDayGrowthRatio> mediumFileCountDayGrowthRatio{};
  shared_ptr<GetDoctorHiveDatabaseResponseBodyDataMetricsMediumFileDayGrowthCount> mediumFileDayGrowthCount{};
  shared_ptr<GetDoctorHiveDatabaseResponseBodyDataMetricsMediumFileRatio> mediumFileRatio{};
  shared_ptr<GetDoctorHiveDatabaseResponseBodyDataMetricsPartitionNum> partitionNum{};
  shared_ptr<GetDoctorHiveDatabaseResponseBodyDataMetricsSmallFileCount> smallFileCount{};
  shared_ptr<GetDoctorHiveDatabaseResponseBodyDataMetricsSmallFileCountDayGrowthRatio> smallFileCountDayGrowthRatio{};
  shared_ptr<GetDoctorHiveDatabaseResponseBodyDataMetricsSmallFileDayGrowthCount> smallFileDayGrowthCount{};
  shared_ptr<GetDoctorHiveDatabaseResponseBodyDataMetricsSmallFileRatio> smallFileRatio{};
  shared_ptr<GetDoctorHiveDatabaseResponseBodyDataMetricsTableCount> tableCount{};
  shared_ptr<GetDoctorHiveDatabaseResponseBodyDataMetricsTinyFileCount> tinyFileCount{};
  shared_ptr<GetDoctorHiveDatabaseResponseBodyDataMetricsTinyFileCountDayGrowthRatio> tinyFileCountDayGrowthRatio{};
  shared_ptr<GetDoctorHiveDatabaseResponseBodyDataMetricsTinyFileDayGrowthCount> tinyFileDayGrowthCount{};
  shared_ptr<GetDoctorHiveDatabaseResponseBodyDataMetricsTinyFileRatio> tinyFileRatio{};
  shared_ptr<GetDoctorHiveDatabaseResponseBodyDataMetricsTotalDataDayGrowthSize> totalDataDayGrowthSize{};
  shared_ptr<GetDoctorHiveDatabaseResponseBodyDataMetricsTotalDataSize> totalDataSize{};
  shared_ptr<GetDoctorHiveDatabaseResponseBodyDataMetricsTotalDataSizeDayGrowthRatio> totalDataSizeDayGrowthRatio{};
  shared_ptr<GetDoctorHiveDatabaseResponseBodyDataMetricsTotalFileCount> totalFileCount{};
  shared_ptr<GetDoctorHiveDatabaseResponseBodyDataMetricsTotalFileCountDayGrowthRatio> totalFileCountDayGrowthRatio{};
  shared_ptr<GetDoctorHiveDatabaseResponseBodyDataMetricsTotalFileDayGrowthCount> totalFileDayGrowthCount{};
  shared_ptr<GetDoctorHiveDatabaseResponseBodyDataMetricsWarmDataDayGrowthSize> warmDataDayGrowthSize{};
  shared_ptr<GetDoctorHiveDatabaseResponseBodyDataMetricsWarmDataRatio> warmDataRatio{};
  shared_ptr<GetDoctorHiveDatabaseResponseBodyDataMetricsWarmDataSize> warmDataSize{};
  shared_ptr<GetDoctorHiveDatabaseResponseBodyDataMetricsWarmDataSizeDayGrowthRatio> warmDataSizeDayGrowthRatio{};

  GetDoctorHiveDatabaseResponseBodyDataMetrics() {}

  explicit GetDoctorHiveDatabaseResponseBodyDataMetrics(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (coldDataDayGrowthSize) {
      res["ColdDataDayGrowthSize"] = coldDataDayGrowthSize ? boost::any(coldDataDayGrowthSize->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (coldDataRatio) {
      res["ColdDataRatio"] = coldDataRatio ? boost::any(coldDataRatio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (coldDataSize) {
      res["ColdDataSize"] = coldDataSize ? boost::any(coldDataSize->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (coldDataSizeDayGrowthRatio) {
      res["ColdDataSizeDayGrowthRatio"] = coldDataSizeDayGrowthRatio ? boost::any(coldDataSizeDayGrowthRatio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (emptyFileCount) {
      res["EmptyFileCount"] = emptyFileCount ? boost::any(emptyFileCount->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (emptyFileCountDayGrowthRatio) {
      res["EmptyFileCountDayGrowthRatio"] = emptyFileCountDayGrowthRatio ? boost::any(emptyFileCountDayGrowthRatio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (emptyFileDayGrowthCount) {
      res["EmptyFileDayGrowthCount"] = emptyFileDayGrowthCount ? boost::any(emptyFileDayGrowthCount->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (emptyFileRatio) {
      res["EmptyFileRatio"] = emptyFileRatio ? boost::any(emptyFileRatio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (freezeDataDayGrowthSize) {
      res["FreezeDataDayGrowthSize"] = freezeDataDayGrowthSize ? boost::any(freezeDataDayGrowthSize->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (freezeDataRatio) {
      res["FreezeDataRatio"] = freezeDataRatio ? boost::any(freezeDataRatio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (freezeDataSize) {
      res["FreezeDataSize"] = freezeDataSize ? boost::any(freezeDataSize->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (freezeDataSizeDayGrowthRatio) {
      res["FreezeDataSizeDayGrowthRatio"] = freezeDataSizeDayGrowthRatio ? boost::any(freezeDataSizeDayGrowthRatio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (hotDataDayGrowthSize) {
      res["HotDataDayGrowthSize"] = hotDataDayGrowthSize ? boost::any(hotDataDayGrowthSize->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (hotDataRatio) {
      res["HotDataRatio"] = hotDataRatio ? boost::any(hotDataRatio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (hotDataSize) {
      res["HotDataSize"] = hotDataSize ? boost::any(hotDataSize->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (hotDataSizeDayGrowthRatio) {
      res["HotDataSizeDayGrowthRatio"] = hotDataSizeDayGrowthRatio ? boost::any(hotDataSizeDayGrowthRatio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (largeFileCount) {
      res["LargeFileCount"] = largeFileCount ? boost::any(largeFileCount->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (largeFileCountDayGrowthRatio) {
      res["LargeFileCountDayGrowthRatio"] = largeFileCountDayGrowthRatio ? boost::any(largeFileCountDayGrowthRatio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (largeFileDayGrowthCount) {
      res["LargeFileDayGrowthCount"] = largeFileDayGrowthCount ? boost::any(largeFileDayGrowthCount->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (largeFileRatio) {
      res["LargeFileRatio"] = largeFileRatio ? boost::any(largeFileRatio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (mediumFileCount) {
      res["MediumFileCount"] = mediumFileCount ? boost::any(mediumFileCount->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (mediumFileCountDayGrowthRatio) {
      res["MediumFileCountDayGrowthRatio"] = mediumFileCountDayGrowthRatio ? boost::any(mediumFileCountDayGrowthRatio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (mediumFileDayGrowthCount) {
      res["MediumFileDayGrowthCount"] = mediumFileDayGrowthCount ? boost::any(mediumFileDayGrowthCount->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (mediumFileRatio) {
      res["MediumFileRatio"] = mediumFileRatio ? boost::any(mediumFileRatio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (partitionNum) {
      res["PartitionNum"] = partitionNum ? boost::any(partitionNum->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (smallFileCount) {
      res["SmallFileCount"] = smallFileCount ? boost::any(smallFileCount->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (smallFileCountDayGrowthRatio) {
      res["SmallFileCountDayGrowthRatio"] = smallFileCountDayGrowthRatio ? boost::any(smallFileCountDayGrowthRatio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (smallFileDayGrowthCount) {
      res["SmallFileDayGrowthCount"] = smallFileDayGrowthCount ? boost::any(smallFileDayGrowthCount->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (smallFileRatio) {
      res["SmallFileRatio"] = smallFileRatio ? boost::any(smallFileRatio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tableCount) {
      res["TableCount"] = tableCount ? boost::any(tableCount->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tinyFileCount) {
      res["TinyFileCount"] = tinyFileCount ? boost::any(tinyFileCount->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tinyFileCountDayGrowthRatio) {
      res["TinyFileCountDayGrowthRatio"] = tinyFileCountDayGrowthRatio ? boost::any(tinyFileCountDayGrowthRatio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tinyFileDayGrowthCount) {
      res["TinyFileDayGrowthCount"] = tinyFileDayGrowthCount ? boost::any(tinyFileDayGrowthCount->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tinyFileRatio) {
      res["TinyFileRatio"] = tinyFileRatio ? boost::any(tinyFileRatio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (totalDataDayGrowthSize) {
      res["TotalDataDayGrowthSize"] = totalDataDayGrowthSize ? boost::any(totalDataDayGrowthSize->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (totalDataSize) {
      res["TotalDataSize"] = totalDataSize ? boost::any(totalDataSize->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (totalDataSizeDayGrowthRatio) {
      res["TotalDataSizeDayGrowthRatio"] = totalDataSizeDayGrowthRatio ? boost::any(totalDataSizeDayGrowthRatio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (totalFileCount) {
      res["TotalFileCount"] = totalFileCount ? boost::any(totalFileCount->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (totalFileCountDayGrowthRatio) {
      res["TotalFileCountDayGrowthRatio"] = totalFileCountDayGrowthRatio ? boost::any(totalFileCountDayGrowthRatio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (totalFileDayGrowthCount) {
      res["TotalFileDayGrowthCount"] = totalFileDayGrowthCount ? boost::any(totalFileDayGrowthCount->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (warmDataDayGrowthSize) {
      res["WarmDataDayGrowthSize"] = warmDataDayGrowthSize ? boost::any(warmDataDayGrowthSize->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (warmDataRatio) {
      res["WarmDataRatio"] = warmDataRatio ? boost::any(warmDataRatio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (warmDataSize) {
      res["WarmDataSize"] = warmDataSize ? boost::any(warmDataSize->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (warmDataSizeDayGrowthRatio) {
      res["WarmDataSizeDayGrowthRatio"] = warmDataSizeDayGrowthRatio ? boost::any(warmDataSizeDayGrowthRatio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ColdDataDayGrowthSize") != m.end() && !m["ColdDataDayGrowthSize"].empty()) {
      if (typeid(map<string, boost::any>) == m["ColdDataDayGrowthSize"].type()) {
        GetDoctorHiveDatabaseResponseBodyDataMetricsColdDataDayGrowthSize model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ColdDataDayGrowthSize"]));
        coldDataDayGrowthSize = make_shared<GetDoctorHiveDatabaseResponseBodyDataMetricsColdDataDayGrowthSize>(model1);
      }
    }
    if (m.find("ColdDataRatio") != m.end() && !m["ColdDataRatio"].empty()) {
      if (typeid(map<string, boost::any>) == m["ColdDataRatio"].type()) {
        GetDoctorHiveDatabaseResponseBodyDataMetricsColdDataRatio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ColdDataRatio"]));
        coldDataRatio = make_shared<GetDoctorHiveDatabaseResponseBodyDataMetricsColdDataRatio>(model1);
      }
    }
    if (m.find("ColdDataSize") != m.end() && !m["ColdDataSize"].empty()) {
      if (typeid(map<string, boost::any>) == m["ColdDataSize"].type()) {
        GetDoctorHiveDatabaseResponseBodyDataMetricsColdDataSize model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ColdDataSize"]));
        coldDataSize = make_shared<GetDoctorHiveDatabaseResponseBodyDataMetricsColdDataSize>(model1);
      }
    }
    if (m.find("ColdDataSizeDayGrowthRatio") != m.end() && !m["ColdDataSizeDayGrowthRatio"].empty()) {
      if (typeid(map<string, boost::any>) == m["ColdDataSizeDayGrowthRatio"].type()) {
        GetDoctorHiveDatabaseResponseBodyDataMetricsColdDataSizeDayGrowthRatio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ColdDataSizeDayGrowthRatio"]));
        coldDataSizeDayGrowthRatio = make_shared<GetDoctorHiveDatabaseResponseBodyDataMetricsColdDataSizeDayGrowthRatio>(model1);
      }
    }
    if (m.find("EmptyFileCount") != m.end() && !m["EmptyFileCount"].empty()) {
      if (typeid(map<string, boost::any>) == m["EmptyFileCount"].type()) {
        GetDoctorHiveDatabaseResponseBodyDataMetricsEmptyFileCount model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EmptyFileCount"]));
        emptyFileCount = make_shared<GetDoctorHiveDatabaseResponseBodyDataMetricsEmptyFileCount>(model1);
      }
    }
    if (m.find("EmptyFileCountDayGrowthRatio") != m.end() && !m["EmptyFileCountDayGrowthRatio"].empty()) {
      if (typeid(map<string, boost::any>) == m["EmptyFileCountDayGrowthRatio"].type()) {
        GetDoctorHiveDatabaseResponseBodyDataMetricsEmptyFileCountDayGrowthRatio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EmptyFileCountDayGrowthRatio"]));
        emptyFileCountDayGrowthRatio = make_shared<GetDoctorHiveDatabaseResponseBodyDataMetricsEmptyFileCountDayGrowthRatio>(model1);
      }
    }
    if (m.find("EmptyFileDayGrowthCount") != m.end() && !m["EmptyFileDayGrowthCount"].empty()) {
      if (typeid(map<string, boost::any>) == m["EmptyFileDayGrowthCount"].type()) {
        GetDoctorHiveDatabaseResponseBodyDataMetricsEmptyFileDayGrowthCount model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EmptyFileDayGrowthCount"]));
        emptyFileDayGrowthCount = make_shared<GetDoctorHiveDatabaseResponseBodyDataMetricsEmptyFileDayGrowthCount>(model1);
      }
    }
    if (m.find("EmptyFileRatio") != m.end() && !m["EmptyFileRatio"].empty()) {
      if (typeid(map<string, boost::any>) == m["EmptyFileRatio"].type()) {
        GetDoctorHiveDatabaseResponseBodyDataMetricsEmptyFileRatio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EmptyFileRatio"]));
        emptyFileRatio = make_shared<GetDoctorHiveDatabaseResponseBodyDataMetricsEmptyFileRatio>(model1);
      }
    }
    if (m.find("FreezeDataDayGrowthSize") != m.end() && !m["FreezeDataDayGrowthSize"].empty()) {
      if (typeid(map<string, boost::any>) == m["FreezeDataDayGrowthSize"].type()) {
        GetDoctorHiveDatabaseResponseBodyDataMetricsFreezeDataDayGrowthSize model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FreezeDataDayGrowthSize"]));
        freezeDataDayGrowthSize = make_shared<GetDoctorHiveDatabaseResponseBodyDataMetricsFreezeDataDayGrowthSize>(model1);
      }
    }
    if (m.find("FreezeDataRatio") != m.end() && !m["FreezeDataRatio"].empty()) {
      if (typeid(map<string, boost::any>) == m["FreezeDataRatio"].type()) {
        GetDoctorHiveDatabaseResponseBodyDataMetricsFreezeDataRatio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FreezeDataRatio"]));
        freezeDataRatio = make_shared<GetDoctorHiveDatabaseResponseBodyDataMetricsFreezeDataRatio>(model1);
      }
    }
    if (m.find("FreezeDataSize") != m.end() && !m["FreezeDataSize"].empty()) {
      if (typeid(map<string, boost::any>) == m["FreezeDataSize"].type()) {
        GetDoctorHiveDatabaseResponseBodyDataMetricsFreezeDataSize model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FreezeDataSize"]));
        freezeDataSize = make_shared<GetDoctorHiveDatabaseResponseBodyDataMetricsFreezeDataSize>(model1);
      }
    }
    if (m.find("FreezeDataSizeDayGrowthRatio") != m.end() && !m["FreezeDataSizeDayGrowthRatio"].empty()) {
      if (typeid(map<string, boost::any>) == m["FreezeDataSizeDayGrowthRatio"].type()) {
        GetDoctorHiveDatabaseResponseBodyDataMetricsFreezeDataSizeDayGrowthRatio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FreezeDataSizeDayGrowthRatio"]));
        freezeDataSizeDayGrowthRatio = make_shared<GetDoctorHiveDatabaseResponseBodyDataMetricsFreezeDataSizeDayGrowthRatio>(model1);
      }
    }
    if (m.find("HotDataDayGrowthSize") != m.end() && !m["HotDataDayGrowthSize"].empty()) {
      if (typeid(map<string, boost::any>) == m["HotDataDayGrowthSize"].type()) {
        GetDoctorHiveDatabaseResponseBodyDataMetricsHotDataDayGrowthSize model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["HotDataDayGrowthSize"]));
        hotDataDayGrowthSize = make_shared<GetDoctorHiveDatabaseResponseBodyDataMetricsHotDataDayGrowthSize>(model1);
      }
    }
    if (m.find("HotDataRatio") != m.end() && !m["HotDataRatio"].empty()) {
      if (typeid(map<string, boost::any>) == m["HotDataRatio"].type()) {
        GetDoctorHiveDatabaseResponseBodyDataMetricsHotDataRatio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["HotDataRatio"]));
        hotDataRatio = make_shared<GetDoctorHiveDatabaseResponseBodyDataMetricsHotDataRatio>(model1);
      }
    }
    if (m.find("HotDataSize") != m.end() && !m["HotDataSize"].empty()) {
      if (typeid(map<string, boost::any>) == m["HotDataSize"].type()) {
        GetDoctorHiveDatabaseResponseBodyDataMetricsHotDataSize model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["HotDataSize"]));
        hotDataSize = make_shared<GetDoctorHiveDatabaseResponseBodyDataMetricsHotDataSize>(model1);
      }
    }
    if (m.find("HotDataSizeDayGrowthRatio") != m.end() && !m["HotDataSizeDayGrowthRatio"].empty()) {
      if (typeid(map<string, boost::any>) == m["HotDataSizeDayGrowthRatio"].type()) {
        GetDoctorHiveDatabaseResponseBodyDataMetricsHotDataSizeDayGrowthRatio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["HotDataSizeDayGrowthRatio"]));
        hotDataSizeDayGrowthRatio = make_shared<GetDoctorHiveDatabaseResponseBodyDataMetricsHotDataSizeDayGrowthRatio>(model1);
      }
    }
    if (m.find("LargeFileCount") != m.end() && !m["LargeFileCount"].empty()) {
      if (typeid(map<string, boost::any>) == m["LargeFileCount"].type()) {
        GetDoctorHiveDatabaseResponseBodyDataMetricsLargeFileCount model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LargeFileCount"]));
        largeFileCount = make_shared<GetDoctorHiveDatabaseResponseBodyDataMetricsLargeFileCount>(model1);
      }
    }
    if (m.find("LargeFileCountDayGrowthRatio") != m.end() && !m["LargeFileCountDayGrowthRatio"].empty()) {
      if (typeid(map<string, boost::any>) == m["LargeFileCountDayGrowthRatio"].type()) {
        GetDoctorHiveDatabaseResponseBodyDataMetricsLargeFileCountDayGrowthRatio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LargeFileCountDayGrowthRatio"]));
        largeFileCountDayGrowthRatio = make_shared<GetDoctorHiveDatabaseResponseBodyDataMetricsLargeFileCountDayGrowthRatio>(model1);
      }
    }
    if (m.find("LargeFileDayGrowthCount") != m.end() && !m["LargeFileDayGrowthCount"].empty()) {
      if (typeid(map<string, boost::any>) == m["LargeFileDayGrowthCount"].type()) {
        GetDoctorHiveDatabaseResponseBodyDataMetricsLargeFileDayGrowthCount model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LargeFileDayGrowthCount"]));
        largeFileDayGrowthCount = make_shared<GetDoctorHiveDatabaseResponseBodyDataMetricsLargeFileDayGrowthCount>(model1);
      }
    }
    if (m.find("LargeFileRatio") != m.end() && !m["LargeFileRatio"].empty()) {
      if (typeid(map<string, boost::any>) == m["LargeFileRatio"].type()) {
        GetDoctorHiveDatabaseResponseBodyDataMetricsLargeFileRatio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LargeFileRatio"]));
        largeFileRatio = make_shared<GetDoctorHiveDatabaseResponseBodyDataMetricsLargeFileRatio>(model1);
      }
    }
    if (m.find("MediumFileCount") != m.end() && !m["MediumFileCount"].empty()) {
      if (typeid(map<string, boost::any>) == m["MediumFileCount"].type()) {
        GetDoctorHiveDatabaseResponseBodyDataMetricsMediumFileCount model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MediumFileCount"]));
        mediumFileCount = make_shared<GetDoctorHiveDatabaseResponseBodyDataMetricsMediumFileCount>(model1);
      }
    }
    if (m.find("MediumFileCountDayGrowthRatio") != m.end() && !m["MediumFileCountDayGrowthRatio"].empty()) {
      if (typeid(map<string, boost::any>) == m["MediumFileCountDayGrowthRatio"].type()) {
        GetDoctorHiveDatabaseResponseBodyDataMetricsMediumFileCountDayGrowthRatio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MediumFileCountDayGrowthRatio"]));
        mediumFileCountDayGrowthRatio = make_shared<GetDoctorHiveDatabaseResponseBodyDataMetricsMediumFileCountDayGrowthRatio>(model1);
      }
    }
    if (m.find("MediumFileDayGrowthCount") != m.end() && !m["MediumFileDayGrowthCount"].empty()) {
      if (typeid(map<string, boost::any>) == m["MediumFileDayGrowthCount"].type()) {
        GetDoctorHiveDatabaseResponseBodyDataMetricsMediumFileDayGrowthCount model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MediumFileDayGrowthCount"]));
        mediumFileDayGrowthCount = make_shared<GetDoctorHiveDatabaseResponseBodyDataMetricsMediumFileDayGrowthCount>(model1);
      }
    }
    if (m.find("MediumFileRatio") != m.end() && !m["MediumFileRatio"].empty()) {
      if (typeid(map<string, boost::any>) == m["MediumFileRatio"].type()) {
        GetDoctorHiveDatabaseResponseBodyDataMetricsMediumFileRatio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MediumFileRatio"]));
        mediumFileRatio = make_shared<GetDoctorHiveDatabaseResponseBodyDataMetricsMediumFileRatio>(model1);
      }
    }
    if (m.find("PartitionNum") != m.end() && !m["PartitionNum"].empty()) {
      if (typeid(map<string, boost::any>) == m["PartitionNum"].type()) {
        GetDoctorHiveDatabaseResponseBodyDataMetricsPartitionNum model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PartitionNum"]));
        partitionNum = make_shared<GetDoctorHiveDatabaseResponseBodyDataMetricsPartitionNum>(model1);
      }
    }
    if (m.find("SmallFileCount") != m.end() && !m["SmallFileCount"].empty()) {
      if (typeid(map<string, boost::any>) == m["SmallFileCount"].type()) {
        GetDoctorHiveDatabaseResponseBodyDataMetricsSmallFileCount model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SmallFileCount"]));
        smallFileCount = make_shared<GetDoctorHiveDatabaseResponseBodyDataMetricsSmallFileCount>(model1);
      }
    }
    if (m.find("SmallFileCountDayGrowthRatio") != m.end() && !m["SmallFileCountDayGrowthRatio"].empty()) {
      if (typeid(map<string, boost::any>) == m["SmallFileCountDayGrowthRatio"].type()) {
        GetDoctorHiveDatabaseResponseBodyDataMetricsSmallFileCountDayGrowthRatio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SmallFileCountDayGrowthRatio"]));
        smallFileCountDayGrowthRatio = make_shared<GetDoctorHiveDatabaseResponseBodyDataMetricsSmallFileCountDayGrowthRatio>(model1);
      }
    }
    if (m.find("SmallFileDayGrowthCount") != m.end() && !m["SmallFileDayGrowthCount"].empty()) {
      if (typeid(map<string, boost::any>) == m["SmallFileDayGrowthCount"].type()) {
        GetDoctorHiveDatabaseResponseBodyDataMetricsSmallFileDayGrowthCount model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SmallFileDayGrowthCount"]));
        smallFileDayGrowthCount = make_shared<GetDoctorHiveDatabaseResponseBodyDataMetricsSmallFileDayGrowthCount>(model1);
      }
    }
    if (m.find("SmallFileRatio") != m.end() && !m["SmallFileRatio"].empty()) {
      if (typeid(map<string, boost::any>) == m["SmallFileRatio"].type()) {
        GetDoctorHiveDatabaseResponseBodyDataMetricsSmallFileRatio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SmallFileRatio"]));
        smallFileRatio = make_shared<GetDoctorHiveDatabaseResponseBodyDataMetricsSmallFileRatio>(model1);
      }
    }
    if (m.find("TableCount") != m.end() && !m["TableCount"].empty()) {
      if (typeid(map<string, boost::any>) == m["TableCount"].type()) {
        GetDoctorHiveDatabaseResponseBodyDataMetricsTableCount model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TableCount"]));
        tableCount = make_shared<GetDoctorHiveDatabaseResponseBodyDataMetricsTableCount>(model1);
      }
    }
    if (m.find("TinyFileCount") != m.end() && !m["TinyFileCount"].empty()) {
      if (typeid(map<string, boost::any>) == m["TinyFileCount"].type()) {
        GetDoctorHiveDatabaseResponseBodyDataMetricsTinyFileCount model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TinyFileCount"]));
        tinyFileCount = make_shared<GetDoctorHiveDatabaseResponseBodyDataMetricsTinyFileCount>(model1);
      }
    }
    if (m.find("TinyFileCountDayGrowthRatio") != m.end() && !m["TinyFileCountDayGrowthRatio"].empty()) {
      if (typeid(map<string, boost::any>) == m["TinyFileCountDayGrowthRatio"].type()) {
        GetDoctorHiveDatabaseResponseBodyDataMetricsTinyFileCountDayGrowthRatio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TinyFileCountDayGrowthRatio"]));
        tinyFileCountDayGrowthRatio = make_shared<GetDoctorHiveDatabaseResponseBodyDataMetricsTinyFileCountDayGrowthRatio>(model1);
      }
    }
    if (m.find("TinyFileDayGrowthCount") != m.end() && !m["TinyFileDayGrowthCount"].empty()) {
      if (typeid(map<string, boost::any>) == m["TinyFileDayGrowthCount"].type()) {
        GetDoctorHiveDatabaseResponseBodyDataMetricsTinyFileDayGrowthCount model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TinyFileDayGrowthCount"]));
        tinyFileDayGrowthCount = make_shared<GetDoctorHiveDatabaseResponseBodyDataMetricsTinyFileDayGrowthCount>(model1);
      }
    }
    if (m.find("TinyFileRatio") != m.end() && !m["TinyFileRatio"].empty()) {
      if (typeid(map<string, boost::any>) == m["TinyFileRatio"].type()) {
        GetDoctorHiveDatabaseResponseBodyDataMetricsTinyFileRatio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TinyFileRatio"]));
        tinyFileRatio = make_shared<GetDoctorHiveDatabaseResponseBodyDataMetricsTinyFileRatio>(model1);
      }
    }
    if (m.find("TotalDataDayGrowthSize") != m.end() && !m["TotalDataDayGrowthSize"].empty()) {
      if (typeid(map<string, boost::any>) == m["TotalDataDayGrowthSize"].type()) {
        GetDoctorHiveDatabaseResponseBodyDataMetricsTotalDataDayGrowthSize model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TotalDataDayGrowthSize"]));
        totalDataDayGrowthSize = make_shared<GetDoctorHiveDatabaseResponseBodyDataMetricsTotalDataDayGrowthSize>(model1);
      }
    }
    if (m.find("TotalDataSize") != m.end() && !m["TotalDataSize"].empty()) {
      if (typeid(map<string, boost::any>) == m["TotalDataSize"].type()) {
        GetDoctorHiveDatabaseResponseBodyDataMetricsTotalDataSize model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TotalDataSize"]));
        totalDataSize = make_shared<GetDoctorHiveDatabaseResponseBodyDataMetricsTotalDataSize>(model1);
      }
    }
    if (m.find("TotalDataSizeDayGrowthRatio") != m.end() && !m["TotalDataSizeDayGrowthRatio"].empty()) {
      if (typeid(map<string, boost::any>) == m["TotalDataSizeDayGrowthRatio"].type()) {
        GetDoctorHiveDatabaseResponseBodyDataMetricsTotalDataSizeDayGrowthRatio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TotalDataSizeDayGrowthRatio"]));
        totalDataSizeDayGrowthRatio = make_shared<GetDoctorHiveDatabaseResponseBodyDataMetricsTotalDataSizeDayGrowthRatio>(model1);
      }
    }
    if (m.find("TotalFileCount") != m.end() && !m["TotalFileCount"].empty()) {
      if (typeid(map<string, boost::any>) == m["TotalFileCount"].type()) {
        GetDoctorHiveDatabaseResponseBodyDataMetricsTotalFileCount model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TotalFileCount"]));
        totalFileCount = make_shared<GetDoctorHiveDatabaseResponseBodyDataMetricsTotalFileCount>(model1);
      }
    }
    if (m.find("TotalFileCountDayGrowthRatio") != m.end() && !m["TotalFileCountDayGrowthRatio"].empty()) {
      if (typeid(map<string, boost::any>) == m["TotalFileCountDayGrowthRatio"].type()) {
        GetDoctorHiveDatabaseResponseBodyDataMetricsTotalFileCountDayGrowthRatio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TotalFileCountDayGrowthRatio"]));
        totalFileCountDayGrowthRatio = make_shared<GetDoctorHiveDatabaseResponseBodyDataMetricsTotalFileCountDayGrowthRatio>(model1);
      }
    }
    if (m.find("TotalFileDayGrowthCount") != m.end() && !m["TotalFileDayGrowthCount"].empty()) {
      if (typeid(map<string, boost::any>) == m["TotalFileDayGrowthCount"].type()) {
        GetDoctorHiveDatabaseResponseBodyDataMetricsTotalFileDayGrowthCount model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TotalFileDayGrowthCount"]));
        totalFileDayGrowthCount = make_shared<GetDoctorHiveDatabaseResponseBodyDataMetricsTotalFileDayGrowthCount>(model1);
      }
    }
    if (m.find("WarmDataDayGrowthSize") != m.end() && !m["WarmDataDayGrowthSize"].empty()) {
      if (typeid(map<string, boost::any>) == m["WarmDataDayGrowthSize"].type()) {
        GetDoctorHiveDatabaseResponseBodyDataMetricsWarmDataDayGrowthSize model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["WarmDataDayGrowthSize"]));
        warmDataDayGrowthSize = make_shared<GetDoctorHiveDatabaseResponseBodyDataMetricsWarmDataDayGrowthSize>(model1);
      }
    }
    if (m.find("WarmDataRatio") != m.end() && !m["WarmDataRatio"].empty()) {
      if (typeid(map<string, boost::any>) == m["WarmDataRatio"].type()) {
        GetDoctorHiveDatabaseResponseBodyDataMetricsWarmDataRatio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["WarmDataRatio"]));
        warmDataRatio = make_shared<GetDoctorHiveDatabaseResponseBodyDataMetricsWarmDataRatio>(model1);
      }
    }
    if (m.find("WarmDataSize") != m.end() && !m["WarmDataSize"].empty()) {
      if (typeid(map<string, boost::any>) == m["WarmDataSize"].type()) {
        GetDoctorHiveDatabaseResponseBodyDataMetricsWarmDataSize model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["WarmDataSize"]));
        warmDataSize = make_shared<GetDoctorHiveDatabaseResponseBodyDataMetricsWarmDataSize>(model1);
      }
    }
    if (m.find("WarmDataSizeDayGrowthRatio") != m.end() && !m["WarmDataSizeDayGrowthRatio"].empty()) {
      if (typeid(map<string, boost::any>) == m["WarmDataSizeDayGrowthRatio"].type()) {
        GetDoctorHiveDatabaseResponseBodyDataMetricsWarmDataSizeDayGrowthRatio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["WarmDataSizeDayGrowthRatio"]));
        warmDataSizeDayGrowthRatio = make_shared<GetDoctorHiveDatabaseResponseBodyDataMetricsWarmDataSizeDayGrowthRatio>(model1);
      }
    }
  }


  virtual ~GetDoctorHiveDatabaseResponseBodyDataMetrics() = default;
};
class GetDoctorHiveDatabaseResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<GetDoctorHiveDatabaseResponseBodyDataAnalysis> analysis{};
  shared_ptr<vector<GetDoctorHiveDatabaseResponseBodyDataFormats>> formats{};
  shared_ptr<GetDoctorHiveDatabaseResponseBodyDataMetrics> metrics{};

  GetDoctorHiveDatabaseResponseBodyData() {}

  explicit GetDoctorHiveDatabaseResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (analysis) {
      res["Analysis"] = analysis ? boost::any(analysis->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (formats) {
      vector<boost::any> temp1;
      for(auto item1:*formats){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Formats"] = boost::any(temp1);
    }
    if (metrics) {
      res["Metrics"] = metrics ? boost::any(metrics->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Analysis") != m.end() && !m["Analysis"].empty()) {
      if (typeid(map<string, boost::any>) == m["Analysis"].type()) {
        GetDoctorHiveDatabaseResponseBodyDataAnalysis model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Analysis"]));
        analysis = make_shared<GetDoctorHiveDatabaseResponseBodyDataAnalysis>(model1);
      }
    }
    if (m.find("Formats") != m.end() && !m["Formats"].empty()) {
      if (typeid(vector<boost::any>) == m["Formats"].type()) {
        vector<GetDoctorHiveDatabaseResponseBodyDataFormats> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Formats"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetDoctorHiveDatabaseResponseBodyDataFormats model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        formats = make_shared<vector<GetDoctorHiveDatabaseResponseBodyDataFormats>>(expect1);
      }
    }
    if (m.find("Metrics") != m.end() && !m["Metrics"].empty()) {
      if (typeid(map<string, boost::any>) == m["Metrics"].type()) {
        GetDoctorHiveDatabaseResponseBodyDataMetrics model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Metrics"]));
        metrics = make_shared<GetDoctorHiveDatabaseResponseBodyDataMetrics>(model1);
      }
    }
  }


  virtual ~GetDoctorHiveDatabaseResponseBodyData() = default;
};
class GetDoctorHiveDatabaseResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetDoctorHiveDatabaseResponseBodyData> data{};
  shared_ptr<string> requestId{};

  GetDoctorHiveDatabaseResponseBody() {}

  explicit GetDoctorHiveDatabaseResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetDoctorHiveDatabaseResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetDoctorHiveDatabaseResponseBodyData>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetDoctorHiveDatabaseResponseBody() = default;
};
class GetDoctorHiveDatabaseResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetDoctorHiveDatabaseResponseBody> body{};

  GetDoctorHiveDatabaseResponse() {}

  explicit GetDoctorHiveDatabaseResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetDoctorHiveDatabaseResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetDoctorHiveDatabaseResponseBody>(model1);
      }
    }
  }


  virtual ~GetDoctorHiveDatabaseResponse() = default;
};
class GetDoctorHiveTableRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> dateTime{};
  shared_ptr<string> regionId{};
  shared_ptr<string> tableName{};

  GetDoctorHiveTableRequest() {}

  explicit GetDoctorHiveTableRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (dateTime) {
      res["DateTime"] = boost::any(*dateTime);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (tableName) {
      res["TableName"] = boost::any(*tableName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("DateTime") != m.end() && !m["DateTime"].empty()) {
      dateTime = make_shared<string>(boost::any_cast<string>(m["DateTime"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("TableName") != m.end() && !m["TableName"].empty()) {
      tableName = make_shared<string>(boost::any_cast<string>(m["TableName"]));
    }
  }


  virtual ~GetDoctorHiveTableRequest() = default;
};
class GetDoctorHiveTableResponseBodyDataAnalysis : public Darabonba::Model {
public:
  shared_ptr<long> hiveDistributionScore{};
  shared_ptr<long> hiveFormatScore{};
  shared_ptr<long> hiveFrequencyScore{};
  shared_ptr<long> hiveScore{};

  GetDoctorHiveTableResponseBodyDataAnalysis() {}

  explicit GetDoctorHiveTableResponseBodyDataAnalysis(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hiveDistributionScore) {
      res["HiveDistributionScore"] = boost::any(*hiveDistributionScore);
    }
    if (hiveFormatScore) {
      res["HiveFormatScore"] = boost::any(*hiveFormatScore);
    }
    if (hiveFrequencyScore) {
      res["HiveFrequencyScore"] = boost::any(*hiveFrequencyScore);
    }
    if (hiveScore) {
      res["HiveScore"] = boost::any(*hiveScore);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HiveDistributionScore") != m.end() && !m["HiveDistributionScore"].empty()) {
      hiveDistributionScore = make_shared<long>(boost::any_cast<long>(m["HiveDistributionScore"]));
    }
    if (m.find("HiveFormatScore") != m.end() && !m["HiveFormatScore"].empty()) {
      hiveFormatScore = make_shared<long>(boost::any_cast<long>(m["HiveFormatScore"]));
    }
    if (m.find("HiveFrequencyScore") != m.end() && !m["HiveFrequencyScore"].empty()) {
      hiveFrequencyScore = make_shared<long>(boost::any_cast<long>(m["HiveFrequencyScore"]));
    }
    if (m.find("HiveScore") != m.end() && !m["HiveScore"].empty()) {
      hiveScore = make_shared<long>(boost::any_cast<long>(m["HiveScore"]));
    }
  }


  virtual ~GetDoctorHiveTableResponseBodyDataAnalysis() = default;
};
class GetDoctorHiveTableResponseBodyDataFormats : public Darabonba::Model {
public:
  shared_ptr<long> formatDayGrowthSize{};
  shared_ptr<string> formatName{};
  shared_ptr<double> formatRatio{};
  shared_ptr<long> formatSize{};
  shared_ptr<double> formatSizeDayGrowthRatio{};
  shared_ptr<string> formatSizeUnit{};

  GetDoctorHiveTableResponseBodyDataFormats() {}

  explicit GetDoctorHiveTableResponseBodyDataFormats(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (formatDayGrowthSize) {
      res["FormatDayGrowthSize"] = boost::any(*formatDayGrowthSize);
    }
    if (formatName) {
      res["FormatName"] = boost::any(*formatName);
    }
    if (formatRatio) {
      res["FormatRatio"] = boost::any(*formatRatio);
    }
    if (formatSize) {
      res["FormatSize"] = boost::any(*formatSize);
    }
    if (formatSizeDayGrowthRatio) {
      res["FormatSizeDayGrowthRatio"] = boost::any(*formatSizeDayGrowthRatio);
    }
    if (formatSizeUnit) {
      res["FormatSizeUnit"] = boost::any(*formatSizeUnit);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FormatDayGrowthSize") != m.end() && !m["FormatDayGrowthSize"].empty()) {
      formatDayGrowthSize = make_shared<long>(boost::any_cast<long>(m["FormatDayGrowthSize"]));
    }
    if (m.find("FormatName") != m.end() && !m["FormatName"].empty()) {
      formatName = make_shared<string>(boost::any_cast<string>(m["FormatName"]));
    }
    if (m.find("FormatRatio") != m.end() && !m["FormatRatio"].empty()) {
      formatRatio = make_shared<double>(boost::any_cast<double>(m["FormatRatio"]));
    }
    if (m.find("FormatSize") != m.end() && !m["FormatSize"].empty()) {
      formatSize = make_shared<long>(boost::any_cast<long>(m["FormatSize"]));
    }
    if (m.find("FormatSizeDayGrowthRatio") != m.end() && !m["FormatSizeDayGrowthRatio"].empty()) {
      formatSizeDayGrowthRatio = make_shared<double>(boost::any_cast<double>(m["FormatSizeDayGrowthRatio"]));
    }
    if (m.find("FormatSizeUnit") != m.end() && !m["FormatSizeUnit"].empty()) {
      formatSizeUnit = make_shared<string>(boost::any_cast<string>(m["FormatSizeUnit"]));
    }
  }


  virtual ~GetDoctorHiveTableResponseBodyDataFormats() = default;
};
class GetDoctorHiveTableResponseBodyDataMetricsColdDataDayGrowthSize : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  GetDoctorHiveTableResponseBodyDataMetricsColdDataDayGrowthSize() {}

  explicit GetDoctorHiveTableResponseBodyDataMetricsColdDataDayGrowthSize(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~GetDoctorHiveTableResponseBodyDataMetricsColdDataDayGrowthSize() = default;
};
class GetDoctorHiveTableResponseBodyDataMetricsColdDataRatio : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  GetDoctorHiveTableResponseBodyDataMetricsColdDataRatio() {}

  explicit GetDoctorHiveTableResponseBodyDataMetricsColdDataRatio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~GetDoctorHiveTableResponseBodyDataMetricsColdDataRatio() = default;
};
class GetDoctorHiveTableResponseBodyDataMetricsColdDataSize : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  GetDoctorHiveTableResponseBodyDataMetricsColdDataSize() {}

  explicit GetDoctorHiveTableResponseBodyDataMetricsColdDataSize(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~GetDoctorHiveTableResponseBodyDataMetricsColdDataSize() = default;
};
class GetDoctorHiveTableResponseBodyDataMetricsColdDataSizeDayGrowthRatio : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  GetDoctorHiveTableResponseBodyDataMetricsColdDataSizeDayGrowthRatio() {}

  explicit GetDoctorHiveTableResponseBodyDataMetricsColdDataSizeDayGrowthRatio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~GetDoctorHiveTableResponseBodyDataMetricsColdDataSizeDayGrowthRatio() = default;
};
class GetDoctorHiveTableResponseBodyDataMetricsEmptyFileCount : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  GetDoctorHiveTableResponseBodyDataMetricsEmptyFileCount() {}

  explicit GetDoctorHiveTableResponseBodyDataMetricsEmptyFileCount(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~GetDoctorHiveTableResponseBodyDataMetricsEmptyFileCount() = default;
};
class GetDoctorHiveTableResponseBodyDataMetricsEmptyFileCountDayGrowthRatio : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  GetDoctorHiveTableResponseBodyDataMetricsEmptyFileCountDayGrowthRatio() {}

  explicit GetDoctorHiveTableResponseBodyDataMetricsEmptyFileCountDayGrowthRatio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~GetDoctorHiveTableResponseBodyDataMetricsEmptyFileCountDayGrowthRatio() = default;
};
class GetDoctorHiveTableResponseBodyDataMetricsEmptyFileDayGrowthCount : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  GetDoctorHiveTableResponseBodyDataMetricsEmptyFileDayGrowthCount() {}

  explicit GetDoctorHiveTableResponseBodyDataMetricsEmptyFileDayGrowthCount(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~GetDoctorHiveTableResponseBodyDataMetricsEmptyFileDayGrowthCount() = default;
};
class GetDoctorHiveTableResponseBodyDataMetricsEmptyFileRatio : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  GetDoctorHiveTableResponseBodyDataMetricsEmptyFileRatio() {}

  explicit GetDoctorHiveTableResponseBodyDataMetricsEmptyFileRatio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~GetDoctorHiveTableResponseBodyDataMetricsEmptyFileRatio() = default;
};
class GetDoctorHiveTableResponseBodyDataMetricsFreezeDataDayGrowthSize : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  GetDoctorHiveTableResponseBodyDataMetricsFreezeDataDayGrowthSize() {}

  explicit GetDoctorHiveTableResponseBodyDataMetricsFreezeDataDayGrowthSize(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~GetDoctorHiveTableResponseBodyDataMetricsFreezeDataDayGrowthSize() = default;
};
class GetDoctorHiveTableResponseBodyDataMetricsFreezeDataRatio : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  GetDoctorHiveTableResponseBodyDataMetricsFreezeDataRatio() {}

  explicit GetDoctorHiveTableResponseBodyDataMetricsFreezeDataRatio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~GetDoctorHiveTableResponseBodyDataMetricsFreezeDataRatio() = default;
};
class GetDoctorHiveTableResponseBodyDataMetricsFreezeDataSize : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  GetDoctorHiveTableResponseBodyDataMetricsFreezeDataSize() {}

  explicit GetDoctorHiveTableResponseBodyDataMetricsFreezeDataSize(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~GetDoctorHiveTableResponseBodyDataMetricsFreezeDataSize() = default;
};
class GetDoctorHiveTableResponseBodyDataMetricsFreezeDataSizeDayGrowthRatio : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  GetDoctorHiveTableResponseBodyDataMetricsFreezeDataSizeDayGrowthRatio() {}

  explicit GetDoctorHiveTableResponseBodyDataMetricsFreezeDataSizeDayGrowthRatio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~GetDoctorHiveTableResponseBodyDataMetricsFreezeDataSizeDayGrowthRatio() = default;
};
class GetDoctorHiveTableResponseBodyDataMetricsHotDataDayGrowthSize : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  GetDoctorHiveTableResponseBodyDataMetricsHotDataDayGrowthSize() {}

  explicit GetDoctorHiveTableResponseBodyDataMetricsHotDataDayGrowthSize(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~GetDoctorHiveTableResponseBodyDataMetricsHotDataDayGrowthSize() = default;
};
class GetDoctorHiveTableResponseBodyDataMetricsHotDataRatio : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  GetDoctorHiveTableResponseBodyDataMetricsHotDataRatio() {}

  explicit GetDoctorHiveTableResponseBodyDataMetricsHotDataRatio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~GetDoctorHiveTableResponseBodyDataMetricsHotDataRatio() = default;
};
class GetDoctorHiveTableResponseBodyDataMetricsHotDataSize : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  GetDoctorHiveTableResponseBodyDataMetricsHotDataSize() {}

  explicit GetDoctorHiveTableResponseBodyDataMetricsHotDataSize(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~GetDoctorHiveTableResponseBodyDataMetricsHotDataSize() = default;
};
class GetDoctorHiveTableResponseBodyDataMetricsHotDataSizeDayGrowthRatio : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  GetDoctorHiveTableResponseBodyDataMetricsHotDataSizeDayGrowthRatio() {}

  explicit GetDoctorHiveTableResponseBodyDataMetricsHotDataSizeDayGrowthRatio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~GetDoctorHiveTableResponseBodyDataMetricsHotDataSizeDayGrowthRatio() = default;
};
class GetDoctorHiveTableResponseBodyDataMetricsLargeFileCount : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  GetDoctorHiveTableResponseBodyDataMetricsLargeFileCount() {}

  explicit GetDoctorHiveTableResponseBodyDataMetricsLargeFileCount(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~GetDoctorHiveTableResponseBodyDataMetricsLargeFileCount() = default;
};
class GetDoctorHiveTableResponseBodyDataMetricsLargeFileCountDayGrowthRatio : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  GetDoctorHiveTableResponseBodyDataMetricsLargeFileCountDayGrowthRatio() {}

  explicit GetDoctorHiveTableResponseBodyDataMetricsLargeFileCountDayGrowthRatio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~GetDoctorHiveTableResponseBodyDataMetricsLargeFileCountDayGrowthRatio() = default;
};
class GetDoctorHiveTableResponseBodyDataMetricsLargeFileDayGrowthCount : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  GetDoctorHiveTableResponseBodyDataMetricsLargeFileDayGrowthCount() {}

  explicit GetDoctorHiveTableResponseBodyDataMetricsLargeFileDayGrowthCount(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~GetDoctorHiveTableResponseBodyDataMetricsLargeFileDayGrowthCount() = default;
};
class GetDoctorHiveTableResponseBodyDataMetricsLargeFileRatio : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  GetDoctorHiveTableResponseBodyDataMetricsLargeFileRatio() {}

  explicit GetDoctorHiveTableResponseBodyDataMetricsLargeFileRatio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~GetDoctorHiveTableResponseBodyDataMetricsLargeFileRatio() = default;
};
class GetDoctorHiveTableResponseBodyDataMetricsMediumFileCount : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  GetDoctorHiveTableResponseBodyDataMetricsMediumFileCount() {}

  explicit GetDoctorHiveTableResponseBodyDataMetricsMediumFileCount(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~GetDoctorHiveTableResponseBodyDataMetricsMediumFileCount() = default;
};
class GetDoctorHiveTableResponseBodyDataMetricsMediumFileCountDayGrowthRatio : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  GetDoctorHiveTableResponseBodyDataMetricsMediumFileCountDayGrowthRatio() {}

  explicit GetDoctorHiveTableResponseBodyDataMetricsMediumFileCountDayGrowthRatio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~GetDoctorHiveTableResponseBodyDataMetricsMediumFileCountDayGrowthRatio() = default;
};
class GetDoctorHiveTableResponseBodyDataMetricsMediumFileDayGrowthCount : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  GetDoctorHiveTableResponseBodyDataMetricsMediumFileDayGrowthCount() {}

  explicit GetDoctorHiveTableResponseBodyDataMetricsMediumFileDayGrowthCount(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~GetDoctorHiveTableResponseBodyDataMetricsMediumFileDayGrowthCount() = default;
};
class GetDoctorHiveTableResponseBodyDataMetricsMediumFileRatio : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  GetDoctorHiveTableResponseBodyDataMetricsMediumFileRatio() {}

  explicit GetDoctorHiveTableResponseBodyDataMetricsMediumFileRatio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~GetDoctorHiveTableResponseBodyDataMetricsMediumFileRatio() = default;
};
class GetDoctorHiveTableResponseBodyDataMetricsPartitionNum : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  GetDoctorHiveTableResponseBodyDataMetricsPartitionNum() {}

  explicit GetDoctorHiveTableResponseBodyDataMetricsPartitionNum(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~GetDoctorHiveTableResponseBodyDataMetricsPartitionNum() = default;
};
class GetDoctorHiveTableResponseBodyDataMetricsSmallFileCount : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  GetDoctorHiveTableResponseBodyDataMetricsSmallFileCount() {}

  explicit GetDoctorHiveTableResponseBodyDataMetricsSmallFileCount(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~GetDoctorHiveTableResponseBodyDataMetricsSmallFileCount() = default;
};
class GetDoctorHiveTableResponseBodyDataMetricsSmallFileCountDayGrowthRatio : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  GetDoctorHiveTableResponseBodyDataMetricsSmallFileCountDayGrowthRatio() {}

  explicit GetDoctorHiveTableResponseBodyDataMetricsSmallFileCountDayGrowthRatio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~GetDoctorHiveTableResponseBodyDataMetricsSmallFileCountDayGrowthRatio() = default;
};
class GetDoctorHiveTableResponseBodyDataMetricsSmallFileDayGrowthCount : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  GetDoctorHiveTableResponseBodyDataMetricsSmallFileDayGrowthCount() {}

  explicit GetDoctorHiveTableResponseBodyDataMetricsSmallFileDayGrowthCount(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~GetDoctorHiveTableResponseBodyDataMetricsSmallFileDayGrowthCount() = default;
};
class GetDoctorHiveTableResponseBodyDataMetricsSmallFileRatio : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  GetDoctorHiveTableResponseBodyDataMetricsSmallFileRatio() {}

  explicit GetDoctorHiveTableResponseBodyDataMetricsSmallFileRatio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~GetDoctorHiveTableResponseBodyDataMetricsSmallFileRatio() = default;
};
class GetDoctorHiveTableResponseBodyDataMetricsTinyFileCount : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  GetDoctorHiveTableResponseBodyDataMetricsTinyFileCount() {}

  explicit GetDoctorHiveTableResponseBodyDataMetricsTinyFileCount(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~GetDoctorHiveTableResponseBodyDataMetricsTinyFileCount() = default;
};
class GetDoctorHiveTableResponseBodyDataMetricsTinyFileCountDayGrowthRatio : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  GetDoctorHiveTableResponseBodyDataMetricsTinyFileCountDayGrowthRatio() {}

  explicit GetDoctorHiveTableResponseBodyDataMetricsTinyFileCountDayGrowthRatio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~GetDoctorHiveTableResponseBodyDataMetricsTinyFileCountDayGrowthRatio() = default;
};
class GetDoctorHiveTableResponseBodyDataMetricsTinyFileDayGrowthCount : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  GetDoctorHiveTableResponseBodyDataMetricsTinyFileDayGrowthCount() {}

  explicit GetDoctorHiveTableResponseBodyDataMetricsTinyFileDayGrowthCount(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~GetDoctorHiveTableResponseBodyDataMetricsTinyFileDayGrowthCount() = default;
};
class GetDoctorHiveTableResponseBodyDataMetricsTinyFileRatio : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  GetDoctorHiveTableResponseBodyDataMetricsTinyFileRatio() {}

  explicit GetDoctorHiveTableResponseBodyDataMetricsTinyFileRatio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~GetDoctorHiveTableResponseBodyDataMetricsTinyFileRatio() = default;
};
class GetDoctorHiveTableResponseBodyDataMetricsTotalDataDayGrowthSize : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  GetDoctorHiveTableResponseBodyDataMetricsTotalDataDayGrowthSize() {}

  explicit GetDoctorHiveTableResponseBodyDataMetricsTotalDataDayGrowthSize(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~GetDoctorHiveTableResponseBodyDataMetricsTotalDataDayGrowthSize() = default;
};
class GetDoctorHiveTableResponseBodyDataMetricsTotalDataSize : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  GetDoctorHiveTableResponseBodyDataMetricsTotalDataSize() {}

  explicit GetDoctorHiveTableResponseBodyDataMetricsTotalDataSize(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~GetDoctorHiveTableResponseBodyDataMetricsTotalDataSize() = default;
};
class GetDoctorHiveTableResponseBodyDataMetricsTotalDataSizeDayGrowthRatio : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  GetDoctorHiveTableResponseBodyDataMetricsTotalDataSizeDayGrowthRatio() {}

  explicit GetDoctorHiveTableResponseBodyDataMetricsTotalDataSizeDayGrowthRatio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~GetDoctorHiveTableResponseBodyDataMetricsTotalDataSizeDayGrowthRatio() = default;
};
class GetDoctorHiveTableResponseBodyDataMetricsTotalFileCount : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  GetDoctorHiveTableResponseBodyDataMetricsTotalFileCount() {}

  explicit GetDoctorHiveTableResponseBodyDataMetricsTotalFileCount(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~GetDoctorHiveTableResponseBodyDataMetricsTotalFileCount() = default;
};
class GetDoctorHiveTableResponseBodyDataMetricsTotalFileCountDayGrowthRatio : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  GetDoctorHiveTableResponseBodyDataMetricsTotalFileCountDayGrowthRatio() {}

  explicit GetDoctorHiveTableResponseBodyDataMetricsTotalFileCountDayGrowthRatio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~GetDoctorHiveTableResponseBodyDataMetricsTotalFileCountDayGrowthRatio() = default;
};
class GetDoctorHiveTableResponseBodyDataMetricsTotalFileDayGrowthCount : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  GetDoctorHiveTableResponseBodyDataMetricsTotalFileDayGrowthCount() {}

  explicit GetDoctorHiveTableResponseBodyDataMetricsTotalFileDayGrowthCount(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~GetDoctorHiveTableResponseBodyDataMetricsTotalFileDayGrowthCount() = default;
};
class GetDoctorHiveTableResponseBodyDataMetricsWarmDataDayGrowthSize : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  GetDoctorHiveTableResponseBodyDataMetricsWarmDataDayGrowthSize() {}

  explicit GetDoctorHiveTableResponseBodyDataMetricsWarmDataDayGrowthSize(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~GetDoctorHiveTableResponseBodyDataMetricsWarmDataDayGrowthSize() = default;
};
class GetDoctorHiveTableResponseBodyDataMetricsWarmDataRatio : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  GetDoctorHiveTableResponseBodyDataMetricsWarmDataRatio() {}

  explicit GetDoctorHiveTableResponseBodyDataMetricsWarmDataRatio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~GetDoctorHiveTableResponseBodyDataMetricsWarmDataRatio() = default;
};
class GetDoctorHiveTableResponseBodyDataMetricsWarmDataSize : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  GetDoctorHiveTableResponseBodyDataMetricsWarmDataSize() {}

  explicit GetDoctorHiveTableResponseBodyDataMetricsWarmDataSize(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~GetDoctorHiveTableResponseBodyDataMetricsWarmDataSize() = default;
};
class GetDoctorHiveTableResponseBodyDataMetricsWarmDataSizeDayGrowthRatio : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  GetDoctorHiveTableResponseBodyDataMetricsWarmDataSizeDayGrowthRatio() {}

  explicit GetDoctorHiveTableResponseBodyDataMetricsWarmDataSizeDayGrowthRatio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~GetDoctorHiveTableResponseBodyDataMetricsWarmDataSizeDayGrowthRatio() = default;
};
class GetDoctorHiveTableResponseBodyDataMetrics : public Darabonba::Model {
public:
  shared_ptr<GetDoctorHiveTableResponseBodyDataMetricsColdDataDayGrowthSize> coldDataDayGrowthSize{};
  shared_ptr<GetDoctorHiveTableResponseBodyDataMetricsColdDataRatio> coldDataRatio{};
  shared_ptr<GetDoctorHiveTableResponseBodyDataMetricsColdDataSize> coldDataSize{};
  shared_ptr<GetDoctorHiveTableResponseBodyDataMetricsColdDataSizeDayGrowthRatio> coldDataSizeDayGrowthRatio{};
  shared_ptr<GetDoctorHiveTableResponseBodyDataMetricsEmptyFileCount> emptyFileCount{};
  shared_ptr<GetDoctorHiveTableResponseBodyDataMetricsEmptyFileCountDayGrowthRatio> emptyFileCountDayGrowthRatio{};
  shared_ptr<GetDoctorHiveTableResponseBodyDataMetricsEmptyFileDayGrowthCount> emptyFileDayGrowthCount{};
  shared_ptr<GetDoctorHiveTableResponseBodyDataMetricsEmptyFileRatio> emptyFileRatio{};
  shared_ptr<GetDoctorHiveTableResponseBodyDataMetricsFreezeDataDayGrowthSize> freezeDataDayGrowthSize{};
  shared_ptr<GetDoctorHiveTableResponseBodyDataMetricsFreezeDataRatio> freezeDataRatio{};
  shared_ptr<GetDoctorHiveTableResponseBodyDataMetricsFreezeDataSize> freezeDataSize{};
  shared_ptr<GetDoctorHiveTableResponseBodyDataMetricsFreezeDataSizeDayGrowthRatio> freezeDataSizeDayGrowthRatio{};
  shared_ptr<GetDoctorHiveTableResponseBodyDataMetricsHotDataDayGrowthSize> hotDataDayGrowthSize{};
  shared_ptr<GetDoctorHiveTableResponseBodyDataMetricsHotDataRatio> hotDataRatio{};
  shared_ptr<GetDoctorHiveTableResponseBodyDataMetricsHotDataSize> hotDataSize{};
  shared_ptr<GetDoctorHiveTableResponseBodyDataMetricsHotDataSizeDayGrowthRatio> hotDataSizeDayGrowthRatio{};
  shared_ptr<GetDoctorHiveTableResponseBodyDataMetricsLargeFileCount> largeFileCount{};
  shared_ptr<GetDoctorHiveTableResponseBodyDataMetricsLargeFileCountDayGrowthRatio> largeFileCountDayGrowthRatio{};
  shared_ptr<GetDoctorHiveTableResponseBodyDataMetricsLargeFileDayGrowthCount> largeFileDayGrowthCount{};
  shared_ptr<GetDoctorHiveTableResponseBodyDataMetricsLargeFileRatio> largeFileRatio{};
  shared_ptr<GetDoctorHiveTableResponseBodyDataMetricsMediumFileCount> mediumFileCount{};
  shared_ptr<GetDoctorHiveTableResponseBodyDataMetricsMediumFileCountDayGrowthRatio> mediumFileCountDayGrowthRatio{};
  shared_ptr<GetDoctorHiveTableResponseBodyDataMetricsMediumFileDayGrowthCount> mediumFileDayGrowthCount{};
  shared_ptr<GetDoctorHiveTableResponseBodyDataMetricsMediumFileRatio> mediumFileRatio{};
  shared_ptr<GetDoctorHiveTableResponseBodyDataMetricsPartitionNum> partitionNum{};
  shared_ptr<GetDoctorHiveTableResponseBodyDataMetricsSmallFileCount> smallFileCount{};
  shared_ptr<GetDoctorHiveTableResponseBodyDataMetricsSmallFileCountDayGrowthRatio> smallFileCountDayGrowthRatio{};
  shared_ptr<GetDoctorHiveTableResponseBodyDataMetricsSmallFileDayGrowthCount> smallFileDayGrowthCount{};
  shared_ptr<GetDoctorHiveTableResponseBodyDataMetricsSmallFileRatio> smallFileRatio{};
  shared_ptr<GetDoctorHiveTableResponseBodyDataMetricsTinyFileCount> tinyFileCount{};
  shared_ptr<GetDoctorHiveTableResponseBodyDataMetricsTinyFileCountDayGrowthRatio> tinyFileCountDayGrowthRatio{};
  shared_ptr<GetDoctorHiveTableResponseBodyDataMetricsTinyFileDayGrowthCount> tinyFileDayGrowthCount{};
  shared_ptr<GetDoctorHiveTableResponseBodyDataMetricsTinyFileRatio> tinyFileRatio{};
  shared_ptr<GetDoctorHiveTableResponseBodyDataMetricsTotalDataDayGrowthSize> totalDataDayGrowthSize{};
  shared_ptr<GetDoctorHiveTableResponseBodyDataMetricsTotalDataSize> totalDataSize{};
  shared_ptr<GetDoctorHiveTableResponseBodyDataMetricsTotalDataSizeDayGrowthRatio> totalDataSizeDayGrowthRatio{};
  shared_ptr<GetDoctorHiveTableResponseBodyDataMetricsTotalFileCount> totalFileCount{};
  shared_ptr<GetDoctorHiveTableResponseBodyDataMetricsTotalFileCountDayGrowthRatio> totalFileCountDayGrowthRatio{};
  shared_ptr<GetDoctorHiveTableResponseBodyDataMetricsTotalFileDayGrowthCount> totalFileDayGrowthCount{};
  shared_ptr<GetDoctorHiveTableResponseBodyDataMetricsWarmDataDayGrowthSize> warmDataDayGrowthSize{};
  shared_ptr<GetDoctorHiveTableResponseBodyDataMetricsWarmDataRatio> warmDataRatio{};
  shared_ptr<GetDoctorHiveTableResponseBodyDataMetricsWarmDataSize> warmDataSize{};
  shared_ptr<GetDoctorHiveTableResponseBodyDataMetricsWarmDataSizeDayGrowthRatio> warmDataSizeDayGrowthRatio{};

  GetDoctorHiveTableResponseBodyDataMetrics() {}

  explicit GetDoctorHiveTableResponseBodyDataMetrics(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (coldDataDayGrowthSize) {
      res["ColdDataDayGrowthSize"] = coldDataDayGrowthSize ? boost::any(coldDataDayGrowthSize->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (coldDataRatio) {
      res["ColdDataRatio"] = coldDataRatio ? boost::any(coldDataRatio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (coldDataSize) {
      res["ColdDataSize"] = coldDataSize ? boost::any(coldDataSize->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (coldDataSizeDayGrowthRatio) {
      res["ColdDataSizeDayGrowthRatio"] = coldDataSizeDayGrowthRatio ? boost::any(coldDataSizeDayGrowthRatio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (emptyFileCount) {
      res["EmptyFileCount"] = emptyFileCount ? boost::any(emptyFileCount->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (emptyFileCountDayGrowthRatio) {
      res["EmptyFileCountDayGrowthRatio"] = emptyFileCountDayGrowthRatio ? boost::any(emptyFileCountDayGrowthRatio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (emptyFileDayGrowthCount) {
      res["EmptyFileDayGrowthCount"] = emptyFileDayGrowthCount ? boost::any(emptyFileDayGrowthCount->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (emptyFileRatio) {
      res["EmptyFileRatio"] = emptyFileRatio ? boost::any(emptyFileRatio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (freezeDataDayGrowthSize) {
      res["FreezeDataDayGrowthSize"] = freezeDataDayGrowthSize ? boost::any(freezeDataDayGrowthSize->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (freezeDataRatio) {
      res["FreezeDataRatio"] = freezeDataRatio ? boost::any(freezeDataRatio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (freezeDataSize) {
      res["FreezeDataSize"] = freezeDataSize ? boost::any(freezeDataSize->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (freezeDataSizeDayGrowthRatio) {
      res["FreezeDataSizeDayGrowthRatio"] = freezeDataSizeDayGrowthRatio ? boost::any(freezeDataSizeDayGrowthRatio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (hotDataDayGrowthSize) {
      res["HotDataDayGrowthSize"] = hotDataDayGrowthSize ? boost::any(hotDataDayGrowthSize->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (hotDataRatio) {
      res["HotDataRatio"] = hotDataRatio ? boost::any(hotDataRatio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (hotDataSize) {
      res["HotDataSize"] = hotDataSize ? boost::any(hotDataSize->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (hotDataSizeDayGrowthRatio) {
      res["HotDataSizeDayGrowthRatio"] = hotDataSizeDayGrowthRatio ? boost::any(hotDataSizeDayGrowthRatio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (largeFileCount) {
      res["LargeFileCount"] = largeFileCount ? boost::any(largeFileCount->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (largeFileCountDayGrowthRatio) {
      res["LargeFileCountDayGrowthRatio"] = largeFileCountDayGrowthRatio ? boost::any(largeFileCountDayGrowthRatio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (largeFileDayGrowthCount) {
      res["LargeFileDayGrowthCount"] = largeFileDayGrowthCount ? boost::any(largeFileDayGrowthCount->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (largeFileRatio) {
      res["LargeFileRatio"] = largeFileRatio ? boost::any(largeFileRatio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (mediumFileCount) {
      res["MediumFileCount"] = mediumFileCount ? boost::any(mediumFileCount->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (mediumFileCountDayGrowthRatio) {
      res["MediumFileCountDayGrowthRatio"] = mediumFileCountDayGrowthRatio ? boost::any(mediumFileCountDayGrowthRatio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (mediumFileDayGrowthCount) {
      res["MediumFileDayGrowthCount"] = mediumFileDayGrowthCount ? boost::any(mediumFileDayGrowthCount->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (mediumFileRatio) {
      res["MediumFileRatio"] = mediumFileRatio ? boost::any(mediumFileRatio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (partitionNum) {
      res["PartitionNum"] = partitionNum ? boost::any(partitionNum->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (smallFileCount) {
      res["SmallFileCount"] = smallFileCount ? boost::any(smallFileCount->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (smallFileCountDayGrowthRatio) {
      res["SmallFileCountDayGrowthRatio"] = smallFileCountDayGrowthRatio ? boost::any(smallFileCountDayGrowthRatio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (smallFileDayGrowthCount) {
      res["SmallFileDayGrowthCount"] = smallFileDayGrowthCount ? boost::any(smallFileDayGrowthCount->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (smallFileRatio) {
      res["SmallFileRatio"] = smallFileRatio ? boost::any(smallFileRatio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tinyFileCount) {
      res["TinyFileCount"] = tinyFileCount ? boost::any(tinyFileCount->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tinyFileCountDayGrowthRatio) {
      res["TinyFileCountDayGrowthRatio"] = tinyFileCountDayGrowthRatio ? boost::any(tinyFileCountDayGrowthRatio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tinyFileDayGrowthCount) {
      res["TinyFileDayGrowthCount"] = tinyFileDayGrowthCount ? boost::any(tinyFileDayGrowthCount->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tinyFileRatio) {
      res["TinyFileRatio"] = tinyFileRatio ? boost::any(tinyFileRatio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (totalDataDayGrowthSize) {
      res["TotalDataDayGrowthSize"] = totalDataDayGrowthSize ? boost::any(totalDataDayGrowthSize->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (totalDataSize) {
      res["TotalDataSize"] = totalDataSize ? boost::any(totalDataSize->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (totalDataSizeDayGrowthRatio) {
      res["TotalDataSizeDayGrowthRatio"] = totalDataSizeDayGrowthRatio ? boost::any(totalDataSizeDayGrowthRatio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (totalFileCount) {
      res["TotalFileCount"] = totalFileCount ? boost::any(totalFileCount->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (totalFileCountDayGrowthRatio) {
      res["TotalFileCountDayGrowthRatio"] = totalFileCountDayGrowthRatio ? boost::any(totalFileCountDayGrowthRatio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (totalFileDayGrowthCount) {
      res["TotalFileDayGrowthCount"] = totalFileDayGrowthCount ? boost::any(totalFileDayGrowthCount->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (warmDataDayGrowthSize) {
      res["WarmDataDayGrowthSize"] = warmDataDayGrowthSize ? boost::any(warmDataDayGrowthSize->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (warmDataRatio) {
      res["WarmDataRatio"] = warmDataRatio ? boost::any(warmDataRatio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (warmDataSize) {
      res["WarmDataSize"] = warmDataSize ? boost::any(warmDataSize->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (warmDataSizeDayGrowthRatio) {
      res["WarmDataSizeDayGrowthRatio"] = warmDataSizeDayGrowthRatio ? boost::any(warmDataSizeDayGrowthRatio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ColdDataDayGrowthSize") != m.end() && !m["ColdDataDayGrowthSize"].empty()) {
      if (typeid(map<string, boost::any>) == m["ColdDataDayGrowthSize"].type()) {
        GetDoctorHiveTableResponseBodyDataMetricsColdDataDayGrowthSize model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ColdDataDayGrowthSize"]));
        coldDataDayGrowthSize = make_shared<GetDoctorHiveTableResponseBodyDataMetricsColdDataDayGrowthSize>(model1);
      }
    }
    if (m.find("ColdDataRatio") != m.end() && !m["ColdDataRatio"].empty()) {
      if (typeid(map<string, boost::any>) == m["ColdDataRatio"].type()) {
        GetDoctorHiveTableResponseBodyDataMetricsColdDataRatio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ColdDataRatio"]));
        coldDataRatio = make_shared<GetDoctorHiveTableResponseBodyDataMetricsColdDataRatio>(model1);
      }
    }
    if (m.find("ColdDataSize") != m.end() && !m["ColdDataSize"].empty()) {
      if (typeid(map<string, boost::any>) == m["ColdDataSize"].type()) {
        GetDoctorHiveTableResponseBodyDataMetricsColdDataSize model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ColdDataSize"]));
        coldDataSize = make_shared<GetDoctorHiveTableResponseBodyDataMetricsColdDataSize>(model1);
      }
    }
    if (m.find("ColdDataSizeDayGrowthRatio") != m.end() && !m["ColdDataSizeDayGrowthRatio"].empty()) {
      if (typeid(map<string, boost::any>) == m["ColdDataSizeDayGrowthRatio"].type()) {
        GetDoctorHiveTableResponseBodyDataMetricsColdDataSizeDayGrowthRatio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ColdDataSizeDayGrowthRatio"]));
        coldDataSizeDayGrowthRatio = make_shared<GetDoctorHiveTableResponseBodyDataMetricsColdDataSizeDayGrowthRatio>(model1);
      }
    }
    if (m.find("EmptyFileCount") != m.end() && !m["EmptyFileCount"].empty()) {
      if (typeid(map<string, boost::any>) == m["EmptyFileCount"].type()) {
        GetDoctorHiveTableResponseBodyDataMetricsEmptyFileCount model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EmptyFileCount"]));
        emptyFileCount = make_shared<GetDoctorHiveTableResponseBodyDataMetricsEmptyFileCount>(model1);
      }
    }
    if (m.find("EmptyFileCountDayGrowthRatio") != m.end() && !m["EmptyFileCountDayGrowthRatio"].empty()) {
      if (typeid(map<string, boost::any>) == m["EmptyFileCountDayGrowthRatio"].type()) {
        GetDoctorHiveTableResponseBodyDataMetricsEmptyFileCountDayGrowthRatio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EmptyFileCountDayGrowthRatio"]));
        emptyFileCountDayGrowthRatio = make_shared<GetDoctorHiveTableResponseBodyDataMetricsEmptyFileCountDayGrowthRatio>(model1);
      }
    }
    if (m.find("EmptyFileDayGrowthCount") != m.end() && !m["EmptyFileDayGrowthCount"].empty()) {
      if (typeid(map<string, boost::any>) == m["EmptyFileDayGrowthCount"].type()) {
        GetDoctorHiveTableResponseBodyDataMetricsEmptyFileDayGrowthCount model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EmptyFileDayGrowthCount"]));
        emptyFileDayGrowthCount = make_shared<GetDoctorHiveTableResponseBodyDataMetricsEmptyFileDayGrowthCount>(model1);
      }
    }
    if (m.find("EmptyFileRatio") != m.end() && !m["EmptyFileRatio"].empty()) {
      if (typeid(map<string, boost::any>) == m["EmptyFileRatio"].type()) {
        GetDoctorHiveTableResponseBodyDataMetricsEmptyFileRatio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EmptyFileRatio"]));
        emptyFileRatio = make_shared<GetDoctorHiveTableResponseBodyDataMetricsEmptyFileRatio>(model1);
      }
    }
    if (m.find("FreezeDataDayGrowthSize") != m.end() && !m["FreezeDataDayGrowthSize"].empty()) {
      if (typeid(map<string, boost::any>) == m["FreezeDataDayGrowthSize"].type()) {
        GetDoctorHiveTableResponseBodyDataMetricsFreezeDataDayGrowthSize model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FreezeDataDayGrowthSize"]));
        freezeDataDayGrowthSize = make_shared<GetDoctorHiveTableResponseBodyDataMetricsFreezeDataDayGrowthSize>(model1);
      }
    }
    if (m.find("FreezeDataRatio") != m.end() && !m["FreezeDataRatio"].empty()) {
      if (typeid(map<string, boost::any>) == m["FreezeDataRatio"].type()) {
        GetDoctorHiveTableResponseBodyDataMetricsFreezeDataRatio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FreezeDataRatio"]));
        freezeDataRatio = make_shared<GetDoctorHiveTableResponseBodyDataMetricsFreezeDataRatio>(model1);
      }
    }
    if (m.find("FreezeDataSize") != m.end() && !m["FreezeDataSize"].empty()) {
      if (typeid(map<string, boost::any>) == m["FreezeDataSize"].type()) {
        GetDoctorHiveTableResponseBodyDataMetricsFreezeDataSize model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FreezeDataSize"]));
        freezeDataSize = make_shared<GetDoctorHiveTableResponseBodyDataMetricsFreezeDataSize>(model1);
      }
    }
    if (m.find("FreezeDataSizeDayGrowthRatio") != m.end() && !m["FreezeDataSizeDayGrowthRatio"].empty()) {
      if (typeid(map<string, boost::any>) == m["FreezeDataSizeDayGrowthRatio"].type()) {
        GetDoctorHiveTableResponseBodyDataMetricsFreezeDataSizeDayGrowthRatio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FreezeDataSizeDayGrowthRatio"]));
        freezeDataSizeDayGrowthRatio = make_shared<GetDoctorHiveTableResponseBodyDataMetricsFreezeDataSizeDayGrowthRatio>(model1);
      }
    }
    if (m.find("HotDataDayGrowthSize") != m.end() && !m["HotDataDayGrowthSize"].empty()) {
      if (typeid(map<string, boost::any>) == m["HotDataDayGrowthSize"].type()) {
        GetDoctorHiveTableResponseBodyDataMetricsHotDataDayGrowthSize model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["HotDataDayGrowthSize"]));
        hotDataDayGrowthSize = make_shared<GetDoctorHiveTableResponseBodyDataMetricsHotDataDayGrowthSize>(model1);
      }
    }
    if (m.find("HotDataRatio") != m.end() && !m["HotDataRatio"].empty()) {
      if (typeid(map<string, boost::any>) == m["HotDataRatio"].type()) {
        GetDoctorHiveTableResponseBodyDataMetricsHotDataRatio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["HotDataRatio"]));
        hotDataRatio = make_shared<GetDoctorHiveTableResponseBodyDataMetricsHotDataRatio>(model1);
      }
    }
    if (m.find("HotDataSize") != m.end() && !m["HotDataSize"].empty()) {
      if (typeid(map<string, boost::any>) == m["HotDataSize"].type()) {
        GetDoctorHiveTableResponseBodyDataMetricsHotDataSize model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["HotDataSize"]));
        hotDataSize = make_shared<GetDoctorHiveTableResponseBodyDataMetricsHotDataSize>(model1);
      }
    }
    if (m.find("HotDataSizeDayGrowthRatio") != m.end() && !m["HotDataSizeDayGrowthRatio"].empty()) {
      if (typeid(map<string, boost::any>) == m["HotDataSizeDayGrowthRatio"].type()) {
        GetDoctorHiveTableResponseBodyDataMetricsHotDataSizeDayGrowthRatio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["HotDataSizeDayGrowthRatio"]));
        hotDataSizeDayGrowthRatio = make_shared<GetDoctorHiveTableResponseBodyDataMetricsHotDataSizeDayGrowthRatio>(model1);
      }
    }
    if (m.find("LargeFileCount") != m.end() && !m["LargeFileCount"].empty()) {
      if (typeid(map<string, boost::any>) == m["LargeFileCount"].type()) {
        GetDoctorHiveTableResponseBodyDataMetricsLargeFileCount model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LargeFileCount"]));
        largeFileCount = make_shared<GetDoctorHiveTableResponseBodyDataMetricsLargeFileCount>(model1);
      }
    }
    if (m.find("LargeFileCountDayGrowthRatio") != m.end() && !m["LargeFileCountDayGrowthRatio"].empty()) {
      if (typeid(map<string, boost::any>) == m["LargeFileCountDayGrowthRatio"].type()) {
        GetDoctorHiveTableResponseBodyDataMetricsLargeFileCountDayGrowthRatio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LargeFileCountDayGrowthRatio"]));
        largeFileCountDayGrowthRatio = make_shared<GetDoctorHiveTableResponseBodyDataMetricsLargeFileCountDayGrowthRatio>(model1);
      }
    }
    if (m.find("LargeFileDayGrowthCount") != m.end() && !m["LargeFileDayGrowthCount"].empty()) {
      if (typeid(map<string, boost::any>) == m["LargeFileDayGrowthCount"].type()) {
        GetDoctorHiveTableResponseBodyDataMetricsLargeFileDayGrowthCount model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LargeFileDayGrowthCount"]));
        largeFileDayGrowthCount = make_shared<GetDoctorHiveTableResponseBodyDataMetricsLargeFileDayGrowthCount>(model1);
      }
    }
    if (m.find("LargeFileRatio") != m.end() && !m["LargeFileRatio"].empty()) {
      if (typeid(map<string, boost::any>) == m["LargeFileRatio"].type()) {
        GetDoctorHiveTableResponseBodyDataMetricsLargeFileRatio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LargeFileRatio"]));
        largeFileRatio = make_shared<GetDoctorHiveTableResponseBodyDataMetricsLargeFileRatio>(model1);
      }
    }
    if (m.find("MediumFileCount") != m.end() && !m["MediumFileCount"].empty()) {
      if (typeid(map<string, boost::any>) == m["MediumFileCount"].type()) {
        GetDoctorHiveTableResponseBodyDataMetricsMediumFileCount model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MediumFileCount"]));
        mediumFileCount = make_shared<GetDoctorHiveTableResponseBodyDataMetricsMediumFileCount>(model1);
      }
    }
    if (m.find("MediumFileCountDayGrowthRatio") != m.end() && !m["MediumFileCountDayGrowthRatio"].empty()) {
      if (typeid(map<string, boost::any>) == m["MediumFileCountDayGrowthRatio"].type()) {
        GetDoctorHiveTableResponseBodyDataMetricsMediumFileCountDayGrowthRatio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MediumFileCountDayGrowthRatio"]));
        mediumFileCountDayGrowthRatio = make_shared<GetDoctorHiveTableResponseBodyDataMetricsMediumFileCountDayGrowthRatio>(model1);
      }
    }
    if (m.find("MediumFileDayGrowthCount") != m.end() && !m["MediumFileDayGrowthCount"].empty()) {
      if (typeid(map<string, boost::any>) == m["MediumFileDayGrowthCount"].type()) {
        GetDoctorHiveTableResponseBodyDataMetricsMediumFileDayGrowthCount model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MediumFileDayGrowthCount"]));
        mediumFileDayGrowthCount = make_shared<GetDoctorHiveTableResponseBodyDataMetricsMediumFileDayGrowthCount>(model1);
      }
    }
    if (m.find("MediumFileRatio") != m.end() && !m["MediumFileRatio"].empty()) {
      if (typeid(map<string, boost::any>) == m["MediumFileRatio"].type()) {
        GetDoctorHiveTableResponseBodyDataMetricsMediumFileRatio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MediumFileRatio"]));
        mediumFileRatio = make_shared<GetDoctorHiveTableResponseBodyDataMetricsMediumFileRatio>(model1);
      }
    }
    if (m.find("PartitionNum") != m.end() && !m["PartitionNum"].empty()) {
      if (typeid(map<string, boost::any>) == m["PartitionNum"].type()) {
        GetDoctorHiveTableResponseBodyDataMetricsPartitionNum model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PartitionNum"]));
        partitionNum = make_shared<GetDoctorHiveTableResponseBodyDataMetricsPartitionNum>(model1);
      }
    }
    if (m.find("SmallFileCount") != m.end() && !m["SmallFileCount"].empty()) {
      if (typeid(map<string, boost::any>) == m["SmallFileCount"].type()) {
        GetDoctorHiveTableResponseBodyDataMetricsSmallFileCount model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SmallFileCount"]));
        smallFileCount = make_shared<GetDoctorHiveTableResponseBodyDataMetricsSmallFileCount>(model1);
      }
    }
    if (m.find("SmallFileCountDayGrowthRatio") != m.end() && !m["SmallFileCountDayGrowthRatio"].empty()) {
      if (typeid(map<string, boost::any>) == m["SmallFileCountDayGrowthRatio"].type()) {
        GetDoctorHiveTableResponseBodyDataMetricsSmallFileCountDayGrowthRatio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SmallFileCountDayGrowthRatio"]));
        smallFileCountDayGrowthRatio = make_shared<GetDoctorHiveTableResponseBodyDataMetricsSmallFileCountDayGrowthRatio>(model1);
      }
    }
    if (m.find("SmallFileDayGrowthCount") != m.end() && !m["SmallFileDayGrowthCount"].empty()) {
      if (typeid(map<string, boost::any>) == m["SmallFileDayGrowthCount"].type()) {
        GetDoctorHiveTableResponseBodyDataMetricsSmallFileDayGrowthCount model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SmallFileDayGrowthCount"]));
        smallFileDayGrowthCount = make_shared<GetDoctorHiveTableResponseBodyDataMetricsSmallFileDayGrowthCount>(model1);
      }
    }
    if (m.find("SmallFileRatio") != m.end() && !m["SmallFileRatio"].empty()) {
      if (typeid(map<string, boost::any>) == m["SmallFileRatio"].type()) {
        GetDoctorHiveTableResponseBodyDataMetricsSmallFileRatio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SmallFileRatio"]));
        smallFileRatio = make_shared<GetDoctorHiveTableResponseBodyDataMetricsSmallFileRatio>(model1);
      }
    }
    if (m.find("TinyFileCount") != m.end() && !m["TinyFileCount"].empty()) {
      if (typeid(map<string, boost::any>) == m["TinyFileCount"].type()) {
        GetDoctorHiveTableResponseBodyDataMetricsTinyFileCount model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TinyFileCount"]));
        tinyFileCount = make_shared<GetDoctorHiveTableResponseBodyDataMetricsTinyFileCount>(model1);
      }
    }
    if (m.find("TinyFileCountDayGrowthRatio") != m.end() && !m["TinyFileCountDayGrowthRatio"].empty()) {
      if (typeid(map<string, boost::any>) == m["TinyFileCountDayGrowthRatio"].type()) {
        GetDoctorHiveTableResponseBodyDataMetricsTinyFileCountDayGrowthRatio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TinyFileCountDayGrowthRatio"]));
        tinyFileCountDayGrowthRatio = make_shared<GetDoctorHiveTableResponseBodyDataMetricsTinyFileCountDayGrowthRatio>(model1);
      }
    }
    if (m.find("TinyFileDayGrowthCount") != m.end() && !m["TinyFileDayGrowthCount"].empty()) {
      if (typeid(map<string, boost::any>) == m["TinyFileDayGrowthCount"].type()) {
        GetDoctorHiveTableResponseBodyDataMetricsTinyFileDayGrowthCount model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TinyFileDayGrowthCount"]));
        tinyFileDayGrowthCount = make_shared<GetDoctorHiveTableResponseBodyDataMetricsTinyFileDayGrowthCount>(model1);
      }
    }
    if (m.find("TinyFileRatio") != m.end() && !m["TinyFileRatio"].empty()) {
      if (typeid(map<string, boost::any>) == m["TinyFileRatio"].type()) {
        GetDoctorHiveTableResponseBodyDataMetricsTinyFileRatio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TinyFileRatio"]));
        tinyFileRatio = make_shared<GetDoctorHiveTableResponseBodyDataMetricsTinyFileRatio>(model1);
      }
    }
    if (m.find("TotalDataDayGrowthSize") != m.end() && !m["TotalDataDayGrowthSize"].empty()) {
      if (typeid(map<string, boost::any>) == m["TotalDataDayGrowthSize"].type()) {
        GetDoctorHiveTableResponseBodyDataMetricsTotalDataDayGrowthSize model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TotalDataDayGrowthSize"]));
        totalDataDayGrowthSize = make_shared<GetDoctorHiveTableResponseBodyDataMetricsTotalDataDayGrowthSize>(model1);
      }
    }
    if (m.find("TotalDataSize") != m.end() && !m["TotalDataSize"].empty()) {
      if (typeid(map<string, boost::any>) == m["TotalDataSize"].type()) {
        GetDoctorHiveTableResponseBodyDataMetricsTotalDataSize model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TotalDataSize"]));
        totalDataSize = make_shared<GetDoctorHiveTableResponseBodyDataMetricsTotalDataSize>(model1);
      }
    }
    if (m.find("TotalDataSizeDayGrowthRatio") != m.end() && !m["TotalDataSizeDayGrowthRatio"].empty()) {
      if (typeid(map<string, boost::any>) == m["TotalDataSizeDayGrowthRatio"].type()) {
        GetDoctorHiveTableResponseBodyDataMetricsTotalDataSizeDayGrowthRatio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TotalDataSizeDayGrowthRatio"]));
        totalDataSizeDayGrowthRatio = make_shared<GetDoctorHiveTableResponseBodyDataMetricsTotalDataSizeDayGrowthRatio>(model1);
      }
    }
    if (m.find("TotalFileCount") != m.end() && !m["TotalFileCount"].empty()) {
      if (typeid(map<string, boost::any>) == m["TotalFileCount"].type()) {
        GetDoctorHiveTableResponseBodyDataMetricsTotalFileCount model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TotalFileCount"]));
        totalFileCount = make_shared<GetDoctorHiveTableResponseBodyDataMetricsTotalFileCount>(model1);
      }
    }
    if (m.find("TotalFileCountDayGrowthRatio") != m.end() && !m["TotalFileCountDayGrowthRatio"].empty()) {
      if (typeid(map<string, boost::any>) == m["TotalFileCountDayGrowthRatio"].type()) {
        GetDoctorHiveTableResponseBodyDataMetricsTotalFileCountDayGrowthRatio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TotalFileCountDayGrowthRatio"]));
        totalFileCountDayGrowthRatio = make_shared<GetDoctorHiveTableResponseBodyDataMetricsTotalFileCountDayGrowthRatio>(model1);
      }
    }
    if (m.find("TotalFileDayGrowthCount") != m.end() && !m["TotalFileDayGrowthCount"].empty()) {
      if (typeid(map<string, boost::any>) == m["TotalFileDayGrowthCount"].type()) {
        GetDoctorHiveTableResponseBodyDataMetricsTotalFileDayGrowthCount model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TotalFileDayGrowthCount"]));
        totalFileDayGrowthCount = make_shared<GetDoctorHiveTableResponseBodyDataMetricsTotalFileDayGrowthCount>(model1);
      }
    }
    if (m.find("WarmDataDayGrowthSize") != m.end() && !m["WarmDataDayGrowthSize"].empty()) {
      if (typeid(map<string, boost::any>) == m["WarmDataDayGrowthSize"].type()) {
        GetDoctorHiveTableResponseBodyDataMetricsWarmDataDayGrowthSize model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["WarmDataDayGrowthSize"]));
        warmDataDayGrowthSize = make_shared<GetDoctorHiveTableResponseBodyDataMetricsWarmDataDayGrowthSize>(model1);
      }
    }
    if (m.find("WarmDataRatio") != m.end() && !m["WarmDataRatio"].empty()) {
      if (typeid(map<string, boost::any>) == m["WarmDataRatio"].type()) {
        GetDoctorHiveTableResponseBodyDataMetricsWarmDataRatio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["WarmDataRatio"]));
        warmDataRatio = make_shared<GetDoctorHiveTableResponseBodyDataMetricsWarmDataRatio>(model1);
      }
    }
    if (m.find("WarmDataSize") != m.end() && !m["WarmDataSize"].empty()) {
      if (typeid(map<string, boost::any>) == m["WarmDataSize"].type()) {
        GetDoctorHiveTableResponseBodyDataMetricsWarmDataSize model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["WarmDataSize"]));
        warmDataSize = make_shared<GetDoctorHiveTableResponseBodyDataMetricsWarmDataSize>(model1);
      }
    }
    if (m.find("WarmDataSizeDayGrowthRatio") != m.end() && !m["WarmDataSizeDayGrowthRatio"].empty()) {
      if (typeid(map<string, boost::any>) == m["WarmDataSizeDayGrowthRatio"].type()) {
        GetDoctorHiveTableResponseBodyDataMetricsWarmDataSizeDayGrowthRatio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["WarmDataSizeDayGrowthRatio"]));
        warmDataSizeDayGrowthRatio = make_shared<GetDoctorHiveTableResponseBodyDataMetricsWarmDataSizeDayGrowthRatio>(model1);
      }
    }
  }


  virtual ~GetDoctorHiveTableResponseBodyDataMetrics() = default;
};
class GetDoctorHiveTableResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<GetDoctorHiveTableResponseBodyDataAnalysis> analysis{};
  shared_ptr<vector<GetDoctorHiveTableResponseBodyDataFormats>> formats{};
  shared_ptr<GetDoctorHiveTableResponseBodyDataMetrics> metrics{};
  shared_ptr<string> owner{};

  GetDoctorHiveTableResponseBodyData() {}

  explicit GetDoctorHiveTableResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (analysis) {
      res["Analysis"] = analysis ? boost::any(analysis->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (formats) {
      vector<boost::any> temp1;
      for(auto item1:*formats){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Formats"] = boost::any(temp1);
    }
    if (metrics) {
      res["Metrics"] = metrics ? boost::any(metrics->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Analysis") != m.end() && !m["Analysis"].empty()) {
      if (typeid(map<string, boost::any>) == m["Analysis"].type()) {
        GetDoctorHiveTableResponseBodyDataAnalysis model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Analysis"]));
        analysis = make_shared<GetDoctorHiveTableResponseBodyDataAnalysis>(model1);
      }
    }
    if (m.find("Formats") != m.end() && !m["Formats"].empty()) {
      if (typeid(vector<boost::any>) == m["Formats"].type()) {
        vector<GetDoctorHiveTableResponseBodyDataFormats> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Formats"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetDoctorHiveTableResponseBodyDataFormats model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        formats = make_shared<vector<GetDoctorHiveTableResponseBodyDataFormats>>(expect1);
      }
    }
    if (m.find("Metrics") != m.end() && !m["Metrics"].empty()) {
      if (typeid(map<string, boost::any>) == m["Metrics"].type()) {
        GetDoctorHiveTableResponseBodyDataMetrics model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Metrics"]));
        metrics = make_shared<GetDoctorHiveTableResponseBodyDataMetrics>(model1);
      }
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
  }


  virtual ~GetDoctorHiveTableResponseBodyData() = default;
};
class GetDoctorHiveTableResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetDoctorHiveTableResponseBodyData> data{};
  shared_ptr<string> requestId{};

  GetDoctorHiveTableResponseBody() {}

  explicit GetDoctorHiveTableResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetDoctorHiveTableResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetDoctorHiveTableResponseBodyData>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetDoctorHiveTableResponseBody() = default;
};
class GetDoctorHiveTableResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetDoctorHiveTableResponseBody> body{};

  GetDoctorHiveTableResponse() {}

  explicit GetDoctorHiveTableResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetDoctorHiveTableResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetDoctorHiveTableResponseBody>(model1);
      }
    }
  }


  virtual ~GetDoctorHiveTableResponse() = default;
};
class GetDoctorJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> regionId{};

  GetDoctorJobRequest() {}

  explicit GetDoctorJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~GetDoctorJobRequest() = default;
};
class GetDoctorJobResponseBodyDataMetricsMemSeconds : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  GetDoctorJobResponseBodyDataMetricsMemSeconds() {}

  explicit GetDoctorJobResponseBodyDataMetricsMemSeconds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~GetDoctorJobResponseBodyDataMetricsMemSeconds() = default;
};
class GetDoctorJobResponseBodyDataMetricsVcoreSeconds : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  GetDoctorJobResponseBodyDataMetricsVcoreSeconds() {}

  explicit GetDoctorJobResponseBodyDataMetricsVcoreSeconds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~GetDoctorJobResponseBodyDataMetricsVcoreSeconds() = default;
};
class GetDoctorJobResponseBodyDataMetrics : public Darabonba::Model {
public:
  shared_ptr<GetDoctorJobResponseBodyDataMetricsMemSeconds> memSeconds{};
  shared_ptr<GetDoctorJobResponseBodyDataMetricsVcoreSeconds> vcoreSeconds{};

  GetDoctorJobResponseBodyDataMetrics() {}

  explicit GetDoctorJobResponseBodyDataMetrics(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (memSeconds) {
      res["MemSeconds"] = memSeconds ? boost::any(memSeconds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (vcoreSeconds) {
      res["VcoreSeconds"] = vcoreSeconds ? boost::any(vcoreSeconds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MemSeconds") != m.end() && !m["MemSeconds"].empty()) {
      if (typeid(map<string, boost::any>) == m["MemSeconds"].type()) {
        GetDoctorJobResponseBodyDataMetricsMemSeconds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MemSeconds"]));
        memSeconds = make_shared<GetDoctorJobResponseBodyDataMetricsMemSeconds>(model1);
      }
    }
    if (m.find("VcoreSeconds") != m.end() && !m["VcoreSeconds"].empty()) {
      if (typeid(map<string, boost::any>) == m["VcoreSeconds"].type()) {
        GetDoctorJobResponseBodyDataMetricsVcoreSeconds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VcoreSeconds"]));
        vcoreSeconds = make_shared<GetDoctorJobResponseBodyDataMetricsVcoreSeconds>(model1);
      }
    }
  }


  virtual ~GetDoctorJobResponseBodyDataMetrics() = default;
};
class GetDoctorJobResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> appName{};
  shared_ptr<long> elapsedTime{};
  shared_ptr<string> finalStatus{};
  shared_ptr<long> finishTime{};
  shared_ptr<long> launchTime{};
  shared_ptr<GetDoctorJobResponseBodyDataMetrics> metrics{};
  shared_ptr<string> queue{};
  shared_ptr<long> startTime{};
  shared_ptr<string> state{};
  shared_ptr<string> type{};
  shared_ptr<string> user{};

  GetDoctorJobResponseBodyData() {}

  explicit GetDoctorJobResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (elapsedTime) {
      res["ElapsedTime"] = boost::any(*elapsedTime);
    }
    if (finalStatus) {
      res["FinalStatus"] = boost::any(*finalStatus);
    }
    if (finishTime) {
      res["FinishTime"] = boost::any(*finishTime);
    }
    if (launchTime) {
      res["LaunchTime"] = boost::any(*launchTime);
    }
    if (metrics) {
      res["Metrics"] = metrics ? boost::any(metrics->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (queue) {
      res["Queue"] = boost::any(*queue);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (user) {
      res["User"] = boost::any(*user);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("ElapsedTime") != m.end() && !m["ElapsedTime"].empty()) {
      elapsedTime = make_shared<long>(boost::any_cast<long>(m["ElapsedTime"]));
    }
    if (m.find("FinalStatus") != m.end() && !m["FinalStatus"].empty()) {
      finalStatus = make_shared<string>(boost::any_cast<string>(m["FinalStatus"]));
    }
    if (m.find("FinishTime") != m.end() && !m["FinishTime"].empty()) {
      finishTime = make_shared<long>(boost::any_cast<long>(m["FinishTime"]));
    }
    if (m.find("LaunchTime") != m.end() && !m["LaunchTime"].empty()) {
      launchTime = make_shared<long>(boost::any_cast<long>(m["LaunchTime"]));
    }
    if (m.find("Metrics") != m.end() && !m["Metrics"].empty()) {
      if (typeid(map<string, boost::any>) == m["Metrics"].type()) {
        GetDoctorJobResponseBodyDataMetrics model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Metrics"]));
        metrics = make_shared<GetDoctorJobResponseBodyDataMetrics>(model1);
      }
    }
    if (m.find("Queue") != m.end() && !m["Queue"].empty()) {
      queue = make_shared<string>(boost::any_cast<string>(m["Queue"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("User") != m.end() && !m["User"].empty()) {
      user = make_shared<string>(boost::any_cast<string>(m["User"]));
    }
  }


  virtual ~GetDoctorJobResponseBodyData() = default;
};
class GetDoctorJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetDoctorJobResponseBodyData> data{};
  shared_ptr<string> requestId{};

  GetDoctorJobResponseBody() {}

  explicit GetDoctorJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetDoctorJobResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetDoctorJobResponseBodyData>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetDoctorJobResponseBody() = default;
};
class GetDoctorJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetDoctorJobResponseBody> body{};

  GetDoctorJobResponse() {}

  explicit GetDoctorJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetDoctorJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetDoctorJobResponseBody>(model1);
      }
    }
  }


  virtual ~GetDoctorJobResponse() = default;
};
class GetDoctorReportComponentSummaryRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> componentType{};
  shared_ptr<string> dateTime{};
  shared_ptr<string> regionId{};

  GetDoctorReportComponentSummaryRequest() {}

  explicit GetDoctorReportComponentSummaryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (componentType) {
      res["ComponentType"] = boost::any(*componentType);
    }
    if (dateTime) {
      res["DateTime"] = boost::any(*dateTime);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("ComponentType") != m.end() && !m["ComponentType"].empty()) {
      componentType = make_shared<string>(boost::any_cast<string>(m["ComponentType"]));
    }
    if (m.find("DateTime") != m.end() && !m["DateTime"].empty()) {
      dateTime = make_shared<string>(boost::any_cast<string>(m["DateTime"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~GetDoctorReportComponentSummaryRequest() = default;
};
class GetDoctorReportComponentSummaryResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> score{};
  shared_ptr<string> suggestion{};
  shared_ptr<string> summary{};

  GetDoctorReportComponentSummaryResponseBodyData() {}

  explicit GetDoctorReportComponentSummaryResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (score) {
      res["Score"] = boost::any(*score);
    }
    if (suggestion) {
      res["Suggestion"] = boost::any(*suggestion);
    }
    if (summary) {
      res["Summary"] = boost::any(*summary);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Score") != m.end() && !m["Score"].empty()) {
      score = make_shared<long>(boost::any_cast<long>(m["Score"]));
    }
    if (m.find("Suggestion") != m.end() && !m["Suggestion"].empty()) {
      suggestion = make_shared<string>(boost::any_cast<string>(m["Suggestion"]));
    }
    if (m.find("Summary") != m.end() && !m["Summary"].empty()) {
      summary = make_shared<string>(boost::any_cast<string>(m["Summary"]));
    }
  }


  virtual ~GetDoctorReportComponentSummaryResponseBodyData() = default;
};
class GetDoctorReportComponentSummaryResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetDoctorReportComponentSummaryResponseBodyData> data{};
  shared_ptr<string> requestId{};

  GetDoctorReportComponentSummaryResponseBody() {}

  explicit GetDoctorReportComponentSummaryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetDoctorReportComponentSummaryResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetDoctorReportComponentSummaryResponseBodyData>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetDoctorReportComponentSummaryResponseBody() = default;
};
class GetDoctorReportComponentSummaryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetDoctorReportComponentSummaryResponseBody> body{};

  GetDoctorReportComponentSummaryResponse() {}

  explicit GetDoctorReportComponentSummaryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetDoctorReportComponentSummaryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetDoctorReportComponentSummaryResponseBody>(model1);
      }
    }
  }


  virtual ~GetDoctorReportComponentSummaryResponse() = default;
};
class GetNodeGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> nodeGroupId{};
  shared_ptr<string> regionId{};

  GetNodeGroupRequest() {}

  explicit GetNodeGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (nodeGroupId) {
      res["NodeGroupId"] = boost::any(*nodeGroupId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("NodeGroupId") != m.end() && !m["NodeGroupId"].empty()) {
      nodeGroupId = make_shared<string>(boost::any_cast<string>(m["NodeGroupId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~GetNodeGroupRequest() = default;
};
class GetNodeGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<NodeGroup> nodeGroup{};
  shared_ptr<string> requestId{};

  GetNodeGroupResponseBody() {}

  explicit GetNodeGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nodeGroup) {
      res["NodeGroup"] = nodeGroup ? boost::any(nodeGroup->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NodeGroup") != m.end() && !m["NodeGroup"].empty()) {
      if (typeid(map<string, boost::any>) == m["NodeGroup"].type()) {
        NodeGroup model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NodeGroup"]));
        nodeGroup = make_shared<NodeGroup>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetNodeGroupResponseBody() = default;
};
class GetNodeGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetNodeGroupResponseBody> body{};

  GetNodeGroupResponse() {}

  explicit GetNodeGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetNodeGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetNodeGroupResponseBody>(model1);
      }
    }
  }


  virtual ~GetNodeGroupResponse() = default;
};
class GetOperationRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> operationId{};
  shared_ptr<string> regionId{};

  GetOperationRequest() {}

  explicit GetOperationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (operationId) {
      res["OperationId"] = boost::any(*operationId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("OperationId") != m.end() && !m["OperationId"].empty()) {
      operationId = make_shared<string>(boost::any_cast<string>(m["OperationId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~GetOperationRequest() = default;
};
class GetOperationResponseBody : public Darabonba::Model {
public:
  shared_ptr<Operation> operation{};
  shared_ptr<string> requestId{};

  GetOperationResponseBody() {}

  explicit GetOperationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (operation) {
      res["Operation"] = operation ? boost::any(operation->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Operation") != m.end() && !m["Operation"].empty()) {
      if (typeid(map<string, boost::any>) == m["Operation"].type()) {
        Operation model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Operation"]));
        operation = make_shared<Operation>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetOperationResponseBody() = default;
};
class GetOperationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetOperationResponseBody> body{};

  GetOperationResponse() {}

  explicit GetOperationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetOperationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetOperationResponseBody>(model1);
      }
    }
  }


  virtual ~GetOperationResponse() = default;
};
class IncreaseNodesRequest : public Darabonba::Model {
public:
  shared_ptr<vector<ApplicationConfig>> applicationConfigs{};
  shared_ptr<bool> autoPayOrder{};
  shared_ptr<bool> autoRenew{};
  shared_ptr<string> clusterId{};
  shared_ptr<long> increaseNodeCount{};
  shared_ptr<long> minIncreaseNodeCount{};
  shared_ptr<string> nodeGroupId{};
  shared_ptr<long> paymentDuration{};
  shared_ptr<string> paymentDurationUnit{};
  shared_ptr<string> regionId{};

  IncreaseNodesRequest() {}

  explicit IncreaseNodesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applicationConfigs) {
      vector<boost::any> temp1;
      for(auto item1:*applicationConfigs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ApplicationConfigs"] = boost::any(temp1);
    }
    if (autoPayOrder) {
      res["AutoPayOrder"] = boost::any(*autoPayOrder);
    }
    if (autoRenew) {
      res["AutoRenew"] = boost::any(*autoRenew);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (increaseNodeCount) {
      res["IncreaseNodeCount"] = boost::any(*increaseNodeCount);
    }
    if (minIncreaseNodeCount) {
      res["MinIncreaseNodeCount"] = boost::any(*minIncreaseNodeCount);
    }
    if (nodeGroupId) {
      res["NodeGroupId"] = boost::any(*nodeGroupId);
    }
    if (paymentDuration) {
      res["PaymentDuration"] = boost::any(*paymentDuration);
    }
    if (paymentDurationUnit) {
      res["PaymentDurationUnit"] = boost::any(*paymentDurationUnit);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApplicationConfigs") != m.end() && !m["ApplicationConfigs"].empty()) {
      if (typeid(vector<boost::any>) == m["ApplicationConfigs"].type()) {
        vector<ApplicationConfig> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ApplicationConfigs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ApplicationConfig model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        applicationConfigs = make_shared<vector<ApplicationConfig>>(expect1);
      }
    }
    if (m.find("AutoPayOrder") != m.end() && !m["AutoPayOrder"].empty()) {
      autoPayOrder = make_shared<bool>(boost::any_cast<bool>(m["AutoPayOrder"]));
    }
    if (m.find("AutoRenew") != m.end() && !m["AutoRenew"].empty()) {
      autoRenew = make_shared<bool>(boost::any_cast<bool>(m["AutoRenew"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("IncreaseNodeCount") != m.end() && !m["IncreaseNodeCount"].empty()) {
      increaseNodeCount = make_shared<long>(boost::any_cast<long>(m["IncreaseNodeCount"]));
    }
    if (m.find("MinIncreaseNodeCount") != m.end() && !m["MinIncreaseNodeCount"].empty()) {
      minIncreaseNodeCount = make_shared<long>(boost::any_cast<long>(m["MinIncreaseNodeCount"]));
    }
    if (m.find("NodeGroupId") != m.end() && !m["NodeGroupId"].empty()) {
      nodeGroupId = make_shared<string>(boost::any_cast<string>(m["NodeGroupId"]));
    }
    if (m.find("PaymentDuration") != m.end() && !m["PaymentDuration"].empty()) {
      paymentDuration = make_shared<long>(boost::any_cast<long>(m["PaymentDuration"]));
    }
    if (m.find("PaymentDurationUnit") != m.end() && !m["PaymentDurationUnit"].empty()) {
      paymentDurationUnit = make_shared<string>(boost::any_cast<string>(m["PaymentDurationUnit"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~IncreaseNodesRequest() = default;
};
class IncreaseNodesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> operationId{};
  shared_ptr<string> requestId{};

  IncreaseNodesResponseBody() {}

  explicit IncreaseNodesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (operationId) {
      res["OperationId"] = boost::any(*operationId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OperationId") != m.end() && !m["OperationId"].empty()) {
      operationId = make_shared<string>(boost::any_cast<string>(m["OperationId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~IncreaseNodesResponseBody() = default;
};
class IncreaseNodesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<IncreaseNodesResponseBody> body{};

  IncreaseNodesResponse() {}

  explicit IncreaseNodesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        IncreaseNodesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<IncreaseNodesResponseBody>(model1);
      }
    }
  }


  virtual ~IncreaseNodesResponse() = default;
};
class JoinResourceGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> resourceId{};
  shared_ptr<string> resourceType{};

  JoinResourceGroupRequest() {}

  explicit JoinResourceGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
  }


  virtual ~JoinResourceGroupRequest() = default;
};
class JoinResourceGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  JoinResourceGroupResponseBody() {}

  explicit JoinResourceGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~JoinResourceGroupResponseBody() = default;
};
class JoinResourceGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<JoinResourceGroupResponseBody> body{};

  JoinResourceGroupResponse() {}

  explicit JoinResourceGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        JoinResourceGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<JoinResourceGroupResponseBody>(model1);
      }
    }
  }


  virtual ~JoinResourceGroupResponse() = default;
};
class ListApiTemplatesRequest : public Darabonba::Model {
public:
  shared_ptr<string> apiName{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> templateId{};
  shared_ptr<vector<string>> templateIds{};
  shared_ptr<string> templateName{};

  ListApiTemplatesRequest() {}

  explicit ListApiTemplatesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiName) {
      res["ApiName"] = boost::any(*apiName);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (templateIds) {
      res["TemplateIds"] = boost::any(*templateIds);
    }
    if (templateName) {
      res["TemplateName"] = boost::any(*templateName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiName") != m.end() && !m["ApiName"].empty()) {
      apiName = make_shared<string>(boost::any_cast<string>(m["ApiName"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("TemplateIds") != m.end() && !m["TemplateIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["TemplateIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["TemplateIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      templateIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("TemplateName") != m.end() && !m["TemplateName"].empty()) {
      templateName = make_shared<string>(boost::any_cast<string>(m["TemplateName"]));
    }
  }


  virtual ~ListApiTemplatesRequest() = default;
};
class ListApiTemplatesResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ApiTemplate>> apiTemplates{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ListApiTemplatesResponseBody() {}

  explicit ListApiTemplatesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiTemplates) {
      vector<boost::any> temp1;
      for(auto item1:*apiTemplates){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ApiTemplates"] = boost::any(temp1);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiTemplates") != m.end() && !m["ApiTemplates"].empty()) {
      if (typeid(vector<boost::any>) == m["ApiTemplates"].type()) {
        vector<ApiTemplate> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ApiTemplates"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ApiTemplate model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        apiTemplates = make_shared<vector<ApiTemplate>>(expect1);
      }
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListApiTemplatesResponseBody() = default;
};
class ListApiTemplatesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListApiTemplatesResponseBody> body{};

  ListApiTemplatesResponse() {}

  explicit ListApiTemplatesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListApiTemplatesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListApiTemplatesResponseBody>(model1);
      }
    }
  }


  virtual ~ListApiTemplatesResponse() = default;
};
class ListApplicationConfigsRequest : public Darabonba::Model {
public:
  shared_ptr<string> applicationName{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> configFileName{};
  shared_ptr<string> configItemKey{};
  shared_ptr<string> configItemValue{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> nodeGroupId{};
  shared_ptr<string> nodeId{};
  shared_ptr<string> regionId{};

  ListApplicationConfigsRequest() {}

  explicit ListApplicationConfigsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applicationName) {
      res["ApplicationName"] = boost::any(*applicationName);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (configFileName) {
      res["ConfigFileName"] = boost::any(*configFileName);
    }
    if (configItemKey) {
      res["ConfigItemKey"] = boost::any(*configItemKey);
    }
    if (configItemValue) {
      res["ConfigItemValue"] = boost::any(*configItemValue);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (nodeGroupId) {
      res["NodeGroupId"] = boost::any(*nodeGroupId);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApplicationName") != m.end() && !m["ApplicationName"].empty()) {
      applicationName = make_shared<string>(boost::any_cast<string>(m["ApplicationName"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("ConfigFileName") != m.end() && !m["ConfigFileName"].empty()) {
      configFileName = make_shared<string>(boost::any_cast<string>(m["ConfigFileName"]));
    }
    if (m.find("ConfigItemKey") != m.end() && !m["ConfigItemKey"].empty()) {
      configItemKey = make_shared<string>(boost::any_cast<string>(m["ConfigItemKey"]));
    }
    if (m.find("ConfigItemValue") != m.end() && !m["ConfigItemValue"].empty()) {
      configItemValue = make_shared<string>(boost::any_cast<string>(m["ConfigItemValue"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("NodeGroupId") != m.end() && !m["NodeGroupId"].empty()) {
      nodeGroupId = make_shared<string>(boost::any_cast<string>(m["NodeGroupId"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<string>(boost::any_cast<string>(m["NodeId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~ListApplicationConfigsRequest() = default;
};
class ListApplicationConfigsResponseBodyApplicationConfigs : public Darabonba::Model {
public:
  shared_ptr<string> applicationName{};
  shared_ptr<string> configEffectState{};
  shared_ptr<string> configFileName{};
  shared_ptr<string> configItemKey{};
  shared_ptr<string> configItemValue{};
  shared_ptr<long> createTime{};
  shared_ptr<bool> custom{};
  shared_ptr<string> description{};
  shared_ptr<string> initValue{};
  shared_ptr<string> modifier{};
  shared_ptr<string> nodeGroupId{};
  shared_ptr<string> nodeId{};
  shared_ptr<long> updateTime{};

  ListApplicationConfigsResponseBodyApplicationConfigs() {}

  explicit ListApplicationConfigsResponseBodyApplicationConfigs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applicationName) {
      res["ApplicationName"] = boost::any(*applicationName);
    }
    if (configEffectState) {
      res["ConfigEffectState"] = boost::any(*configEffectState);
    }
    if (configFileName) {
      res["ConfigFileName"] = boost::any(*configFileName);
    }
    if (configItemKey) {
      res["ConfigItemKey"] = boost::any(*configItemKey);
    }
    if (configItemValue) {
      res["ConfigItemValue"] = boost::any(*configItemValue);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (custom) {
      res["Custom"] = boost::any(*custom);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (initValue) {
      res["InitValue"] = boost::any(*initValue);
    }
    if (modifier) {
      res["Modifier"] = boost::any(*modifier);
    }
    if (nodeGroupId) {
      res["NodeGroupId"] = boost::any(*nodeGroupId);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApplicationName") != m.end() && !m["ApplicationName"].empty()) {
      applicationName = make_shared<string>(boost::any_cast<string>(m["ApplicationName"]));
    }
    if (m.find("ConfigEffectState") != m.end() && !m["ConfigEffectState"].empty()) {
      configEffectState = make_shared<string>(boost::any_cast<string>(m["ConfigEffectState"]));
    }
    if (m.find("ConfigFileName") != m.end() && !m["ConfigFileName"].empty()) {
      configFileName = make_shared<string>(boost::any_cast<string>(m["ConfigFileName"]));
    }
    if (m.find("ConfigItemKey") != m.end() && !m["ConfigItemKey"].empty()) {
      configItemKey = make_shared<string>(boost::any_cast<string>(m["ConfigItemKey"]));
    }
    if (m.find("ConfigItemValue") != m.end() && !m["ConfigItemValue"].empty()) {
      configItemValue = make_shared<string>(boost::any_cast<string>(m["ConfigItemValue"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("Custom") != m.end() && !m["Custom"].empty()) {
      custom = make_shared<bool>(boost::any_cast<bool>(m["Custom"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("InitValue") != m.end() && !m["InitValue"].empty()) {
      initValue = make_shared<string>(boost::any_cast<string>(m["InitValue"]));
    }
    if (m.find("Modifier") != m.end() && !m["Modifier"].empty()) {
      modifier = make_shared<string>(boost::any_cast<string>(m["Modifier"]));
    }
    if (m.find("NodeGroupId") != m.end() && !m["NodeGroupId"].empty()) {
      nodeGroupId = make_shared<string>(boost::any_cast<string>(m["NodeGroupId"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<string>(boost::any_cast<string>(m["NodeId"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<long>(boost::any_cast<long>(m["UpdateTime"]));
    }
  }


  virtual ~ListApplicationConfigsResponseBodyApplicationConfigs() = default;
};
class ListApplicationConfigsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListApplicationConfigsResponseBodyApplicationConfigs>> applicationConfigs{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ListApplicationConfigsResponseBody() {}

  explicit ListApplicationConfigsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applicationConfigs) {
      vector<boost::any> temp1;
      for(auto item1:*applicationConfigs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ApplicationConfigs"] = boost::any(temp1);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApplicationConfigs") != m.end() && !m["ApplicationConfigs"].empty()) {
      if (typeid(vector<boost::any>) == m["ApplicationConfigs"].type()) {
        vector<ListApplicationConfigsResponseBodyApplicationConfigs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ApplicationConfigs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListApplicationConfigsResponseBodyApplicationConfigs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        applicationConfigs = make_shared<vector<ListApplicationConfigsResponseBodyApplicationConfigs>>(expect1);
      }
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListApplicationConfigsResponseBody() = default;
};
class ListApplicationConfigsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListApplicationConfigsResponseBody> body{};

  ListApplicationConfigsResponse() {}

  explicit ListApplicationConfigsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListApplicationConfigsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListApplicationConfigsResponseBody>(model1);
      }
    }
  }


  virtual ~ListApplicationConfigsResponse() = default;
};
class ListApplicationsRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> applicationNames{};
  shared_ptr<string> clusterId{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> regionId{};

  ListApplicationsRequest() {}

  explicit ListApplicationsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applicationNames) {
      res["ApplicationNames"] = boost::any(*applicationNames);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApplicationNames") != m.end() && !m["ApplicationNames"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ApplicationNames"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ApplicationNames"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      applicationNames = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~ListApplicationsRequest() = default;
};
class ListApplicationsResponseBodyApplications : public Darabonba::Model {
public:
  shared_ptr<string> applicationName{};
  shared_ptr<string> applicationState{};
  shared_ptr<string> applicationVersion{};
  shared_ptr<string> communityVersion{};

  ListApplicationsResponseBodyApplications() {}

  explicit ListApplicationsResponseBodyApplications(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applicationName) {
      res["ApplicationName"] = boost::any(*applicationName);
    }
    if (applicationState) {
      res["ApplicationState"] = boost::any(*applicationState);
    }
    if (applicationVersion) {
      res["ApplicationVersion"] = boost::any(*applicationVersion);
    }
    if (communityVersion) {
      res["CommunityVersion"] = boost::any(*communityVersion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApplicationName") != m.end() && !m["ApplicationName"].empty()) {
      applicationName = make_shared<string>(boost::any_cast<string>(m["ApplicationName"]));
    }
    if (m.find("ApplicationState") != m.end() && !m["ApplicationState"].empty()) {
      applicationState = make_shared<string>(boost::any_cast<string>(m["ApplicationState"]));
    }
    if (m.find("ApplicationVersion") != m.end() && !m["ApplicationVersion"].empty()) {
      applicationVersion = make_shared<string>(boost::any_cast<string>(m["ApplicationVersion"]));
    }
    if (m.find("CommunityVersion") != m.end() && !m["CommunityVersion"].empty()) {
      communityVersion = make_shared<string>(boost::any_cast<string>(m["CommunityVersion"]));
    }
  }


  virtual ~ListApplicationsResponseBodyApplications() = default;
};
class ListApplicationsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListApplicationsResponseBodyApplications>> applications{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ListApplicationsResponseBody() {}

  explicit ListApplicationsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applications) {
      vector<boost::any> temp1;
      for(auto item1:*applications){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Applications"] = boost::any(temp1);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Applications") != m.end() && !m["Applications"].empty()) {
      if (typeid(vector<boost::any>) == m["Applications"].type()) {
        vector<ListApplicationsResponseBodyApplications> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Applications"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListApplicationsResponseBodyApplications model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        applications = make_shared<vector<ListApplicationsResponseBodyApplications>>(expect1);
      }
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListApplicationsResponseBody() = default;
};
class ListApplicationsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListApplicationsResponseBody> body{};

  ListApplicationsResponse() {}

  explicit ListApplicationsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListApplicationsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListApplicationsResponseBody>(model1);
      }
    }
  }


  virtual ~ListApplicationsResponse() = default;
};
class ListAutoScalingActivitiesRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<long> endTime{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> nodeGroupId{};
  shared_ptr<string> regionId{};
  shared_ptr<vector<string>> scalingActivityStates{};
  shared_ptr<string> scalingActivityType{};
  shared_ptr<string> scalingRuleName{};
  shared_ptr<long> startTime{};

  ListAutoScalingActivitiesRequest() {}

  explicit ListAutoScalingActivitiesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (nodeGroupId) {
      res["NodeGroupId"] = boost::any(*nodeGroupId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (scalingActivityStates) {
      res["ScalingActivityStates"] = boost::any(*scalingActivityStates);
    }
    if (scalingActivityType) {
      res["ScalingActivityType"] = boost::any(*scalingActivityType);
    }
    if (scalingRuleName) {
      res["ScalingRuleName"] = boost::any(*scalingRuleName);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("NodeGroupId") != m.end() && !m["NodeGroupId"].empty()) {
      nodeGroupId = make_shared<string>(boost::any_cast<string>(m["NodeGroupId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ScalingActivityStates") != m.end() && !m["ScalingActivityStates"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ScalingActivityStates"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ScalingActivityStates"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      scalingActivityStates = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ScalingActivityType") != m.end() && !m["ScalingActivityType"].empty()) {
      scalingActivityType = make_shared<string>(boost::any_cast<string>(m["ScalingActivityType"]));
    }
    if (m.find("ScalingRuleName") != m.end() && !m["ScalingRuleName"].empty()) {
      scalingRuleName = make_shared<string>(boost::any_cast<string>(m["ScalingRuleName"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
  }


  virtual ~ListAutoScalingActivitiesRequest() = default;
};
class ListAutoScalingActivitiesResponseBodyScalingActivities : public Darabonba::Model {
public:
  shared_ptr<string> activityId{};
  shared_ptr<string> activityState{};
  shared_ptr<string> activityType{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> description{};
  shared_ptr<long> endTime{};
  shared_ptr<long> expectNum{};
  shared_ptr<string> nodeGroupId{};
  shared_ptr<string> nodeGroupName{};
  shared_ptr<string> operationId{};
  shared_ptr<string> ruleName{};
  shared_ptr<long> startTime{};

  ListAutoScalingActivitiesResponseBodyScalingActivities() {}

  explicit ListAutoScalingActivitiesResponseBodyScalingActivities(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (activityId) {
      res["ActivityId"] = boost::any(*activityId);
    }
    if (activityState) {
      res["ActivityState"] = boost::any(*activityState);
    }
    if (activityType) {
      res["ActivityType"] = boost::any(*activityType);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (expectNum) {
      res["ExpectNum"] = boost::any(*expectNum);
    }
    if (nodeGroupId) {
      res["NodeGroupId"] = boost::any(*nodeGroupId);
    }
    if (nodeGroupName) {
      res["NodeGroupName"] = boost::any(*nodeGroupName);
    }
    if (operationId) {
      res["OperationId"] = boost::any(*operationId);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActivityId") != m.end() && !m["ActivityId"].empty()) {
      activityId = make_shared<string>(boost::any_cast<string>(m["ActivityId"]));
    }
    if (m.find("ActivityState") != m.end() && !m["ActivityState"].empty()) {
      activityState = make_shared<string>(boost::any_cast<string>(m["ActivityState"]));
    }
    if (m.find("ActivityType") != m.end() && !m["ActivityType"].empty()) {
      activityType = make_shared<string>(boost::any_cast<string>(m["ActivityType"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("ExpectNum") != m.end() && !m["ExpectNum"].empty()) {
      expectNum = make_shared<long>(boost::any_cast<long>(m["ExpectNum"]));
    }
    if (m.find("NodeGroupId") != m.end() && !m["NodeGroupId"].empty()) {
      nodeGroupId = make_shared<string>(boost::any_cast<string>(m["NodeGroupId"]));
    }
    if (m.find("NodeGroupName") != m.end() && !m["NodeGroupName"].empty()) {
      nodeGroupName = make_shared<string>(boost::any_cast<string>(m["NodeGroupName"]));
    }
    if (m.find("OperationId") != m.end() && !m["OperationId"].empty()) {
      operationId = make_shared<string>(boost::any_cast<string>(m["OperationId"]));
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
  }


  virtual ~ListAutoScalingActivitiesResponseBodyScalingActivities() = default;
};
class ListAutoScalingActivitiesResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListAutoScalingActivitiesResponseBodyScalingActivities>> scalingActivities{};
  shared_ptr<long> totalCount{};

  ListAutoScalingActivitiesResponseBody() {}

  explicit ListAutoScalingActivitiesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (scalingActivities) {
      vector<boost::any> temp1;
      for(auto item1:*scalingActivities){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ScalingActivities"] = boost::any(temp1);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ScalingActivities") != m.end() && !m["ScalingActivities"].empty()) {
      if (typeid(vector<boost::any>) == m["ScalingActivities"].type()) {
        vector<ListAutoScalingActivitiesResponseBodyScalingActivities> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ScalingActivities"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListAutoScalingActivitiesResponseBodyScalingActivities model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        scalingActivities = make_shared<vector<ListAutoScalingActivitiesResponseBodyScalingActivities>>(expect1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListAutoScalingActivitiesResponseBody() = default;
};
class ListAutoScalingActivitiesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListAutoScalingActivitiesResponseBody> body{};

  ListAutoScalingActivitiesResponse() {}

  explicit ListAutoScalingActivitiesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListAutoScalingActivitiesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListAutoScalingActivitiesResponseBody>(model1);
      }
    }
  }


  virtual ~ListAutoScalingActivitiesResponse() = default;
};
class ListClustersRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> clusterIds{};
  shared_ptr<string> clusterName{};
  shared_ptr<vector<string>> clusterStates{};
  shared_ptr<vector<string>> clusterTypes{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<vector<string>> paymentTypes{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<vector<Tag>> tags{};

  ListClustersRequest() {}

  explicit ListClustersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterIds) {
      res["ClusterIds"] = boost::any(*clusterIds);
    }
    if (clusterName) {
      res["ClusterName"] = boost::any(*clusterName);
    }
    if (clusterStates) {
      res["ClusterStates"] = boost::any(*clusterStates);
    }
    if (clusterTypes) {
      res["ClusterTypes"] = boost::any(*clusterTypes);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (paymentTypes) {
      res["PaymentTypes"] = boost::any(*paymentTypes);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterIds") != m.end() && !m["ClusterIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ClusterIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ClusterIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      clusterIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ClusterName") != m.end() && !m["ClusterName"].empty()) {
      clusterName = make_shared<string>(boost::any_cast<string>(m["ClusterName"]));
    }
    if (m.find("ClusterStates") != m.end() && !m["ClusterStates"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ClusterStates"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ClusterStates"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      clusterStates = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ClusterTypes") != m.end() && !m["ClusterTypes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ClusterTypes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ClusterTypes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      clusterTypes = make_shared<vector<string>>(toVec1);
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("PaymentTypes") != m.end() && !m["PaymentTypes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["PaymentTypes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["PaymentTypes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      paymentTypes = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<Tag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            Tag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<Tag>>(expect1);
      }
    }
  }


  virtual ~ListClustersRequest() = default;
};
class ListClustersResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ClusterSummary>> clusters{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ListClustersResponseBody() {}

  explicit ListClustersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusters) {
      vector<boost::any> temp1;
      for(auto item1:*clusters){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Clusters"] = boost::any(temp1);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Clusters") != m.end() && !m["Clusters"].empty()) {
      if (typeid(vector<boost::any>) == m["Clusters"].type()) {
        vector<ClusterSummary> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Clusters"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ClusterSummary model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        clusters = make_shared<vector<ClusterSummary>>(expect1);
      }
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListClustersResponseBody() = default;
};
class ListClustersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListClustersResponseBody> body{};

  ListClustersResponse() {}

  explicit ListClustersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListClustersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListClustersResponseBody>(model1);
      }
    }
  }


  virtual ~ListClustersResponse() = default;
};
class ListComponentInstancesRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> applicationNames{};
  shared_ptr<string> clusterId{};
  shared_ptr<vector<string>> componentNames{};
  shared_ptr<vector<string>> componentStates{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<vector<string>> nodeIds{};
  shared_ptr<vector<string>> nodeNames{};
  shared_ptr<string> regionId{};

  ListComponentInstancesRequest() {}

  explicit ListComponentInstancesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applicationNames) {
      res["ApplicationNames"] = boost::any(*applicationNames);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (componentNames) {
      res["ComponentNames"] = boost::any(*componentNames);
    }
    if (componentStates) {
      res["ComponentStates"] = boost::any(*componentStates);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (nodeIds) {
      res["NodeIds"] = boost::any(*nodeIds);
    }
    if (nodeNames) {
      res["NodeNames"] = boost::any(*nodeNames);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApplicationNames") != m.end() && !m["ApplicationNames"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ApplicationNames"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ApplicationNames"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      applicationNames = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("ComponentNames") != m.end() && !m["ComponentNames"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ComponentNames"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ComponentNames"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      componentNames = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ComponentStates") != m.end() && !m["ComponentStates"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ComponentStates"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ComponentStates"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      componentStates = make_shared<vector<string>>(toVec1);
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("NodeIds") != m.end() && !m["NodeIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["NodeIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["NodeIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      nodeIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("NodeNames") != m.end() && !m["NodeNames"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["NodeNames"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["NodeNames"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      nodeNames = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~ListComponentInstancesRequest() = default;
};
class ListComponentInstancesResponseBodyComponentInstances : public Darabonba::Model {
public:
  shared_ptr<string> applicationName{};
  shared_ptr<string> bizState{};
  shared_ptr<string> commissionState{};
  shared_ptr<string> componentInstanceState{};
  shared_ptr<string> componentName{};
  shared_ptr<long> createTime{};
  shared_ptr<string> desiredState{};
  shared_ptr<string> nodeId{};
  shared_ptr<string> nodeName{};

  ListComponentInstancesResponseBodyComponentInstances() {}

  explicit ListComponentInstancesResponseBodyComponentInstances(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applicationName) {
      res["ApplicationName"] = boost::any(*applicationName);
    }
    if (bizState) {
      res["BizState"] = boost::any(*bizState);
    }
    if (commissionState) {
      res["CommissionState"] = boost::any(*commissionState);
    }
    if (componentInstanceState) {
      res["ComponentInstanceState"] = boost::any(*componentInstanceState);
    }
    if (componentName) {
      res["ComponentName"] = boost::any(*componentName);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (desiredState) {
      res["DesiredState"] = boost::any(*desiredState);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (nodeName) {
      res["NodeName"] = boost::any(*nodeName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApplicationName") != m.end() && !m["ApplicationName"].empty()) {
      applicationName = make_shared<string>(boost::any_cast<string>(m["ApplicationName"]));
    }
    if (m.find("BizState") != m.end() && !m["BizState"].empty()) {
      bizState = make_shared<string>(boost::any_cast<string>(m["BizState"]));
    }
    if (m.find("CommissionState") != m.end() && !m["CommissionState"].empty()) {
      commissionState = make_shared<string>(boost::any_cast<string>(m["CommissionState"]));
    }
    if (m.find("ComponentInstanceState") != m.end() && !m["ComponentInstanceState"].empty()) {
      componentInstanceState = make_shared<string>(boost::any_cast<string>(m["ComponentInstanceState"]));
    }
    if (m.find("ComponentName") != m.end() && !m["ComponentName"].empty()) {
      componentName = make_shared<string>(boost::any_cast<string>(m["ComponentName"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("DesiredState") != m.end() && !m["DesiredState"].empty()) {
      desiredState = make_shared<string>(boost::any_cast<string>(m["DesiredState"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<string>(boost::any_cast<string>(m["NodeId"]));
    }
    if (m.find("NodeName") != m.end() && !m["NodeName"].empty()) {
      nodeName = make_shared<string>(boost::any_cast<string>(m["NodeName"]));
    }
  }


  virtual ~ListComponentInstancesResponseBodyComponentInstances() = default;
};
class ListComponentInstancesResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListComponentInstancesResponseBodyComponentInstances>> componentInstances{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ListComponentInstancesResponseBody() {}

  explicit ListComponentInstancesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (componentInstances) {
      vector<boost::any> temp1;
      for(auto item1:*componentInstances){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ComponentInstances"] = boost::any(temp1);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ComponentInstances") != m.end() && !m["ComponentInstances"].empty()) {
      if (typeid(vector<boost::any>) == m["ComponentInstances"].type()) {
        vector<ListComponentInstancesResponseBodyComponentInstances> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ComponentInstances"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListComponentInstancesResponseBodyComponentInstances model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        componentInstances = make_shared<vector<ListComponentInstancesResponseBodyComponentInstances>>(expect1);
      }
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListComponentInstancesResponseBody() = default;
};
class ListComponentInstancesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListComponentInstancesResponseBody> body{};

  ListComponentInstancesResponse() {}

  explicit ListComponentInstancesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListComponentInstancesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListComponentInstancesResponseBody>(model1);
      }
    }
  }


  virtual ~ListComponentInstancesResponse() = default;
};
class ListComponentsRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> applicationNames{};
  shared_ptr<string> clusterId{};
  shared_ptr<vector<string>> componentNames{};
  shared_ptr<vector<string>> componentStates{};
  shared_ptr<bool> includeExpiredConfig{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> regionId{};

  ListComponentsRequest() {}

  explicit ListComponentsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applicationNames) {
      res["ApplicationNames"] = boost::any(*applicationNames);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (componentNames) {
      res["ComponentNames"] = boost::any(*componentNames);
    }
    if (componentStates) {
      res["ComponentStates"] = boost::any(*componentStates);
    }
    if (includeExpiredConfig) {
      res["IncludeExpiredConfig"] = boost::any(*includeExpiredConfig);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApplicationNames") != m.end() && !m["ApplicationNames"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ApplicationNames"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ApplicationNames"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      applicationNames = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("ComponentNames") != m.end() && !m["ComponentNames"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ComponentNames"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ComponentNames"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      componentNames = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ComponentStates") != m.end() && !m["ComponentStates"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ComponentStates"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ComponentStates"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      componentStates = make_shared<vector<string>>(toVec1);
    }
    if (m.find("IncludeExpiredConfig") != m.end() && !m["IncludeExpiredConfig"].empty()) {
      includeExpiredConfig = make_shared<bool>(boost::any_cast<bool>(m["IncludeExpiredConfig"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~ListComponentsRequest() = default;
};
class ListComponentsResponseBodyComponents : public Darabonba::Model {
public:
  shared_ptr<string> applicationName{};
  shared_ptr<vector<Attribute>> attributes{};
  shared_ptr<string> componentName{};
  shared_ptr<string> namespace_{};
  shared_ptr<long> replica{};

  ListComponentsResponseBodyComponents() {}

  explicit ListComponentsResponseBodyComponents(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applicationName) {
      res["ApplicationName"] = boost::any(*applicationName);
    }
    if (attributes) {
      vector<boost::any> temp1;
      for(auto item1:*attributes){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Attributes"] = boost::any(temp1);
    }
    if (componentName) {
      res["ComponentName"] = boost::any(*componentName);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (replica) {
      res["Replica"] = boost::any(*replica);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApplicationName") != m.end() && !m["ApplicationName"].empty()) {
      applicationName = make_shared<string>(boost::any_cast<string>(m["ApplicationName"]));
    }
    if (m.find("Attributes") != m.end() && !m["Attributes"].empty()) {
      if (typeid(vector<boost::any>) == m["Attributes"].type()) {
        vector<Attribute> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Attributes"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            Attribute model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        attributes = make_shared<vector<Attribute>>(expect1);
      }
    }
    if (m.find("ComponentName") != m.end() && !m["ComponentName"].empty()) {
      componentName = make_shared<string>(boost::any_cast<string>(m["ComponentName"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("Replica") != m.end() && !m["Replica"].empty()) {
      replica = make_shared<long>(boost::any_cast<long>(m["Replica"]));
    }
  }


  virtual ~ListComponentsResponseBodyComponents() = default;
};
class ListComponentsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListComponentsResponseBodyComponents>> components{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ListComponentsResponseBody() {}

  explicit ListComponentsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (components) {
      vector<boost::any> temp1;
      for(auto item1:*components){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Components"] = boost::any(temp1);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Components") != m.end() && !m["Components"].empty()) {
      if (typeid(vector<boost::any>) == m["Components"].type()) {
        vector<ListComponentsResponseBodyComponents> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Components"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListComponentsResponseBodyComponents model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        components = make_shared<vector<ListComponentsResponseBodyComponents>>(expect1);
      }
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListComponentsResponseBody() = default;
};
class ListComponentsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListComponentsResponseBody> body{};

  ListComponentsResponse() {}

  explicit ListComponentsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListComponentsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListComponentsResponseBody>(model1);
      }
    }
  }


  virtual ~ListComponentsResponse() = default;
};
class ListDoctorApplicationsRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> appIds{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> dateTime{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> orderBy{};
  shared_ptr<string> orderType{};
  shared_ptr<vector<string>> queues{};
  shared_ptr<string> regionId{};
  shared_ptr<vector<string>> types{};
  shared_ptr<vector<string>> users{};

  ListDoctorApplicationsRequest() {}

  explicit ListDoctorApplicationsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appIds) {
      res["AppIds"] = boost::any(*appIds);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (dateTime) {
      res["DateTime"] = boost::any(*dateTime);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (orderBy) {
      res["OrderBy"] = boost::any(*orderBy);
    }
    if (orderType) {
      res["OrderType"] = boost::any(*orderType);
    }
    if (queues) {
      res["Queues"] = boost::any(*queues);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (types) {
      res["Types"] = boost::any(*types);
    }
    if (users) {
      res["Users"] = boost::any(*users);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppIds") != m.end() && !m["AppIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["AppIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["AppIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      appIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("DateTime") != m.end() && !m["DateTime"].empty()) {
      dateTime = make_shared<string>(boost::any_cast<string>(m["DateTime"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("OrderBy") != m.end() && !m["OrderBy"].empty()) {
      orderBy = make_shared<string>(boost::any_cast<string>(m["OrderBy"]));
    }
    if (m.find("OrderType") != m.end() && !m["OrderType"].empty()) {
      orderType = make_shared<string>(boost::any_cast<string>(m["OrderType"]));
    }
    if (m.find("Queues") != m.end() && !m["Queues"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Queues"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Queues"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      queues = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Types") != m.end() && !m["Types"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Types"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Types"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      types = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Users") != m.end() && !m["Users"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Users"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Users"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      users = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListDoctorApplicationsRequest() = default;
};
class ListDoctorApplicationsResponseBodyDataAnalysis : public Darabonba::Model {
public:
  shared_ptr<long> score{};
  shared_ptr<string> suggestion{};

  ListDoctorApplicationsResponseBodyDataAnalysis() {}

  explicit ListDoctorApplicationsResponseBodyDataAnalysis(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (score) {
      res["Score"] = boost::any(*score);
    }
    if (suggestion) {
      res["Suggestion"] = boost::any(*suggestion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Score") != m.end() && !m["Score"].empty()) {
      score = make_shared<long>(boost::any_cast<long>(m["Score"]));
    }
    if (m.find("Suggestion") != m.end() && !m["Suggestion"].empty()) {
      suggestion = make_shared<string>(boost::any_cast<string>(m["Suggestion"]));
    }
  }


  virtual ~ListDoctorApplicationsResponseBodyDataAnalysis() = default;
};
class ListDoctorApplicationsResponseBodyDataMetricsMemSeconds : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  ListDoctorApplicationsResponseBodyDataMetricsMemSeconds() {}

  explicit ListDoctorApplicationsResponseBodyDataMetricsMemSeconds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~ListDoctorApplicationsResponseBodyDataMetricsMemSeconds() = default;
};
class ListDoctorApplicationsResponseBodyDataMetricsMemUtilization : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  ListDoctorApplicationsResponseBodyDataMetricsMemUtilization() {}

  explicit ListDoctorApplicationsResponseBodyDataMetricsMemUtilization(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~ListDoctorApplicationsResponseBodyDataMetricsMemUtilization() = default;
};
class ListDoctorApplicationsResponseBodyDataMetricsVcoreSeconds : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  ListDoctorApplicationsResponseBodyDataMetricsVcoreSeconds() {}

  explicit ListDoctorApplicationsResponseBodyDataMetricsVcoreSeconds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~ListDoctorApplicationsResponseBodyDataMetricsVcoreSeconds() = default;
};
class ListDoctorApplicationsResponseBodyDataMetricsVcoreUtilization : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  ListDoctorApplicationsResponseBodyDataMetricsVcoreUtilization() {}

  explicit ListDoctorApplicationsResponseBodyDataMetricsVcoreUtilization(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~ListDoctorApplicationsResponseBodyDataMetricsVcoreUtilization() = default;
};
class ListDoctorApplicationsResponseBodyDataMetrics : public Darabonba::Model {
public:
  shared_ptr<ListDoctorApplicationsResponseBodyDataMetricsMemSeconds> memSeconds{};
  shared_ptr<ListDoctorApplicationsResponseBodyDataMetricsMemUtilization> memUtilization{};
  shared_ptr<ListDoctorApplicationsResponseBodyDataMetricsVcoreSeconds> vcoreSeconds{};
  shared_ptr<ListDoctorApplicationsResponseBodyDataMetricsVcoreUtilization> vcoreUtilization{};

  ListDoctorApplicationsResponseBodyDataMetrics() {}

  explicit ListDoctorApplicationsResponseBodyDataMetrics(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (memSeconds) {
      res["MemSeconds"] = memSeconds ? boost::any(memSeconds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (memUtilization) {
      res["MemUtilization"] = memUtilization ? boost::any(memUtilization->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (vcoreSeconds) {
      res["VcoreSeconds"] = vcoreSeconds ? boost::any(vcoreSeconds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (vcoreUtilization) {
      res["VcoreUtilization"] = vcoreUtilization ? boost::any(vcoreUtilization->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MemSeconds") != m.end() && !m["MemSeconds"].empty()) {
      if (typeid(map<string, boost::any>) == m["MemSeconds"].type()) {
        ListDoctorApplicationsResponseBodyDataMetricsMemSeconds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MemSeconds"]));
        memSeconds = make_shared<ListDoctorApplicationsResponseBodyDataMetricsMemSeconds>(model1);
      }
    }
    if (m.find("MemUtilization") != m.end() && !m["MemUtilization"].empty()) {
      if (typeid(map<string, boost::any>) == m["MemUtilization"].type()) {
        ListDoctorApplicationsResponseBodyDataMetricsMemUtilization model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MemUtilization"]));
        memUtilization = make_shared<ListDoctorApplicationsResponseBodyDataMetricsMemUtilization>(model1);
      }
    }
    if (m.find("VcoreSeconds") != m.end() && !m["VcoreSeconds"].empty()) {
      if (typeid(map<string, boost::any>) == m["VcoreSeconds"].type()) {
        ListDoctorApplicationsResponseBodyDataMetricsVcoreSeconds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VcoreSeconds"]));
        vcoreSeconds = make_shared<ListDoctorApplicationsResponseBodyDataMetricsVcoreSeconds>(model1);
      }
    }
    if (m.find("VcoreUtilization") != m.end() && !m["VcoreUtilization"].empty()) {
      if (typeid(map<string, boost::any>) == m["VcoreUtilization"].type()) {
        ListDoctorApplicationsResponseBodyDataMetricsVcoreUtilization model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VcoreUtilization"]));
        vcoreUtilization = make_shared<ListDoctorApplicationsResponseBodyDataMetricsVcoreUtilization>(model1);
      }
    }
  }


  virtual ~ListDoctorApplicationsResponseBodyDataMetrics() = default;
};
class ListDoctorApplicationsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<ListDoctorApplicationsResponseBodyDataAnalysis> analysis{};
  shared_ptr<string> appId{};
  shared_ptr<string> appName{};
  shared_ptr<long> endTime{};
  shared_ptr<vector<string>> ids{};
  shared_ptr<ListDoctorApplicationsResponseBodyDataMetrics> metrics{};
  shared_ptr<string> querySql{};
  shared_ptr<string> queue{};
  shared_ptr<long> startTime{};
  shared_ptr<string> type{};
  shared_ptr<string> user{};

  ListDoctorApplicationsResponseBodyData() {}

  explicit ListDoctorApplicationsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (analysis) {
      res["Analysis"] = analysis ? boost::any(analysis->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (ids) {
      res["Ids"] = boost::any(*ids);
    }
    if (metrics) {
      res["Metrics"] = metrics ? boost::any(metrics->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (querySql) {
      res["QuerySql"] = boost::any(*querySql);
    }
    if (queue) {
      res["Queue"] = boost::any(*queue);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (user) {
      res["User"] = boost::any(*user);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Analysis") != m.end() && !m["Analysis"].empty()) {
      if (typeid(map<string, boost::any>) == m["Analysis"].type()) {
        ListDoctorApplicationsResponseBodyDataAnalysis model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Analysis"]));
        analysis = make_shared<ListDoctorApplicationsResponseBodyDataAnalysis>(model1);
      }
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("Ids") != m.end() && !m["Ids"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Ids"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Ids"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ids = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Metrics") != m.end() && !m["Metrics"].empty()) {
      if (typeid(map<string, boost::any>) == m["Metrics"].type()) {
        ListDoctorApplicationsResponseBodyDataMetrics model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Metrics"]));
        metrics = make_shared<ListDoctorApplicationsResponseBodyDataMetrics>(model1);
      }
    }
    if (m.find("QuerySql") != m.end() && !m["QuerySql"].empty()) {
      querySql = make_shared<string>(boost::any_cast<string>(m["QuerySql"]));
    }
    if (m.find("Queue") != m.end() && !m["Queue"].empty()) {
      queue = make_shared<string>(boost::any_cast<string>(m["Queue"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("User") != m.end() && !m["User"].empty()) {
      user = make_shared<string>(boost::any_cast<string>(m["User"]));
    }
  }


  virtual ~ListDoctorApplicationsResponseBodyData() = default;
};
class ListDoctorApplicationsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListDoctorApplicationsResponseBodyData>> data{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ListDoctorApplicationsResponseBody() {}

  explicit ListDoctorApplicationsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<ListDoctorApplicationsResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDoctorApplicationsResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListDoctorApplicationsResponseBodyData>>(expect1);
      }
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListDoctorApplicationsResponseBody() = default;
};
class ListDoctorApplicationsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListDoctorApplicationsResponseBody> body{};

  ListDoctorApplicationsResponse() {}

  explicit ListDoctorApplicationsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListDoctorApplicationsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListDoctorApplicationsResponseBody>(model1);
      }
    }
  }


  virtual ~ListDoctorApplicationsResponse() = default;
};
class ListDoctorComputeSummaryRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<vector<string>> componentTypes{};
  shared_ptr<string> dateTime{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> orderBy{};
  shared_ptr<string> orderType{};
  shared_ptr<string> regionId{};

  ListDoctorComputeSummaryRequest() {}

  explicit ListDoctorComputeSummaryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (componentTypes) {
      res["ComponentTypes"] = boost::any(*componentTypes);
    }
    if (dateTime) {
      res["DateTime"] = boost::any(*dateTime);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (orderBy) {
      res["OrderBy"] = boost::any(*orderBy);
    }
    if (orderType) {
      res["OrderType"] = boost::any(*orderType);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("ComponentTypes") != m.end() && !m["ComponentTypes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ComponentTypes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ComponentTypes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      componentTypes = make_shared<vector<string>>(toVec1);
    }
    if (m.find("DateTime") != m.end() && !m["DateTime"].empty()) {
      dateTime = make_shared<string>(boost::any_cast<string>(m["DateTime"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("OrderBy") != m.end() && !m["OrderBy"].empty()) {
      orderBy = make_shared<string>(boost::any_cast<string>(m["OrderBy"]));
    }
    if (m.find("OrderType") != m.end() && !m["OrderType"].empty()) {
      orderType = make_shared<string>(boost::any_cast<string>(m["OrderType"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~ListDoctorComputeSummaryRequest() = default;
};
class ListDoctorComputeSummaryResponseBodyDataAnalysis : public Darabonba::Model {
public:
  shared_ptr<long> healthyJobCount{};
  shared_ptr<long> needAttentionJobCount{};
  shared_ptr<long> score{};
  shared_ptr<double> scoreDayGrowthRatio{};
  shared_ptr<long> subHealthyJobCount{};
  shared_ptr<long> unhealthyJobCount{};

  ListDoctorComputeSummaryResponseBodyDataAnalysis() {}

  explicit ListDoctorComputeSummaryResponseBodyDataAnalysis(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (healthyJobCount) {
      res["HealthyJobCount"] = boost::any(*healthyJobCount);
    }
    if (needAttentionJobCount) {
      res["NeedAttentionJobCount"] = boost::any(*needAttentionJobCount);
    }
    if (score) {
      res["Score"] = boost::any(*score);
    }
    if (scoreDayGrowthRatio) {
      res["ScoreDayGrowthRatio"] = boost::any(*scoreDayGrowthRatio);
    }
    if (subHealthyJobCount) {
      res["SubHealthyJobCount"] = boost::any(*subHealthyJobCount);
    }
    if (unhealthyJobCount) {
      res["UnhealthyJobCount"] = boost::any(*unhealthyJobCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HealthyJobCount") != m.end() && !m["HealthyJobCount"].empty()) {
      healthyJobCount = make_shared<long>(boost::any_cast<long>(m["HealthyJobCount"]));
    }
    if (m.find("NeedAttentionJobCount") != m.end() && !m["NeedAttentionJobCount"].empty()) {
      needAttentionJobCount = make_shared<long>(boost::any_cast<long>(m["NeedAttentionJobCount"]));
    }
    if (m.find("Score") != m.end() && !m["Score"].empty()) {
      score = make_shared<long>(boost::any_cast<long>(m["Score"]));
    }
    if (m.find("ScoreDayGrowthRatio") != m.end() && !m["ScoreDayGrowthRatio"].empty()) {
      scoreDayGrowthRatio = make_shared<double>(boost::any_cast<double>(m["ScoreDayGrowthRatio"]));
    }
    if (m.find("SubHealthyJobCount") != m.end() && !m["SubHealthyJobCount"].empty()) {
      subHealthyJobCount = make_shared<long>(boost::any_cast<long>(m["SubHealthyJobCount"]));
    }
    if (m.find("UnhealthyJobCount") != m.end() && !m["UnhealthyJobCount"].empty()) {
      unhealthyJobCount = make_shared<long>(boost::any_cast<long>(m["UnhealthyJobCount"]));
    }
  }


  virtual ~ListDoctorComputeSummaryResponseBodyDataAnalysis() = default;
};
class ListDoctorComputeSummaryResponseBodyDataMetricsMemSeconds : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  ListDoctorComputeSummaryResponseBodyDataMetricsMemSeconds() {}

  explicit ListDoctorComputeSummaryResponseBodyDataMetricsMemSeconds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~ListDoctorComputeSummaryResponseBodyDataMetricsMemSeconds() = default;
};
class ListDoctorComputeSummaryResponseBodyDataMetricsMemSecondsDayGrowthRatio : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  ListDoctorComputeSummaryResponseBodyDataMetricsMemSecondsDayGrowthRatio() {}

  explicit ListDoctorComputeSummaryResponseBodyDataMetricsMemSecondsDayGrowthRatio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~ListDoctorComputeSummaryResponseBodyDataMetricsMemSecondsDayGrowthRatio() = default;
};
class ListDoctorComputeSummaryResponseBodyDataMetricsMemUtilization : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  ListDoctorComputeSummaryResponseBodyDataMetricsMemUtilization() {}

  explicit ListDoctorComputeSummaryResponseBodyDataMetricsMemUtilization(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~ListDoctorComputeSummaryResponseBodyDataMetricsMemUtilization() = default;
};
class ListDoctorComputeSummaryResponseBodyDataMetricsReadSize : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  ListDoctorComputeSummaryResponseBodyDataMetricsReadSize() {}

  explicit ListDoctorComputeSummaryResponseBodyDataMetricsReadSize(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~ListDoctorComputeSummaryResponseBodyDataMetricsReadSize() = default;
};
class ListDoctorComputeSummaryResponseBodyDataMetricsVcoreSeconds : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  ListDoctorComputeSummaryResponseBodyDataMetricsVcoreSeconds() {}

  explicit ListDoctorComputeSummaryResponseBodyDataMetricsVcoreSeconds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~ListDoctorComputeSummaryResponseBodyDataMetricsVcoreSeconds() = default;
};
class ListDoctorComputeSummaryResponseBodyDataMetricsVcoreSecondsDayGrowthRatio : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  ListDoctorComputeSummaryResponseBodyDataMetricsVcoreSecondsDayGrowthRatio() {}

  explicit ListDoctorComputeSummaryResponseBodyDataMetricsVcoreSecondsDayGrowthRatio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~ListDoctorComputeSummaryResponseBodyDataMetricsVcoreSecondsDayGrowthRatio() = default;
};
class ListDoctorComputeSummaryResponseBodyDataMetricsVcoreUtilization : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  ListDoctorComputeSummaryResponseBodyDataMetricsVcoreUtilization() {}

  explicit ListDoctorComputeSummaryResponseBodyDataMetricsVcoreUtilization(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~ListDoctorComputeSummaryResponseBodyDataMetricsVcoreUtilization() = default;
};
class ListDoctorComputeSummaryResponseBodyDataMetricsWriteSize : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  ListDoctorComputeSummaryResponseBodyDataMetricsWriteSize() {}

  explicit ListDoctorComputeSummaryResponseBodyDataMetricsWriteSize(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~ListDoctorComputeSummaryResponseBodyDataMetricsWriteSize() = default;
};
class ListDoctorComputeSummaryResponseBodyDataMetrics : public Darabonba::Model {
public:
  shared_ptr<ListDoctorComputeSummaryResponseBodyDataMetricsMemSeconds> memSeconds{};
  shared_ptr<ListDoctorComputeSummaryResponseBodyDataMetricsMemSecondsDayGrowthRatio> memSecondsDayGrowthRatio{};
  shared_ptr<ListDoctorComputeSummaryResponseBodyDataMetricsMemUtilization> memUtilization{};
  shared_ptr<ListDoctorComputeSummaryResponseBodyDataMetricsReadSize> readSize{};
  shared_ptr<ListDoctorComputeSummaryResponseBodyDataMetricsVcoreSeconds> vcoreSeconds{};
  shared_ptr<ListDoctorComputeSummaryResponseBodyDataMetricsVcoreSecondsDayGrowthRatio> vcoreSecondsDayGrowthRatio{};
  shared_ptr<ListDoctorComputeSummaryResponseBodyDataMetricsVcoreUtilization> vcoreUtilization{};
  shared_ptr<ListDoctorComputeSummaryResponseBodyDataMetricsWriteSize> writeSize{};

  ListDoctorComputeSummaryResponseBodyDataMetrics() {}

  explicit ListDoctorComputeSummaryResponseBodyDataMetrics(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (memSeconds) {
      res["MemSeconds"] = memSeconds ? boost::any(memSeconds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (memSecondsDayGrowthRatio) {
      res["MemSecondsDayGrowthRatio"] = memSecondsDayGrowthRatio ? boost::any(memSecondsDayGrowthRatio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (memUtilization) {
      res["MemUtilization"] = memUtilization ? boost::any(memUtilization->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (readSize) {
      res["ReadSize"] = readSize ? boost::any(readSize->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (vcoreSeconds) {
      res["VcoreSeconds"] = vcoreSeconds ? boost::any(vcoreSeconds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (vcoreSecondsDayGrowthRatio) {
      res["VcoreSecondsDayGrowthRatio"] = vcoreSecondsDayGrowthRatio ? boost::any(vcoreSecondsDayGrowthRatio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (vcoreUtilization) {
      res["VcoreUtilization"] = vcoreUtilization ? boost::any(vcoreUtilization->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (writeSize) {
      res["WriteSize"] = writeSize ? boost::any(writeSize->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MemSeconds") != m.end() && !m["MemSeconds"].empty()) {
      if (typeid(map<string, boost::any>) == m["MemSeconds"].type()) {
        ListDoctorComputeSummaryResponseBodyDataMetricsMemSeconds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MemSeconds"]));
        memSeconds = make_shared<ListDoctorComputeSummaryResponseBodyDataMetricsMemSeconds>(model1);
      }
    }
    if (m.find("MemSecondsDayGrowthRatio") != m.end() && !m["MemSecondsDayGrowthRatio"].empty()) {
      if (typeid(map<string, boost::any>) == m["MemSecondsDayGrowthRatio"].type()) {
        ListDoctorComputeSummaryResponseBodyDataMetricsMemSecondsDayGrowthRatio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MemSecondsDayGrowthRatio"]));
        memSecondsDayGrowthRatio = make_shared<ListDoctorComputeSummaryResponseBodyDataMetricsMemSecondsDayGrowthRatio>(model1);
      }
    }
    if (m.find("MemUtilization") != m.end() && !m["MemUtilization"].empty()) {
      if (typeid(map<string, boost::any>) == m["MemUtilization"].type()) {
        ListDoctorComputeSummaryResponseBodyDataMetricsMemUtilization model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MemUtilization"]));
        memUtilization = make_shared<ListDoctorComputeSummaryResponseBodyDataMetricsMemUtilization>(model1);
      }
    }
    if (m.find("ReadSize") != m.end() && !m["ReadSize"].empty()) {
      if (typeid(map<string, boost::any>) == m["ReadSize"].type()) {
        ListDoctorComputeSummaryResponseBodyDataMetricsReadSize model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ReadSize"]));
        readSize = make_shared<ListDoctorComputeSummaryResponseBodyDataMetricsReadSize>(model1);
      }
    }
    if (m.find("VcoreSeconds") != m.end() && !m["VcoreSeconds"].empty()) {
      if (typeid(map<string, boost::any>) == m["VcoreSeconds"].type()) {
        ListDoctorComputeSummaryResponseBodyDataMetricsVcoreSeconds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VcoreSeconds"]));
        vcoreSeconds = make_shared<ListDoctorComputeSummaryResponseBodyDataMetricsVcoreSeconds>(model1);
      }
    }
    if (m.find("VcoreSecondsDayGrowthRatio") != m.end() && !m["VcoreSecondsDayGrowthRatio"].empty()) {
      if (typeid(map<string, boost::any>) == m["VcoreSecondsDayGrowthRatio"].type()) {
        ListDoctorComputeSummaryResponseBodyDataMetricsVcoreSecondsDayGrowthRatio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VcoreSecondsDayGrowthRatio"]));
        vcoreSecondsDayGrowthRatio = make_shared<ListDoctorComputeSummaryResponseBodyDataMetricsVcoreSecondsDayGrowthRatio>(model1);
      }
    }
    if (m.find("VcoreUtilization") != m.end() && !m["VcoreUtilization"].empty()) {
      if (typeid(map<string, boost::any>) == m["VcoreUtilization"].type()) {
        ListDoctorComputeSummaryResponseBodyDataMetricsVcoreUtilization model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VcoreUtilization"]));
        vcoreUtilization = make_shared<ListDoctorComputeSummaryResponseBodyDataMetricsVcoreUtilization>(model1);
      }
    }
    if (m.find("WriteSize") != m.end() && !m["WriteSize"].empty()) {
      if (typeid(map<string, boost::any>) == m["WriteSize"].type()) {
        ListDoctorComputeSummaryResponseBodyDataMetricsWriteSize model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["WriteSize"]));
        writeSize = make_shared<ListDoctorComputeSummaryResponseBodyDataMetricsWriteSize>(model1);
      }
    }
  }


  virtual ~ListDoctorComputeSummaryResponseBodyDataMetrics() = default;
};
class ListDoctorComputeSummaryResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<ListDoctorComputeSummaryResponseBodyDataAnalysis> analysis{};
  shared_ptr<string> componentName{};
  shared_ptr<ListDoctorComputeSummaryResponseBodyDataMetrics> metrics{};

  ListDoctorComputeSummaryResponseBodyData() {}

  explicit ListDoctorComputeSummaryResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (analysis) {
      res["Analysis"] = analysis ? boost::any(analysis->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (componentName) {
      res["ComponentName"] = boost::any(*componentName);
    }
    if (metrics) {
      res["Metrics"] = metrics ? boost::any(metrics->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Analysis") != m.end() && !m["Analysis"].empty()) {
      if (typeid(map<string, boost::any>) == m["Analysis"].type()) {
        ListDoctorComputeSummaryResponseBodyDataAnalysis model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Analysis"]));
        analysis = make_shared<ListDoctorComputeSummaryResponseBodyDataAnalysis>(model1);
      }
    }
    if (m.find("ComponentName") != m.end() && !m["ComponentName"].empty()) {
      componentName = make_shared<string>(boost::any_cast<string>(m["ComponentName"]));
    }
    if (m.find("Metrics") != m.end() && !m["Metrics"].empty()) {
      if (typeid(map<string, boost::any>) == m["Metrics"].type()) {
        ListDoctorComputeSummaryResponseBodyDataMetrics model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Metrics"]));
        metrics = make_shared<ListDoctorComputeSummaryResponseBodyDataMetrics>(model1);
      }
    }
  }


  virtual ~ListDoctorComputeSummaryResponseBodyData() = default;
};
class ListDoctorComputeSummaryResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListDoctorComputeSummaryResponseBodyData>> data{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ListDoctorComputeSummaryResponseBody() {}

  explicit ListDoctorComputeSummaryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<ListDoctorComputeSummaryResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDoctorComputeSummaryResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListDoctorComputeSummaryResponseBodyData>>(expect1);
      }
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListDoctorComputeSummaryResponseBody() = default;
};
class ListDoctorComputeSummaryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListDoctorComputeSummaryResponseBody> body{};

  ListDoctorComputeSummaryResponse() {}

  explicit ListDoctorComputeSummaryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListDoctorComputeSummaryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListDoctorComputeSummaryResponseBody>(model1);
      }
    }
  }


  virtual ~ListDoctorComputeSummaryResponse() = default;
};
class ListDoctorHBaseRegionServersRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> dateTime{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> orderBy{};
  shared_ptr<string> orderType{};
  shared_ptr<string> regionId{};
  shared_ptr<vector<string>> regionServerHosts{};

  ListDoctorHBaseRegionServersRequest() {}

  explicit ListDoctorHBaseRegionServersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (dateTime) {
      res["DateTime"] = boost::any(*dateTime);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (orderBy) {
      res["OrderBy"] = boost::any(*orderBy);
    }
    if (orderType) {
      res["OrderType"] = boost::any(*orderType);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (regionServerHosts) {
      res["RegionServerHosts"] = boost::any(*regionServerHosts);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("DateTime") != m.end() && !m["DateTime"].empty()) {
      dateTime = make_shared<string>(boost::any_cast<string>(m["DateTime"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("OrderBy") != m.end() && !m["OrderBy"].empty()) {
      orderBy = make_shared<string>(boost::any_cast<string>(m["OrderBy"]));
    }
    if (m.find("OrderType") != m.end() && !m["OrderType"].empty()) {
      orderType = make_shared<string>(boost::any_cast<string>(m["OrderType"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RegionServerHosts") != m.end() && !m["RegionServerHosts"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RegionServerHosts"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RegionServerHosts"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      regionServerHosts = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListDoctorHBaseRegionServersRequest() = default;
};
class ListDoctorHBaseRegionServersResponseBodyDataMetricsAvgGc : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  ListDoctorHBaseRegionServersResponseBodyDataMetricsAvgGc() {}

  explicit ListDoctorHBaseRegionServersResponseBodyDataMetricsAvgGc(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~ListDoctorHBaseRegionServersResponseBodyDataMetricsAvgGc() = default;
};
class ListDoctorHBaseRegionServersResponseBodyDataMetricsCacheRatio : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  ListDoctorHBaseRegionServersResponseBodyDataMetricsCacheRatio() {}

  explicit ListDoctorHBaseRegionServersResponseBodyDataMetricsCacheRatio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~ListDoctorHBaseRegionServersResponseBodyDataMetricsCacheRatio() = default;
};
class ListDoctorHBaseRegionServersResponseBodyDataMetricsDailyReadRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  ListDoctorHBaseRegionServersResponseBodyDataMetricsDailyReadRequest() {}

  explicit ListDoctorHBaseRegionServersResponseBodyDataMetricsDailyReadRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~ListDoctorHBaseRegionServersResponseBodyDataMetricsDailyReadRequest() = default;
};
class ListDoctorHBaseRegionServersResponseBodyDataMetricsDailyReadRequestDayGrowthRatio : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  ListDoctorHBaseRegionServersResponseBodyDataMetricsDailyReadRequestDayGrowthRatio() {}

  explicit ListDoctorHBaseRegionServersResponseBodyDataMetricsDailyReadRequestDayGrowthRatio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~ListDoctorHBaseRegionServersResponseBodyDataMetricsDailyReadRequestDayGrowthRatio() = default;
};
class ListDoctorHBaseRegionServersResponseBodyDataMetricsDailyWriteRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  ListDoctorHBaseRegionServersResponseBodyDataMetricsDailyWriteRequest() {}

  explicit ListDoctorHBaseRegionServersResponseBodyDataMetricsDailyWriteRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~ListDoctorHBaseRegionServersResponseBodyDataMetricsDailyWriteRequest() = default;
};
class ListDoctorHBaseRegionServersResponseBodyDataMetricsDailyWriteRequestDayGrowthRatio : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  ListDoctorHBaseRegionServersResponseBodyDataMetricsDailyWriteRequestDayGrowthRatio() {}

  explicit ListDoctorHBaseRegionServersResponseBodyDataMetricsDailyWriteRequestDayGrowthRatio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~ListDoctorHBaseRegionServersResponseBodyDataMetricsDailyWriteRequestDayGrowthRatio() = default;
};
class ListDoctorHBaseRegionServersResponseBodyDataMetricsRegionCount : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  ListDoctorHBaseRegionServersResponseBodyDataMetricsRegionCount() {}

  explicit ListDoctorHBaseRegionServersResponseBodyDataMetricsRegionCount(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~ListDoctorHBaseRegionServersResponseBodyDataMetricsRegionCount() = default;
};
class ListDoctorHBaseRegionServersResponseBodyDataMetricsTotalReadRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  ListDoctorHBaseRegionServersResponseBodyDataMetricsTotalReadRequest() {}

  explicit ListDoctorHBaseRegionServersResponseBodyDataMetricsTotalReadRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~ListDoctorHBaseRegionServersResponseBodyDataMetricsTotalReadRequest() = default;
};
class ListDoctorHBaseRegionServersResponseBodyDataMetricsTotalRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  ListDoctorHBaseRegionServersResponseBodyDataMetricsTotalRequest() {}

  explicit ListDoctorHBaseRegionServersResponseBodyDataMetricsTotalRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~ListDoctorHBaseRegionServersResponseBodyDataMetricsTotalRequest() = default;
};
class ListDoctorHBaseRegionServersResponseBodyDataMetricsTotalWriteRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  ListDoctorHBaseRegionServersResponseBodyDataMetricsTotalWriteRequest() {}

  explicit ListDoctorHBaseRegionServersResponseBodyDataMetricsTotalWriteRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~ListDoctorHBaseRegionServersResponseBodyDataMetricsTotalWriteRequest() = default;
};
class ListDoctorHBaseRegionServersResponseBodyDataMetrics : public Darabonba::Model {
public:
  shared_ptr<ListDoctorHBaseRegionServersResponseBodyDataMetricsAvgGc> avgGc{};
  shared_ptr<ListDoctorHBaseRegionServersResponseBodyDataMetricsCacheRatio> cacheRatio{};
  shared_ptr<ListDoctorHBaseRegionServersResponseBodyDataMetricsDailyReadRequest> dailyReadRequest{};
  shared_ptr<ListDoctorHBaseRegionServersResponseBodyDataMetricsDailyReadRequestDayGrowthRatio> dailyReadRequestDayGrowthRatio{};
  shared_ptr<ListDoctorHBaseRegionServersResponseBodyDataMetricsDailyWriteRequest> dailyWriteRequest{};
  shared_ptr<ListDoctorHBaseRegionServersResponseBodyDataMetricsDailyWriteRequestDayGrowthRatio> dailyWriteRequestDayGrowthRatio{};
  shared_ptr<ListDoctorHBaseRegionServersResponseBodyDataMetricsRegionCount> regionCount{};
  shared_ptr<ListDoctorHBaseRegionServersResponseBodyDataMetricsTotalReadRequest> totalReadRequest{};
  shared_ptr<ListDoctorHBaseRegionServersResponseBodyDataMetricsTotalRequest> totalRequest{};
  shared_ptr<ListDoctorHBaseRegionServersResponseBodyDataMetricsTotalWriteRequest> totalWriteRequest{};

  ListDoctorHBaseRegionServersResponseBodyDataMetrics() {}

  explicit ListDoctorHBaseRegionServersResponseBodyDataMetrics(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (avgGc) {
      res["AvgGc"] = avgGc ? boost::any(avgGc->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (cacheRatio) {
      res["CacheRatio"] = cacheRatio ? boost::any(cacheRatio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (dailyReadRequest) {
      res["DailyReadRequest"] = dailyReadRequest ? boost::any(dailyReadRequest->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (dailyReadRequestDayGrowthRatio) {
      res["DailyReadRequestDayGrowthRatio"] = dailyReadRequestDayGrowthRatio ? boost::any(dailyReadRequestDayGrowthRatio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (dailyWriteRequest) {
      res["DailyWriteRequest"] = dailyWriteRequest ? boost::any(dailyWriteRequest->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (dailyWriteRequestDayGrowthRatio) {
      res["DailyWriteRequestDayGrowthRatio"] = dailyWriteRequestDayGrowthRatio ? boost::any(dailyWriteRequestDayGrowthRatio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (regionCount) {
      res["RegionCount"] = regionCount ? boost::any(regionCount->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (totalReadRequest) {
      res["TotalReadRequest"] = totalReadRequest ? boost::any(totalReadRequest->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (totalRequest) {
      res["TotalRequest"] = totalRequest ? boost::any(totalRequest->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (totalWriteRequest) {
      res["TotalWriteRequest"] = totalWriteRequest ? boost::any(totalWriteRequest->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AvgGc") != m.end() && !m["AvgGc"].empty()) {
      if (typeid(map<string, boost::any>) == m["AvgGc"].type()) {
        ListDoctorHBaseRegionServersResponseBodyDataMetricsAvgGc model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AvgGc"]));
        avgGc = make_shared<ListDoctorHBaseRegionServersResponseBodyDataMetricsAvgGc>(model1);
      }
    }
    if (m.find("CacheRatio") != m.end() && !m["CacheRatio"].empty()) {
      if (typeid(map<string, boost::any>) == m["CacheRatio"].type()) {
        ListDoctorHBaseRegionServersResponseBodyDataMetricsCacheRatio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CacheRatio"]));
        cacheRatio = make_shared<ListDoctorHBaseRegionServersResponseBodyDataMetricsCacheRatio>(model1);
      }
    }
    if (m.find("DailyReadRequest") != m.end() && !m["DailyReadRequest"].empty()) {
      if (typeid(map<string, boost::any>) == m["DailyReadRequest"].type()) {
        ListDoctorHBaseRegionServersResponseBodyDataMetricsDailyReadRequest model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DailyReadRequest"]));
        dailyReadRequest = make_shared<ListDoctorHBaseRegionServersResponseBodyDataMetricsDailyReadRequest>(model1);
      }
    }
    if (m.find("DailyReadRequestDayGrowthRatio") != m.end() && !m["DailyReadRequestDayGrowthRatio"].empty()) {
      if (typeid(map<string, boost::any>) == m["DailyReadRequestDayGrowthRatio"].type()) {
        ListDoctorHBaseRegionServersResponseBodyDataMetricsDailyReadRequestDayGrowthRatio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DailyReadRequestDayGrowthRatio"]));
        dailyReadRequestDayGrowthRatio = make_shared<ListDoctorHBaseRegionServersResponseBodyDataMetricsDailyReadRequestDayGrowthRatio>(model1);
      }
    }
    if (m.find("DailyWriteRequest") != m.end() && !m["DailyWriteRequest"].empty()) {
      if (typeid(map<string, boost::any>) == m["DailyWriteRequest"].type()) {
        ListDoctorHBaseRegionServersResponseBodyDataMetricsDailyWriteRequest model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DailyWriteRequest"]));
        dailyWriteRequest = make_shared<ListDoctorHBaseRegionServersResponseBodyDataMetricsDailyWriteRequest>(model1);
      }
    }
    if (m.find("DailyWriteRequestDayGrowthRatio") != m.end() && !m["DailyWriteRequestDayGrowthRatio"].empty()) {
      if (typeid(map<string, boost::any>) == m["DailyWriteRequestDayGrowthRatio"].type()) {
        ListDoctorHBaseRegionServersResponseBodyDataMetricsDailyWriteRequestDayGrowthRatio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DailyWriteRequestDayGrowthRatio"]));
        dailyWriteRequestDayGrowthRatio = make_shared<ListDoctorHBaseRegionServersResponseBodyDataMetricsDailyWriteRequestDayGrowthRatio>(model1);
      }
    }
    if (m.find("RegionCount") != m.end() && !m["RegionCount"].empty()) {
      if (typeid(map<string, boost::any>) == m["RegionCount"].type()) {
        ListDoctorHBaseRegionServersResponseBodyDataMetricsRegionCount model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RegionCount"]));
        regionCount = make_shared<ListDoctorHBaseRegionServersResponseBodyDataMetricsRegionCount>(model1);
      }
    }
    if (m.find("TotalReadRequest") != m.end() && !m["TotalReadRequest"].empty()) {
      if (typeid(map<string, boost::any>) == m["TotalReadRequest"].type()) {
        ListDoctorHBaseRegionServersResponseBodyDataMetricsTotalReadRequest model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TotalReadRequest"]));
        totalReadRequest = make_shared<ListDoctorHBaseRegionServersResponseBodyDataMetricsTotalReadRequest>(model1);
      }
    }
    if (m.find("TotalRequest") != m.end() && !m["TotalRequest"].empty()) {
      if (typeid(map<string, boost::any>) == m["TotalRequest"].type()) {
        ListDoctorHBaseRegionServersResponseBodyDataMetricsTotalRequest model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TotalRequest"]));
        totalRequest = make_shared<ListDoctorHBaseRegionServersResponseBodyDataMetricsTotalRequest>(model1);
      }
    }
    if (m.find("TotalWriteRequest") != m.end() && !m["TotalWriteRequest"].empty()) {
      if (typeid(map<string, boost::any>) == m["TotalWriteRequest"].type()) {
        ListDoctorHBaseRegionServersResponseBodyDataMetricsTotalWriteRequest model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TotalWriteRequest"]));
        totalWriteRequest = make_shared<ListDoctorHBaseRegionServersResponseBodyDataMetricsTotalWriteRequest>(model1);
      }
    }
  }


  virtual ~ListDoctorHBaseRegionServersResponseBodyDataMetrics() = default;
};
class ListDoctorHBaseRegionServersResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<ListDoctorHBaseRegionServersResponseBodyDataMetrics> metrics{};
  shared_ptr<string> regionServerHost{};

  ListDoctorHBaseRegionServersResponseBodyData() {}

  explicit ListDoctorHBaseRegionServersResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (metrics) {
      res["Metrics"] = metrics ? boost::any(metrics->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (regionServerHost) {
      res["RegionServerHost"] = boost::any(*regionServerHost);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Metrics") != m.end() && !m["Metrics"].empty()) {
      if (typeid(map<string, boost::any>) == m["Metrics"].type()) {
        ListDoctorHBaseRegionServersResponseBodyDataMetrics model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Metrics"]));
        metrics = make_shared<ListDoctorHBaseRegionServersResponseBodyDataMetrics>(model1);
      }
    }
    if (m.find("RegionServerHost") != m.end() && !m["RegionServerHost"].empty()) {
      regionServerHost = make_shared<string>(boost::any_cast<string>(m["RegionServerHost"]));
    }
  }


  virtual ~ListDoctorHBaseRegionServersResponseBodyData() = default;
};
class ListDoctorHBaseRegionServersResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListDoctorHBaseRegionServersResponseBodyData>> data{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ListDoctorHBaseRegionServersResponseBody() {}

  explicit ListDoctorHBaseRegionServersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<ListDoctorHBaseRegionServersResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDoctorHBaseRegionServersResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListDoctorHBaseRegionServersResponseBodyData>>(expect1);
      }
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListDoctorHBaseRegionServersResponseBody() = default;
};
class ListDoctorHBaseRegionServersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListDoctorHBaseRegionServersResponseBody> body{};

  ListDoctorHBaseRegionServersResponse() {}

  explicit ListDoctorHBaseRegionServersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListDoctorHBaseRegionServersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListDoctorHBaseRegionServersResponseBody>(model1);
      }
    }
  }


  virtual ~ListDoctorHBaseRegionServersResponse() = default;
};
class ListDoctorHBaseTablesRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> dateTime{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> orderBy{};
  shared_ptr<string> orderType{};
  shared_ptr<string> regionId{};
  shared_ptr<vector<string>> tableNames{};

  ListDoctorHBaseTablesRequest() {}

  explicit ListDoctorHBaseTablesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (dateTime) {
      res["DateTime"] = boost::any(*dateTime);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (orderBy) {
      res["OrderBy"] = boost::any(*orderBy);
    }
    if (orderType) {
      res["OrderType"] = boost::any(*orderType);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (tableNames) {
      res["TableNames"] = boost::any(*tableNames);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("DateTime") != m.end() && !m["DateTime"].empty()) {
      dateTime = make_shared<string>(boost::any_cast<string>(m["DateTime"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("OrderBy") != m.end() && !m["OrderBy"].empty()) {
      orderBy = make_shared<string>(boost::any_cast<string>(m["OrderBy"]));
    }
    if (m.find("OrderType") != m.end() && !m["OrderType"].empty()) {
      orderType = make_shared<string>(boost::any_cast<string>(m["OrderType"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("TableNames") != m.end() && !m["TableNames"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["TableNames"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["TableNames"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      tableNames = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListDoctorHBaseTablesRequest() = default;
};
class ListDoctorHBaseTablesResponseBodyDataAnalysis : public Darabonba::Model {
public:
  shared_ptr<vector<string>> readRequestHotspotRegionList{};
  shared_ptr<string> readRequestUnbalanceSuggestion{};
  shared_ptr<vector<string>> requestHotspotRegionList{};
  shared_ptr<string> requestUnbalanceSuggestion{};
  shared_ptr<long> tableScore{};
  shared_ptr<vector<string>> writeRequestHotspotRegionList{};
  shared_ptr<string> writeRequestUnbalanceSuggestion{};

  ListDoctorHBaseTablesResponseBodyDataAnalysis() {}

  explicit ListDoctorHBaseTablesResponseBodyDataAnalysis(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (readRequestHotspotRegionList) {
      res["ReadRequestHotspotRegionList"] = boost::any(*readRequestHotspotRegionList);
    }
    if (readRequestUnbalanceSuggestion) {
      res["ReadRequestUnbalanceSuggestion"] = boost::any(*readRequestUnbalanceSuggestion);
    }
    if (requestHotspotRegionList) {
      res["RequestHotspotRegionList"] = boost::any(*requestHotspotRegionList);
    }
    if (requestUnbalanceSuggestion) {
      res["RequestUnbalanceSuggestion"] = boost::any(*requestUnbalanceSuggestion);
    }
    if (tableScore) {
      res["TableScore"] = boost::any(*tableScore);
    }
    if (writeRequestHotspotRegionList) {
      res["WriteRequestHotspotRegionList"] = boost::any(*writeRequestHotspotRegionList);
    }
    if (writeRequestUnbalanceSuggestion) {
      res["WriteRequestUnbalanceSuggestion"] = boost::any(*writeRequestUnbalanceSuggestion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ReadRequestHotspotRegionList") != m.end() && !m["ReadRequestHotspotRegionList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ReadRequestHotspotRegionList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ReadRequestHotspotRegionList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      readRequestHotspotRegionList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ReadRequestUnbalanceSuggestion") != m.end() && !m["ReadRequestUnbalanceSuggestion"].empty()) {
      readRequestUnbalanceSuggestion = make_shared<string>(boost::any_cast<string>(m["ReadRequestUnbalanceSuggestion"]));
    }
    if (m.find("RequestHotspotRegionList") != m.end() && !m["RequestHotspotRegionList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RequestHotspotRegionList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RequestHotspotRegionList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      requestHotspotRegionList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestUnbalanceSuggestion") != m.end() && !m["RequestUnbalanceSuggestion"].empty()) {
      requestUnbalanceSuggestion = make_shared<string>(boost::any_cast<string>(m["RequestUnbalanceSuggestion"]));
    }
    if (m.find("TableScore") != m.end() && !m["TableScore"].empty()) {
      tableScore = make_shared<long>(boost::any_cast<long>(m["TableScore"]));
    }
    if (m.find("WriteRequestHotspotRegionList") != m.end() && !m["WriteRequestHotspotRegionList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["WriteRequestHotspotRegionList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["WriteRequestHotspotRegionList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      writeRequestHotspotRegionList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("WriteRequestUnbalanceSuggestion") != m.end() && !m["WriteRequestUnbalanceSuggestion"].empty()) {
      writeRequestUnbalanceSuggestion = make_shared<string>(boost::any_cast<string>(m["WriteRequestUnbalanceSuggestion"]));
    }
  }


  virtual ~ListDoctorHBaseTablesResponseBodyDataAnalysis() = default;
};
class ListDoctorHBaseTablesResponseBodyDataMetricsColdAccessDay : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  ListDoctorHBaseTablesResponseBodyDataMetricsColdAccessDay() {}

  explicit ListDoctorHBaseTablesResponseBodyDataMetricsColdAccessDay(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~ListDoctorHBaseTablesResponseBodyDataMetricsColdAccessDay() = default;
};
class ListDoctorHBaseTablesResponseBodyDataMetricsColdConfigDay : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  ListDoctorHBaseTablesResponseBodyDataMetricsColdConfigDay() {}

  explicit ListDoctorHBaseTablesResponseBodyDataMetricsColdConfigDay(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~ListDoctorHBaseTablesResponseBodyDataMetricsColdConfigDay() = default;
};
class ListDoctorHBaseTablesResponseBodyDataMetricsColdDataSize : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  ListDoctorHBaseTablesResponseBodyDataMetricsColdDataSize() {}

  explicit ListDoctorHBaseTablesResponseBodyDataMetricsColdDataSize(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~ListDoctorHBaseTablesResponseBodyDataMetricsColdDataSize() = default;
};
class ListDoctorHBaseTablesResponseBodyDataMetricsDailyReadRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  ListDoctorHBaseTablesResponseBodyDataMetricsDailyReadRequest() {}

  explicit ListDoctorHBaseTablesResponseBodyDataMetricsDailyReadRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~ListDoctorHBaseTablesResponseBodyDataMetricsDailyReadRequest() = default;
};
class ListDoctorHBaseTablesResponseBodyDataMetricsDailyReadRequestDayGrowthRatio : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  ListDoctorHBaseTablesResponseBodyDataMetricsDailyReadRequestDayGrowthRatio() {}

  explicit ListDoctorHBaseTablesResponseBodyDataMetricsDailyReadRequestDayGrowthRatio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~ListDoctorHBaseTablesResponseBodyDataMetricsDailyReadRequestDayGrowthRatio() = default;
};
class ListDoctorHBaseTablesResponseBodyDataMetricsDailyWriteRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  ListDoctorHBaseTablesResponseBodyDataMetricsDailyWriteRequest() {}

  explicit ListDoctorHBaseTablesResponseBodyDataMetricsDailyWriteRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~ListDoctorHBaseTablesResponseBodyDataMetricsDailyWriteRequest() = default;
};
class ListDoctorHBaseTablesResponseBodyDataMetricsDailyWriteRequestDayGrowthRatio : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  ListDoctorHBaseTablesResponseBodyDataMetricsDailyWriteRequestDayGrowthRatio() {}

  explicit ListDoctorHBaseTablesResponseBodyDataMetricsDailyWriteRequestDayGrowthRatio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~ListDoctorHBaseTablesResponseBodyDataMetricsDailyWriteRequestDayGrowthRatio() = default;
};
class ListDoctorHBaseTablesResponseBodyDataMetricsFreezeConfigDay : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  ListDoctorHBaseTablesResponseBodyDataMetricsFreezeConfigDay() {}

  explicit ListDoctorHBaseTablesResponseBodyDataMetricsFreezeConfigDay(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~ListDoctorHBaseTablesResponseBodyDataMetricsFreezeConfigDay() = default;
};
class ListDoctorHBaseTablesResponseBodyDataMetricsFreezeDataSize : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  ListDoctorHBaseTablesResponseBodyDataMetricsFreezeDataSize() {}

  explicit ListDoctorHBaseTablesResponseBodyDataMetricsFreezeDataSize(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~ListDoctorHBaseTablesResponseBodyDataMetricsFreezeDataSize() = default;
};
class ListDoctorHBaseTablesResponseBodyDataMetricsHotDataSize : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  ListDoctorHBaseTablesResponseBodyDataMetricsHotDataSize() {}

  explicit ListDoctorHBaseTablesResponseBodyDataMetricsHotDataSize(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~ListDoctorHBaseTablesResponseBodyDataMetricsHotDataSize() = default;
};
class ListDoctorHBaseTablesResponseBodyDataMetricsLocality : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  ListDoctorHBaseTablesResponseBodyDataMetricsLocality() {}

  explicit ListDoctorHBaseTablesResponseBodyDataMetricsLocality(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~ListDoctorHBaseTablesResponseBodyDataMetricsLocality() = default;
};
class ListDoctorHBaseTablesResponseBodyDataMetricsReadRequestBalance : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  ListDoctorHBaseTablesResponseBodyDataMetricsReadRequestBalance() {}

  explicit ListDoctorHBaseTablesResponseBodyDataMetricsReadRequestBalance(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~ListDoctorHBaseTablesResponseBodyDataMetricsReadRequestBalance() = default;
};
class ListDoctorHBaseTablesResponseBodyDataMetricsRegionBalance : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  ListDoctorHBaseTablesResponseBodyDataMetricsRegionBalance() {}

  explicit ListDoctorHBaseTablesResponseBodyDataMetricsRegionBalance(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~ListDoctorHBaseTablesResponseBodyDataMetricsRegionBalance() = default;
};
class ListDoctorHBaseTablesResponseBodyDataMetricsRegionCount : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  ListDoctorHBaseTablesResponseBodyDataMetricsRegionCount() {}

  explicit ListDoctorHBaseTablesResponseBodyDataMetricsRegionCount(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~ListDoctorHBaseTablesResponseBodyDataMetricsRegionCount() = default;
};
class ListDoctorHBaseTablesResponseBodyDataMetricsRegionCountDayGrowthRatio : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  ListDoctorHBaseTablesResponseBodyDataMetricsRegionCountDayGrowthRatio() {}

  explicit ListDoctorHBaseTablesResponseBodyDataMetricsRegionCountDayGrowthRatio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~ListDoctorHBaseTablesResponseBodyDataMetricsRegionCountDayGrowthRatio() = default;
};
class ListDoctorHBaseTablesResponseBodyDataMetricsRegionServerCount : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  ListDoctorHBaseTablesResponseBodyDataMetricsRegionServerCount() {}

  explicit ListDoctorHBaseTablesResponseBodyDataMetricsRegionServerCount(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~ListDoctorHBaseTablesResponseBodyDataMetricsRegionServerCount() = default;
};
class ListDoctorHBaseTablesResponseBodyDataMetricsRequestBalance : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  ListDoctorHBaseTablesResponseBodyDataMetricsRequestBalance() {}

  explicit ListDoctorHBaseTablesResponseBodyDataMetricsRequestBalance(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~ListDoctorHBaseTablesResponseBodyDataMetricsRequestBalance() = default;
};
class ListDoctorHBaseTablesResponseBodyDataMetricsStoreFileCount : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  ListDoctorHBaseTablesResponseBodyDataMetricsStoreFileCount() {}

  explicit ListDoctorHBaseTablesResponseBodyDataMetricsStoreFileCount(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~ListDoctorHBaseTablesResponseBodyDataMetricsStoreFileCount() = default;
};
class ListDoctorHBaseTablesResponseBodyDataMetricsStoreFileCountDayGrowthRatio : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  ListDoctorHBaseTablesResponseBodyDataMetricsStoreFileCountDayGrowthRatio() {}

  explicit ListDoctorHBaseTablesResponseBodyDataMetricsStoreFileCountDayGrowthRatio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~ListDoctorHBaseTablesResponseBodyDataMetricsStoreFileCountDayGrowthRatio() = default;
};
class ListDoctorHBaseTablesResponseBodyDataMetricsTableSize : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  ListDoctorHBaseTablesResponseBodyDataMetricsTableSize() {}

  explicit ListDoctorHBaseTablesResponseBodyDataMetricsTableSize(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~ListDoctorHBaseTablesResponseBodyDataMetricsTableSize() = default;
};
class ListDoctorHBaseTablesResponseBodyDataMetricsTableSizeDayGrowthRatio : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  ListDoctorHBaseTablesResponseBodyDataMetricsTableSizeDayGrowthRatio() {}

  explicit ListDoctorHBaseTablesResponseBodyDataMetricsTableSizeDayGrowthRatio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~ListDoctorHBaseTablesResponseBodyDataMetricsTableSizeDayGrowthRatio() = default;
};
class ListDoctorHBaseTablesResponseBodyDataMetricsWarmConfigDay : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  ListDoctorHBaseTablesResponseBodyDataMetricsWarmConfigDay() {}

  explicit ListDoctorHBaseTablesResponseBodyDataMetricsWarmConfigDay(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~ListDoctorHBaseTablesResponseBodyDataMetricsWarmConfigDay() = default;
};
class ListDoctorHBaseTablesResponseBodyDataMetricsWarmDataSize : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  ListDoctorHBaseTablesResponseBodyDataMetricsWarmDataSize() {}

  explicit ListDoctorHBaseTablesResponseBodyDataMetricsWarmDataSize(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~ListDoctorHBaseTablesResponseBodyDataMetricsWarmDataSize() = default;
};
class ListDoctorHBaseTablesResponseBodyDataMetricsWriteRequestBalance : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  ListDoctorHBaseTablesResponseBodyDataMetricsWriteRequestBalance() {}

  explicit ListDoctorHBaseTablesResponseBodyDataMetricsWriteRequestBalance(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~ListDoctorHBaseTablesResponseBodyDataMetricsWriteRequestBalance() = default;
};
class ListDoctorHBaseTablesResponseBodyDataMetrics : public Darabonba::Model {
public:
  shared_ptr<ListDoctorHBaseTablesResponseBodyDataMetricsColdAccessDay> coldAccessDay{};
  shared_ptr<ListDoctorHBaseTablesResponseBodyDataMetricsColdConfigDay> coldConfigDay{};
  shared_ptr<ListDoctorHBaseTablesResponseBodyDataMetricsColdDataSize> coldDataSize{};
  shared_ptr<ListDoctorHBaseTablesResponseBodyDataMetricsDailyReadRequest> dailyReadRequest{};
  shared_ptr<ListDoctorHBaseTablesResponseBodyDataMetricsDailyReadRequestDayGrowthRatio> dailyReadRequestDayGrowthRatio{};
  shared_ptr<ListDoctorHBaseTablesResponseBodyDataMetricsDailyWriteRequest> dailyWriteRequest{};
  shared_ptr<ListDoctorHBaseTablesResponseBodyDataMetricsDailyWriteRequestDayGrowthRatio> dailyWriteRequestDayGrowthRatio{};
  shared_ptr<ListDoctorHBaseTablesResponseBodyDataMetricsFreezeConfigDay> freezeConfigDay{};
  shared_ptr<ListDoctorHBaseTablesResponseBodyDataMetricsFreezeDataSize> freezeDataSize{};
  shared_ptr<ListDoctorHBaseTablesResponseBodyDataMetricsHotDataSize> hotDataSize{};
  shared_ptr<ListDoctorHBaseTablesResponseBodyDataMetricsLocality> locality{};
  shared_ptr<ListDoctorHBaseTablesResponseBodyDataMetricsReadRequestBalance> readRequestBalance{};
  shared_ptr<ListDoctorHBaseTablesResponseBodyDataMetricsRegionBalance> regionBalance{};
  shared_ptr<ListDoctorHBaseTablesResponseBodyDataMetricsRegionCount> regionCount{};
  shared_ptr<ListDoctorHBaseTablesResponseBodyDataMetricsRegionCountDayGrowthRatio> regionCountDayGrowthRatio{};
  shared_ptr<ListDoctorHBaseTablesResponseBodyDataMetricsRegionServerCount> regionServerCount{};
  shared_ptr<ListDoctorHBaseTablesResponseBodyDataMetricsRequestBalance> requestBalance{};
  shared_ptr<ListDoctorHBaseTablesResponseBodyDataMetricsStoreFileCount> storeFileCount{};
  shared_ptr<ListDoctorHBaseTablesResponseBodyDataMetricsStoreFileCountDayGrowthRatio> storeFileCountDayGrowthRatio{};
  shared_ptr<ListDoctorHBaseTablesResponseBodyDataMetricsTableSize> tableSize{};
  shared_ptr<ListDoctorHBaseTablesResponseBodyDataMetricsTableSizeDayGrowthRatio> tableSizeDayGrowthRatio{};
  shared_ptr<ListDoctorHBaseTablesResponseBodyDataMetricsWarmConfigDay> warmConfigDay{};
  shared_ptr<ListDoctorHBaseTablesResponseBodyDataMetricsWarmDataSize> warmDataSize{};
  shared_ptr<ListDoctorHBaseTablesResponseBodyDataMetricsWriteRequestBalance> writeRequestBalance{};

  ListDoctorHBaseTablesResponseBodyDataMetrics() {}

  explicit ListDoctorHBaseTablesResponseBodyDataMetrics(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (coldAccessDay) {
      res["ColdAccessDay"] = coldAccessDay ? boost::any(coldAccessDay->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (coldConfigDay) {
      res["ColdConfigDay"] = coldConfigDay ? boost::any(coldConfigDay->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (coldDataSize) {
      res["ColdDataSize"] = coldDataSize ? boost::any(coldDataSize->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (dailyReadRequest) {
      res["DailyReadRequest"] = dailyReadRequest ? boost::any(dailyReadRequest->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (dailyReadRequestDayGrowthRatio) {
      res["DailyReadRequestDayGrowthRatio"] = dailyReadRequestDayGrowthRatio ? boost::any(dailyReadRequestDayGrowthRatio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (dailyWriteRequest) {
      res["DailyWriteRequest"] = dailyWriteRequest ? boost::any(dailyWriteRequest->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (dailyWriteRequestDayGrowthRatio) {
      res["DailyWriteRequestDayGrowthRatio"] = dailyWriteRequestDayGrowthRatio ? boost::any(dailyWriteRequestDayGrowthRatio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (freezeConfigDay) {
      res["FreezeConfigDay"] = freezeConfigDay ? boost::any(freezeConfigDay->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (freezeDataSize) {
      res["FreezeDataSize"] = freezeDataSize ? boost::any(freezeDataSize->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (hotDataSize) {
      res["HotDataSize"] = hotDataSize ? boost::any(hotDataSize->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (locality) {
      res["Locality"] = locality ? boost::any(locality->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (readRequestBalance) {
      res["ReadRequestBalance"] = readRequestBalance ? boost::any(readRequestBalance->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (regionBalance) {
      res["RegionBalance"] = regionBalance ? boost::any(regionBalance->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (regionCount) {
      res["RegionCount"] = regionCount ? boost::any(regionCount->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (regionCountDayGrowthRatio) {
      res["RegionCountDayGrowthRatio"] = regionCountDayGrowthRatio ? boost::any(regionCountDayGrowthRatio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (regionServerCount) {
      res["RegionServerCount"] = regionServerCount ? boost::any(regionServerCount->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestBalance) {
      res["RequestBalance"] = requestBalance ? boost::any(requestBalance->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (storeFileCount) {
      res["StoreFileCount"] = storeFileCount ? boost::any(storeFileCount->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (storeFileCountDayGrowthRatio) {
      res["StoreFileCountDayGrowthRatio"] = storeFileCountDayGrowthRatio ? boost::any(storeFileCountDayGrowthRatio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tableSize) {
      res["TableSize"] = tableSize ? boost::any(tableSize->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tableSizeDayGrowthRatio) {
      res["TableSizeDayGrowthRatio"] = tableSizeDayGrowthRatio ? boost::any(tableSizeDayGrowthRatio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (warmConfigDay) {
      res["WarmConfigDay"] = warmConfigDay ? boost::any(warmConfigDay->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (warmDataSize) {
      res["WarmDataSize"] = warmDataSize ? boost::any(warmDataSize->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (writeRequestBalance) {
      res["WriteRequestBalance"] = writeRequestBalance ? boost::any(writeRequestBalance->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ColdAccessDay") != m.end() && !m["ColdAccessDay"].empty()) {
      if (typeid(map<string, boost::any>) == m["ColdAccessDay"].type()) {
        ListDoctorHBaseTablesResponseBodyDataMetricsColdAccessDay model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ColdAccessDay"]));
        coldAccessDay = make_shared<ListDoctorHBaseTablesResponseBodyDataMetricsColdAccessDay>(model1);
      }
    }
    if (m.find("ColdConfigDay") != m.end() && !m["ColdConfigDay"].empty()) {
      if (typeid(map<string, boost::any>) == m["ColdConfigDay"].type()) {
        ListDoctorHBaseTablesResponseBodyDataMetricsColdConfigDay model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ColdConfigDay"]));
        coldConfigDay = make_shared<ListDoctorHBaseTablesResponseBodyDataMetricsColdConfigDay>(model1);
      }
    }
    if (m.find("ColdDataSize") != m.end() && !m["ColdDataSize"].empty()) {
      if (typeid(map<string, boost::any>) == m["ColdDataSize"].type()) {
        ListDoctorHBaseTablesResponseBodyDataMetricsColdDataSize model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ColdDataSize"]));
        coldDataSize = make_shared<ListDoctorHBaseTablesResponseBodyDataMetricsColdDataSize>(model1);
      }
    }
    if (m.find("DailyReadRequest") != m.end() && !m["DailyReadRequest"].empty()) {
      if (typeid(map<string, boost::any>) == m["DailyReadRequest"].type()) {
        ListDoctorHBaseTablesResponseBodyDataMetricsDailyReadRequest model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DailyReadRequest"]));
        dailyReadRequest = make_shared<ListDoctorHBaseTablesResponseBodyDataMetricsDailyReadRequest>(model1);
      }
    }
    if (m.find("DailyReadRequestDayGrowthRatio") != m.end() && !m["DailyReadRequestDayGrowthRatio"].empty()) {
      if (typeid(map<string, boost::any>) == m["DailyReadRequestDayGrowthRatio"].type()) {
        ListDoctorHBaseTablesResponseBodyDataMetricsDailyReadRequestDayGrowthRatio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DailyReadRequestDayGrowthRatio"]));
        dailyReadRequestDayGrowthRatio = make_shared<ListDoctorHBaseTablesResponseBodyDataMetricsDailyReadRequestDayGrowthRatio>(model1);
      }
    }
    if (m.find("DailyWriteRequest") != m.end() && !m["DailyWriteRequest"].empty()) {
      if (typeid(map<string, boost::any>) == m["DailyWriteRequest"].type()) {
        ListDoctorHBaseTablesResponseBodyDataMetricsDailyWriteRequest model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DailyWriteRequest"]));
        dailyWriteRequest = make_shared<ListDoctorHBaseTablesResponseBodyDataMetricsDailyWriteRequest>(model1);
      }
    }
    if (m.find("DailyWriteRequestDayGrowthRatio") != m.end() && !m["DailyWriteRequestDayGrowthRatio"].empty()) {
      if (typeid(map<string, boost::any>) == m["DailyWriteRequestDayGrowthRatio"].type()) {
        ListDoctorHBaseTablesResponseBodyDataMetricsDailyWriteRequestDayGrowthRatio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DailyWriteRequestDayGrowthRatio"]));
        dailyWriteRequestDayGrowthRatio = make_shared<ListDoctorHBaseTablesResponseBodyDataMetricsDailyWriteRequestDayGrowthRatio>(model1);
      }
    }
    if (m.find("FreezeConfigDay") != m.end() && !m["FreezeConfigDay"].empty()) {
      if (typeid(map<string, boost::any>) == m["FreezeConfigDay"].type()) {
        ListDoctorHBaseTablesResponseBodyDataMetricsFreezeConfigDay model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FreezeConfigDay"]));
        freezeConfigDay = make_shared<ListDoctorHBaseTablesResponseBodyDataMetricsFreezeConfigDay>(model1);
      }
    }
    if (m.find("FreezeDataSize") != m.end() && !m["FreezeDataSize"].empty()) {
      if (typeid(map<string, boost::any>) == m["FreezeDataSize"].type()) {
        ListDoctorHBaseTablesResponseBodyDataMetricsFreezeDataSize model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FreezeDataSize"]));
        freezeDataSize = make_shared<ListDoctorHBaseTablesResponseBodyDataMetricsFreezeDataSize>(model1);
      }
    }
    if (m.find("HotDataSize") != m.end() && !m["HotDataSize"].empty()) {
      if (typeid(map<string, boost::any>) == m["HotDataSize"].type()) {
        ListDoctorHBaseTablesResponseBodyDataMetricsHotDataSize model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["HotDataSize"]));
        hotDataSize = make_shared<ListDoctorHBaseTablesResponseBodyDataMetricsHotDataSize>(model1);
      }
    }
    if (m.find("Locality") != m.end() && !m["Locality"].empty()) {
      if (typeid(map<string, boost::any>) == m["Locality"].type()) {
        ListDoctorHBaseTablesResponseBodyDataMetricsLocality model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Locality"]));
        locality = make_shared<ListDoctorHBaseTablesResponseBodyDataMetricsLocality>(model1);
      }
    }
    if (m.find("ReadRequestBalance") != m.end() && !m["ReadRequestBalance"].empty()) {
      if (typeid(map<string, boost::any>) == m["ReadRequestBalance"].type()) {
        ListDoctorHBaseTablesResponseBodyDataMetricsReadRequestBalance model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ReadRequestBalance"]));
        readRequestBalance = make_shared<ListDoctorHBaseTablesResponseBodyDataMetricsReadRequestBalance>(model1);
      }
    }
    if (m.find("RegionBalance") != m.end() && !m["RegionBalance"].empty()) {
      if (typeid(map<string, boost::any>) == m["RegionBalance"].type()) {
        ListDoctorHBaseTablesResponseBodyDataMetricsRegionBalance model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RegionBalance"]));
        regionBalance = make_shared<ListDoctorHBaseTablesResponseBodyDataMetricsRegionBalance>(model1);
      }
    }
    if (m.find("RegionCount") != m.end() && !m["RegionCount"].empty()) {
      if (typeid(map<string, boost::any>) == m["RegionCount"].type()) {
        ListDoctorHBaseTablesResponseBodyDataMetricsRegionCount model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RegionCount"]));
        regionCount = make_shared<ListDoctorHBaseTablesResponseBodyDataMetricsRegionCount>(model1);
      }
    }
    if (m.find("RegionCountDayGrowthRatio") != m.end() && !m["RegionCountDayGrowthRatio"].empty()) {
      if (typeid(map<string, boost::any>) == m["RegionCountDayGrowthRatio"].type()) {
        ListDoctorHBaseTablesResponseBodyDataMetricsRegionCountDayGrowthRatio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RegionCountDayGrowthRatio"]));
        regionCountDayGrowthRatio = make_shared<ListDoctorHBaseTablesResponseBodyDataMetricsRegionCountDayGrowthRatio>(model1);
      }
    }
    if (m.find("RegionServerCount") != m.end() && !m["RegionServerCount"].empty()) {
      if (typeid(map<string, boost::any>) == m["RegionServerCount"].type()) {
        ListDoctorHBaseTablesResponseBodyDataMetricsRegionServerCount model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RegionServerCount"]));
        regionServerCount = make_shared<ListDoctorHBaseTablesResponseBodyDataMetricsRegionServerCount>(model1);
      }
    }
    if (m.find("RequestBalance") != m.end() && !m["RequestBalance"].empty()) {
      if (typeid(map<string, boost::any>) == m["RequestBalance"].type()) {
        ListDoctorHBaseTablesResponseBodyDataMetricsRequestBalance model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RequestBalance"]));
        requestBalance = make_shared<ListDoctorHBaseTablesResponseBodyDataMetricsRequestBalance>(model1);
      }
    }
    if (m.find("StoreFileCount") != m.end() && !m["StoreFileCount"].empty()) {
      if (typeid(map<string, boost::any>) == m["StoreFileCount"].type()) {
        ListDoctorHBaseTablesResponseBodyDataMetricsStoreFileCount model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["StoreFileCount"]));
        storeFileCount = make_shared<ListDoctorHBaseTablesResponseBodyDataMetricsStoreFileCount>(model1);
      }
    }
    if (m.find("StoreFileCountDayGrowthRatio") != m.end() && !m["StoreFileCountDayGrowthRatio"].empty()) {
      if (typeid(map<string, boost::any>) == m["StoreFileCountDayGrowthRatio"].type()) {
        ListDoctorHBaseTablesResponseBodyDataMetricsStoreFileCountDayGrowthRatio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["StoreFileCountDayGrowthRatio"]));
        storeFileCountDayGrowthRatio = make_shared<ListDoctorHBaseTablesResponseBodyDataMetricsStoreFileCountDayGrowthRatio>(model1);
      }
    }
    if (m.find("TableSize") != m.end() && !m["TableSize"].empty()) {
      if (typeid(map<string, boost::any>) == m["TableSize"].type()) {
        ListDoctorHBaseTablesResponseBodyDataMetricsTableSize model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TableSize"]));
        tableSize = make_shared<ListDoctorHBaseTablesResponseBodyDataMetricsTableSize>(model1);
      }
    }
    if (m.find("TableSizeDayGrowthRatio") != m.end() && !m["TableSizeDayGrowthRatio"].empty()) {
      if (typeid(map<string, boost::any>) == m["TableSizeDayGrowthRatio"].type()) {
        ListDoctorHBaseTablesResponseBodyDataMetricsTableSizeDayGrowthRatio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TableSizeDayGrowthRatio"]));
        tableSizeDayGrowthRatio = make_shared<ListDoctorHBaseTablesResponseBodyDataMetricsTableSizeDayGrowthRatio>(model1);
      }
    }
    if (m.find("WarmConfigDay") != m.end() && !m["WarmConfigDay"].empty()) {
      if (typeid(map<string, boost::any>) == m["WarmConfigDay"].type()) {
        ListDoctorHBaseTablesResponseBodyDataMetricsWarmConfigDay model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["WarmConfigDay"]));
        warmConfigDay = make_shared<ListDoctorHBaseTablesResponseBodyDataMetricsWarmConfigDay>(model1);
      }
    }
    if (m.find("WarmDataSize") != m.end() && !m["WarmDataSize"].empty()) {
      if (typeid(map<string, boost::any>) == m["WarmDataSize"].type()) {
        ListDoctorHBaseTablesResponseBodyDataMetricsWarmDataSize model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["WarmDataSize"]));
        warmDataSize = make_shared<ListDoctorHBaseTablesResponseBodyDataMetricsWarmDataSize>(model1);
      }
    }
    if (m.find("WriteRequestBalance") != m.end() && !m["WriteRequestBalance"].empty()) {
      if (typeid(map<string, boost::any>) == m["WriteRequestBalance"].type()) {
        ListDoctorHBaseTablesResponseBodyDataMetricsWriteRequestBalance model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["WriteRequestBalance"]));
        writeRequestBalance = make_shared<ListDoctorHBaseTablesResponseBodyDataMetricsWriteRequestBalance>(model1);
      }
    }
  }


  virtual ~ListDoctorHBaseTablesResponseBodyDataMetrics() = default;
};
class ListDoctorHBaseTablesResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<ListDoctorHBaseTablesResponseBodyDataAnalysis> analysis{};
  shared_ptr<ListDoctorHBaseTablesResponseBodyDataMetrics> metrics{};
  shared_ptr<string> tableName{};

  ListDoctorHBaseTablesResponseBodyData() {}

  explicit ListDoctorHBaseTablesResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (analysis) {
      res["Analysis"] = analysis ? boost::any(analysis->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (metrics) {
      res["Metrics"] = metrics ? boost::any(metrics->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tableName) {
      res["TableName"] = boost::any(*tableName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Analysis") != m.end() && !m["Analysis"].empty()) {
      if (typeid(map<string, boost::any>) == m["Analysis"].type()) {
        ListDoctorHBaseTablesResponseBodyDataAnalysis model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Analysis"]));
        analysis = make_shared<ListDoctorHBaseTablesResponseBodyDataAnalysis>(model1);
      }
    }
    if (m.find("Metrics") != m.end() && !m["Metrics"].empty()) {
      if (typeid(map<string, boost::any>) == m["Metrics"].type()) {
        ListDoctorHBaseTablesResponseBodyDataMetrics model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Metrics"]));
        metrics = make_shared<ListDoctorHBaseTablesResponseBodyDataMetrics>(model1);
      }
    }
    if (m.find("TableName") != m.end() && !m["TableName"].empty()) {
      tableName = make_shared<string>(boost::any_cast<string>(m["TableName"]));
    }
  }


  virtual ~ListDoctorHBaseTablesResponseBodyData() = default;
};
class ListDoctorHBaseTablesResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListDoctorHBaseTablesResponseBodyData>> data{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ListDoctorHBaseTablesResponseBody() {}

  explicit ListDoctorHBaseTablesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<ListDoctorHBaseTablesResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDoctorHBaseTablesResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListDoctorHBaseTablesResponseBodyData>>(expect1);
      }
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListDoctorHBaseTablesResponseBody() = default;
};
class ListDoctorHBaseTablesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListDoctorHBaseTablesResponseBody> body{};

  ListDoctorHBaseTablesResponse() {}

  explicit ListDoctorHBaseTablesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListDoctorHBaseTablesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListDoctorHBaseTablesResponseBody>(model1);
      }
    }
  }


  virtual ~ListDoctorHBaseTablesResponse() = default;
};
class ListDoctorHDFSDirectoriesRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> dateTime{};
  shared_ptr<string> dirPath{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> orderBy{};
  shared_ptr<string> orderType{};
  shared_ptr<string> regionId{};

  ListDoctorHDFSDirectoriesRequest() {}

  explicit ListDoctorHDFSDirectoriesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (dateTime) {
      res["DateTime"] = boost::any(*dateTime);
    }
    if (dirPath) {
      res["DirPath"] = boost::any(*dirPath);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (orderBy) {
      res["OrderBy"] = boost::any(*orderBy);
    }
    if (orderType) {
      res["OrderType"] = boost::any(*orderType);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("DateTime") != m.end() && !m["DateTime"].empty()) {
      dateTime = make_shared<string>(boost::any_cast<string>(m["DateTime"]));
    }
    if (m.find("DirPath") != m.end() && !m["DirPath"].empty()) {
      dirPath = make_shared<string>(boost::any_cast<string>(m["DirPath"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("OrderBy") != m.end() && !m["OrderBy"].empty()) {
      orderBy = make_shared<string>(boost::any_cast<string>(m["OrderBy"]));
    }
    if (m.find("OrderType") != m.end() && !m["OrderType"].empty()) {
      orderType = make_shared<string>(boost::any_cast<string>(m["OrderType"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~ListDoctorHDFSDirectoriesRequest() = default;
};
class ListDoctorHDFSDirectoriesResponseBodyDataMetricsColdDataDayGrowthSize : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  ListDoctorHDFSDirectoriesResponseBodyDataMetricsColdDataDayGrowthSize() {}

  explicit ListDoctorHDFSDirectoriesResponseBodyDataMetricsColdDataDayGrowthSize(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~ListDoctorHDFSDirectoriesResponseBodyDataMetricsColdDataDayGrowthSize() = default;
};
class ListDoctorHDFSDirectoriesResponseBodyDataMetricsColdDataSize : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  ListDoctorHDFSDirectoriesResponseBodyDataMetricsColdDataSize() {}

  explicit ListDoctorHDFSDirectoriesResponseBodyDataMetricsColdDataSize(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~ListDoctorHDFSDirectoriesResponseBodyDataMetricsColdDataSize() = default;
};
class ListDoctorHDFSDirectoriesResponseBodyDataMetricsColdDataSizeDayGrowthRatio : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  ListDoctorHDFSDirectoriesResponseBodyDataMetricsColdDataSizeDayGrowthRatio() {}

  explicit ListDoctorHDFSDirectoriesResponseBodyDataMetricsColdDataSizeDayGrowthRatio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~ListDoctorHDFSDirectoriesResponseBodyDataMetricsColdDataSizeDayGrowthRatio() = default;
};
class ListDoctorHDFSDirectoriesResponseBodyDataMetricsEmptyFileCount : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  ListDoctorHDFSDirectoriesResponseBodyDataMetricsEmptyFileCount() {}

  explicit ListDoctorHDFSDirectoriesResponseBodyDataMetricsEmptyFileCount(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~ListDoctorHDFSDirectoriesResponseBodyDataMetricsEmptyFileCount() = default;
};
class ListDoctorHDFSDirectoriesResponseBodyDataMetricsEmptyFileCountDayGrowthRatio : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  ListDoctorHDFSDirectoriesResponseBodyDataMetricsEmptyFileCountDayGrowthRatio() {}

  explicit ListDoctorHDFSDirectoriesResponseBodyDataMetricsEmptyFileCountDayGrowthRatio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~ListDoctorHDFSDirectoriesResponseBodyDataMetricsEmptyFileCountDayGrowthRatio() = default;
};
class ListDoctorHDFSDirectoriesResponseBodyDataMetricsEmptyFileDayGrowthCount : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  ListDoctorHDFSDirectoriesResponseBodyDataMetricsEmptyFileDayGrowthCount() {}

  explicit ListDoctorHDFSDirectoriesResponseBodyDataMetricsEmptyFileDayGrowthCount(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~ListDoctorHDFSDirectoriesResponseBodyDataMetricsEmptyFileDayGrowthCount() = default;
};
class ListDoctorHDFSDirectoriesResponseBodyDataMetricsFreezeDataDayGrowthSize : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  ListDoctorHDFSDirectoriesResponseBodyDataMetricsFreezeDataDayGrowthSize() {}

  explicit ListDoctorHDFSDirectoriesResponseBodyDataMetricsFreezeDataDayGrowthSize(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~ListDoctorHDFSDirectoriesResponseBodyDataMetricsFreezeDataDayGrowthSize() = default;
};
class ListDoctorHDFSDirectoriesResponseBodyDataMetricsFreezeDataSize : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  ListDoctorHDFSDirectoriesResponseBodyDataMetricsFreezeDataSize() {}

  explicit ListDoctorHDFSDirectoriesResponseBodyDataMetricsFreezeDataSize(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~ListDoctorHDFSDirectoriesResponseBodyDataMetricsFreezeDataSize() = default;
};
class ListDoctorHDFSDirectoriesResponseBodyDataMetricsFreezeDataSizeDayGrowthRatio : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  ListDoctorHDFSDirectoriesResponseBodyDataMetricsFreezeDataSizeDayGrowthRatio() {}

  explicit ListDoctorHDFSDirectoriesResponseBodyDataMetricsFreezeDataSizeDayGrowthRatio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~ListDoctorHDFSDirectoriesResponseBodyDataMetricsFreezeDataSizeDayGrowthRatio() = default;
};
class ListDoctorHDFSDirectoriesResponseBodyDataMetricsHotDataDayGrowthSize : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  ListDoctorHDFSDirectoriesResponseBodyDataMetricsHotDataDayGrowthSize() {}

  explicit ListDoctorHDFSDirectoriesResponseBodyDataMetricsHotDataDayGrowthSize(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~ListDoctorHDFSDirectoriesResponseBodyDataMetricsHotDataDayGrowthSize() = default;
};
class ListDoctorHDFSDirectoriesResponseBodyDataMetricsHotDataSize : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  ListDoctorHDFSDirectoriesResponseBodyDataMetricsHotDataSize() {}

  explicit ListDoctorHDFSDirectoriesResponseBodyDataMetricsHotDataSize(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~ListDoctorHDFSDirectoriesResponseBodyDataMetricsHotDataSize() = default;
};
class ListDoctorHDFSDirectoriesResponseBodyDataMetricsHotDataSizeDayGrowthRatio : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  ListDoctorHDFSDirectoriesResponseBodyDataMetricsHotDataSizeDayGrowthRatio() {}

  explicit ListDoctorHDFSDirectoriesResponseBodyDataMetricsHotDataSizeDayGrowthRatio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~ListDoctorHDFSDirectoriesResponseBodyDataMetricsHotDataSizeDayGrowthRatio() = default;
};
class ListDoctorHDFSDirectoriesResponseBodyDataMetricsLargeFileCount : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  ListDoctorHDFSDirectoriesResponseBodyDataMetricsLargeFileCount() {}

  explicit ListDoctorHDFSDirectoriesResponseBodyDataMetricsLargeFileCount(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~ListDoctorHDFSDirectoriesResponseBodyDataMetricsLargeFileCount() = default;
};
class ListDoctorHDFSDirectoriesResponseBodyDataMetricsLargeFileCountDayGrowthRatio : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  ListDoctorHDFSDirectoriesResponseBodyDataMetricsLargeFileCountDayGrowthRatio() {}

  explicit ListDoctorHDFSDirectoriesResponseBodyDataMetricsLargeFileCountDayGrowthRatio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~ListDoctorHDFSDirectoriesResponseBodyDataMetricsLargeFileCountDayGrowthRatio() = default;
};
class ListDoctorHDFSDirectoriesResponseBodyDataMetricsLargeFileDayGrowthCount : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  ListDoctorHDFSDirectoriesResponseBodyDataMetricsLargeFileDayGrowthCount() {}

  explicit ListDoctorHDFSDirectoriesResponseBodyDataMetricsLargeFileDayGrowthCount(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~ListDoctorHDFSDirectoriesResponseBodyDataMetricsLargeFileDayGrowthCount() = default;
};
class ListDoctorHDFSDirectoriesResponseBodyDataMetricsMediumFileCount : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  ListDoctorHDFSDirectoriesResponseBodyDataMetricsMediumFileCount() {}

  explicit ListDoctorHDFSDirectoriesResponseBodyDataMetricsMediumFileCount(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~ListDoctorHDFSDirectoriesResponseBodyDataMetricsMediumFileCount() = default;
};
class ListDoctorHDFSDirectoriesResponseBodyDataMetricsMediumFileCountDayGrowthRatio : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  ListDoctorHDFSDirectoriesResponseBodyDataMetricsMediumFileCountDayGrowthRatio() {}

  explicit ListDoctorHDFSDirectoriesResponseBodyDataMetricsMediumFileCountDayGrowthRatio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~ListDoctorHDFSDirectoriesResponseBodyDataMetricsMediumFileCountDayGrowthRatio() = default;
};
class ListDoctorHDFSDirectoriesResponseBodyDataMetricsMediumFileDayGrowthCount : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  ListDoctorHDFSDirectoriesResponseBodyDataMetricsMediumFileDayGrowthCount() {}

  explicit ListDoctorHDFSDirectoriesResponseBodyDataMetricsMediumFileDayGrowthCount(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~ListDoctorHDFSDirectoriesResponseBodyDataMetricsMediumFileDayGrowthCount() = default;
};
class ListDoctorHDFSDirectoriesResponseBodyDataMetricsSmallFileCount : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  ListDoctorHDFSDirectoriesResponseBodyDataMetricsSmallFileCount() {}

  explicit ListDoctorHDFSDirectoriesResponseBodyDataMetricsSmallFileCount(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~ListDoctorHDFSDirectoriesResponseBodyDataMetricsSmallFileCount() = default;
};
class ListDoctorHDFSDirectoriesResponseBodyDataMetricsSmallFileCountDayGrowthRatio : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  ListDoctorHDFSDirectoriesResponseBodyDataMetricsSmallFileCountDayGrowthRatio() {}

  explicit ListDoctorHDFSDirectoriesResponseBodyDataMetricsSmallFileCountDayGrowthRatio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~ListDoctorHDFSDirectoriesResponseBodyDataMetricsSmallFileCountDayGrowthRatio() = default;
};
class ListDoctorHDFSDirectoriesResponseBodyDataMetricsSmallFileDayGrowthCount : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  ListDoctorHDFSDirectoriesResponseBodyDataMetricsSmallFileDayGrowthCount() {}

  explicit ListDoctorHDFSDirectoriesResponseBodyDataMetricsSmallFileDayGrowthCount(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~ListDoctorHDFSDirectoriesResponseBodyDataMetricsSmallFileDayGrowthCount() = default;
};
class ListDoctorHDFSDirectoriesResponseBodyDataMetricsTinyFileCount : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  ListDoctorHDFSDirectoriesResponseBodyDataMetricsTinyFileCount() {}

  explicit ListDoctorHDFSDirectoriesResponseBodyDataMetricsTinyFileCount(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~ListDoctorHDFSDirectoriesResponseBodyDataMetricsTinyFileCount() = default;
};
class ListDoctorHDFSDirectoriesResponseBodyDataMetricsTinyFileCountDayGrowthRatio : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  ListDoctorHDFSDirectoriesResponseBodyDataMetricsTinyFileCountDayGrowthRatio() {}

  explicit ListDoctorHDFSDirectoriesResponseBodyDataMetricsTinyFileCountDayGrowthRatio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~ListDoctorHDFSDirectoriesResponseBodyDataMetricsTinyFileCountDayGrowthRatio() = default;
};
class ListDoctorHDFSDirectoriesResponseBodyDataMetricsTinyFileDayGrowthCount : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  ListDoctorHDFSDirectoriesResponseBodyDataMetricsTinyFileDayGrowthCount() {}

  explicit ListDoctorHDFSDirectoriesResponseBodyDataMetricsTinyFileDayGrowthCount(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~ListDoctorHDFSDirectoriesResponseBodyDataMetricsTinyFileDayGrowthCount() = default;
};
class ListDoctorHDFSDirectoriesResponseBodyDataMetricsTotalDataDayGrowthSize : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  ListDoctorHDFSDirectoriesResponseBodyDataMetricsTotalDataDayGrowthSize() {}

  explicit ListDoctorHDFSDirectoriesResponseBodyDataMetricsTotalDataDayGrowthSize(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~ListDoctorHDFSDirectoriesResponseBodyDataMetricsTotalDataDayGrowthSize() = default;
};
class ListDoctorHDFSDirectoriesResponseBodyDataMetricsTotalDataSize : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  ListDoctorHDFSDirectoriesResponseBodyDataMetricsTotalDataSize() {}

  explicit ListDoctorHDFSDirectoriesResponseBodyDataMetricsTotalDataSize(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~ListDoctorHDFSDirectoriesResponseBodyDataMetricsTotalDataSize() = default;
};
class ListDoctorHDFSDirectoriesResponseBodyDataMetricsTotalDataSizeDayGrowthRatio : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  ListDoctorHDFSDirectoriesResponseBodyDataMetricsTotalDataSizeDayGrowthRatio() {}

  explicit ListDoctorHDFSDirectoriesResponseBodyDataMetricsTotalDataSizeDayGrowthRatio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~ListDoctorHDFSDirectoriesResponseBodyDataMetricsTotalDataSizeDayGrowthRatio() = default;
};
class ListDoctorHDFSDirectoriesResponseBodyDataMetricsTotalFileCount : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  ListDoctorHDFSDirectoriesResponseBodyDataMetricsTotalFileCount() {}

  explicit ListDoctorHDFSDirectoriesResponseBodyDataMetricsTotalFileCount(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~ListDoctorHDFSDirectoriesResponseBodyDataMetricsTotalFileCount() = default;
};
class ListDoctorHDFSDirectoriesResponseBodyDataMetricsTotalFileCountDayGrowthRatio : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  ListDoctorHDFSDirectoriesResponseBodyDataMetricsTotalFileCountDayGrowthRatio() {}

  explicit ListDoctorHDFSDirectoriesResponseBodyDataMetricsTotalFileCountDayGrowthRatio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~ListDoctorHDFSDirectoriesResponseBodyDataMetricsTotalFileCountDayGrowthRatio() = default;
};
class ListDoctorHDFSDirectoriesResponseBodyDataMetricsTotalFileDayGrowthCount : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  ListDoctorHDFSDirectoriesResponseBodyDataMetricsTotalFileDayGrowthCount() {}

  explicit ListDoctorHDFSDirectoriesResponseBodyDataMetricsTotalFileDayGrowthCount(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~ListDoctorHDFSDirectoriesResponseBodyDataMetricsTotalFileDayGrowthCount() = default;
};
class ListDoctorHDFSDirectoriesResponseBodyDataMetricsWarmDataDayGrowthSize : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  ListDoctorHDFSDirectoriesResponseBodyDataMetricsWarmDataDayGrowthSize() {}

  explicit ListDoctorHDFSDirectoriesResponseBodyDataMetricsWarmDataDayGrowthSize(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~ListDoctorHDFSDirectoriesResponseBodyDataMetricsWarmDataDayGrowthSize() = default;
};
class ListDoctorHDFSDirectoriesResponseBodyDataMetricsWarmDataSize : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  ListDoctorHDFSDirectoriesResponseBodyDataMetricsWarmDataSize() {}

  explicit ListDoctorHDFSDirectoriesResponseBodyDataMetricsWarmDataSize(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~ListDoctorHDFSDirectoriesResponseBodyDataMetricsWarmDataSize() = default;
};
class ListDoctorHDFSDirectoriesResponseBodyDataMetricsWarmDataSizeDayGrowthRatio : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  ListDoctorHDFSDirectoriesResponseBodyDataMetricsWarmDataSizeDayGrowthRatio() {}

  explicit ListDoctorHDFSDirectoriesResponseBodyDataMetricsWarmDataSizeDayGrowthRatio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~ListDoctorHDFSDirectoriesResponseBodyDataMetricsWarmDataSizeDayGrowthRatio() = default;
};
class ListDoctorHDFSDirectoriesResponseBodyDataMetrics : public Darabonba::Model {
public:
  shared_ptr<ListDoctorHDFSDirectoriesResponseBodyDataMetricsColdDataDayGrowthSize> coldDataDayGrowthSize{};
  shared_ptr<ListDoctorHDFSDirectoriesResponseBodyDataMetricsColdDataSize> coldDataSize{};
  shared_ptr<ListDoctorHDFSDirectoriesResponseBodyDataMetricsColdDataSizeDayGrowthRatio> coldDataSizeDayGrowthRatio{};
  shared_ptr<ListDoctorHDFSDirectoriesResponseBodyDataMetricsEmptyFileCount> emptyFileCount{};
  shared_ptr<ListDoctorHDFSDirectoriesResponseBodyDataMetricsEmptyFileCountDayGrowthRatio> emptyFileCountDayGrowthRatio{};
  shared_ptr<ListDoctorHDFSDirectoriesResponseBodyDataMetricsEmptyFileDayGrowthCount> emptyFileDayGrowthCount{};
  shared_ptr<ListDoctorHDFSDirectoriesResponseBodyDataMetricsFreezeDataDayGrowthSize> freezeDataDayGrowthSize{};
  shared_ptr<ListDoctorHDFSDirectoriesResponseBodyDataMetricsFreezeDataSize> freezeDataSize{};
  shared_ptr<ListDoctorHDFSDirectoriesResponseBodyDataMetricsFreezeDataSizeDayGrowthRatio> freezeDataSizeDayGrowthRatio{};
  shared_ptr<ListDoctorHDFSDirectoriesResponseBodyDataMetricsHotDataDayGrowthSize> hotDataDayGrowthSize{};
  shared_ptr<ListDoctorHDFSDirectoriesResponseBodyDataMetricsHotDataSize> hotDataSize{};
  shared_ptr<ListDoctorHDFSDirectoriesResponseBodyDataMetricsHotDataSizeDayGrowthRatio> hotDataSizeDayGrowthRatio{};
  shared_ptr<ListDoctorHDFSDirectoriesResponseBodyDataMetricsLargeFileCount> largeFileCount{};
  shared_ptr<ListDoctorHDFSDirectoriesResponseBodyDataMetricsLargeFileCountDayGrowthRatio> largeFileCountDayGrowthRatio{};
  shared_ptr<ListDoctorHDFSDirectoriesResponseBodyDataMetricsLargeFileDayGrowthCount> largeFileDayGrowthCount{};
  shared_ptr<ListDoctorHDFSDirectoriesResponseBodyDataMetricsMediumFileCount> mediumFileCount{};
  shared_ptr<ListDoctorHDFSDirectoriesResponseBodyDataMetricsMediumFileCountDayGrowthRatio> mediumFileCountDayGrowthRatio{};
  shared_ptr<ListDoctorHDFSDirectoriesResponseBodyDataMetricsMediumFileDayGrowthCount> mediumFileDayGrowthCount{};
  shared_ptr<ListDoctorHDFSDirectoriesResponseBodyDataMetricsSmallFileCount> smallFileCount{};
  shared_ptr<ListDoctorHDFSDirectoriesResponseBodyDataMetricsSmallFileCountDayGrowthRatio> smallFileCountDayGrowthRatio{};
  shared_ptr<ListDoctorHDFSDirectoriesResponseBodyDataMetricsSmallFileDayGrowthCount> smallFileDayGrowthCount{};
  shared_ptr<ListDoctorHDFSDirectoriesResponseBodyDataMetricsTinyFileCount> tinyFileCount{};
  shared_ptr<ListDoctorHDFSDirectoriesResponseBodyDataMetricsTinyFileCountDayGrowthRatio> tinyFileCountDayGrowthRatio{};
  shared_ptr<ListDoctorHDFSDirectoriesResponseBodyDataMetricsTinyFileDayGrowthCount> tinyFileDayGrowthCount{};
  shared_ptr<ListDoctorHDFSDirectoriesResponseBodyDataMetricsTotalDataDayGrowthSize> totalDataDayGrowthSize{};
  shared_ptr<ListDoctorHDFSDirectoriesResponseBodyDataMetricsTotalDataSize> totalDataSize{};
  shared_ptr<ListDoctorHDFSDirectoriesResponseBodyDataMetricsTotalDataSizeDayGrowthRatio> totalDataSizeDayGrowthRatio{};
  shared_ptr<ListDoctorHDFSDirectoriesResponseBodyDataMetricsTotalFileCount> totalFileCount{};
  shared_ptr<ListDoctorHDFSDirectoriesResponseBodyDataMetricsTotalFileCountDayGrowthRatio> totalFileCountDayGrowthRatio{};
  shared_ptr<ListDoctorHDFSDirectoriesResponseBodyDataMetricsTotalFileDayGrowthCount> totalFileDayGrowthCount{};
  shared_ptr<ListDoctorHDFSDirectoriesResponseBodyDataMetricsWarmDataDayGrowthSize> warmDataDayGrowthSize{};
  shared_ptr<ListDoctorHDFSDirectoriesResponseBodyDataMetricsWarmDataSize> warmDataSize{};
  shared_ptr<ListDoctorHDFSDirectoriesResponseBodyDataMetricsWarmDataSizeDayGrowthRatio> warmDataSizeDayGrowthRatio{};

  ListDoctorHDFSDirectoriesResponseBodyDataMetrics() {}

  explicit ListDoctorHDFSDirectoriesResponseBodyDataMetrics(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (coldDataDayGrowthSize) {
      res["ColdDataDayGrowthSize"] = coldDataDayGrowthSize ? boost::any(coldDataDayGrowthSize->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (coldDataSize) {
      res["ColdDataSize"] = coldDataSize ? boost::any(coldDataSize->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (coldDataSizeDayGrowthRatio) {
      res["ColdDataSizeDayGrowthRatio"] = coldDataSizeDayGrowthRatio ? boost::any(coldDataSizeDayGrowthRatio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (emptyFileCount) {
      res["EmptyFileCount"] = emptyFileCount ? boost::any(emptyFileCount->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (emptyFileCountDayGrowthRatio) {
      res["EmptyFileCountDayGrowthRatio"] = emptyFileCountDayGrowthRatio ? boost::any(emptyFileCountDayGrowthRatio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (emptyFileDayGrowthCount) {
      res["EmptyFileDayGrowthCount"] = emptyFileDayGrowthCount ? boost::any(emptyFileDayGrowthCount->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (freezeDataDayGrowthSize) {
      res["FreezeDataDayGrowthSize"] = freezeDataDayGrowthSize ? boost::any(freezeDataDayGrowthSize->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (freezeDataSize) {
      res["FreezeDataSize"] = freezeDataSize ? boost::any(freezeDataSize->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (freezeDataSizeDayGrowthRatio) {
      res["FreezeDataSizeDayGrowthRatio"] = freezeDataSizeDayGrowthRatio ? boost::any(freezeDataSizeDayGrowthRatio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (hotDataDayGrowthSize) {
      res["HotDataDayGrowthSize"] = hotDataDayGrowthSize ? boost::any(hotDataDayGrowthSize->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (hotDataSize) {
      res["HotDataSize"] = hotDataSize ? boost::any(hotDataSize->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (hotDataSizeDayGrowthRatio) {
      res["HotDataSizeDayGrowthRatio"] = hotDataSizeDayGrowthRatio ? boost::any(hotDataSizeDayGrowthRatio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (largeFileCount) {
      res["LargeFileCount"] = largeFileCount ? boost::any(largeFileCount->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (largeFileCountDayGrowthRatio) {
      res["LargeFileCountDayGrowthRatio"] = largeFileCountDayGrowthRatio ? boost::any(largeFileCountDayGrowthRatio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (largeFileDayGrowthCount) {
      res["LargeFileDayGrowthCount"] = largeFileDayGrowthCount ? boost::any(largeFileDayGrowthCount->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (mediumFileCount) {
      res["MediumFileCount"] = mediumFileCount ? boost::any(mediumFileCount->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (mediumFileCountDayGrowthRatio) {
      res["MediumFileCountDayGrowthRatio"] = mediumFileCountDayGrowthRatio ? boost::any(mediumFileCountDayGrowthRatio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (mediumFileDayGrowthCount) {
      res["MediumFileDayGrowthCount"] = mediumFileDayGrowthCount ? boost::any(mediumFileDayGrowthCount->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (smallFileCount) {
      res["SmallFileCount"] = smallFileCount ? boost::any(smallFileCount->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (smallFileCountDayGrowthRatio) {
      res["SmallFileCountDayGrowthRatio"] = smallFileCountDayGrowthRatio ? boost::any(smallFileCountDayGrowthRatio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (smallFileDayGrowthCount) {
      res["SmallFileDayGrowthCount"] = smallFileDayGrowthCount ? boost::any(smallFileDayGrowthCount->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tinyFileCount) {
      res["TinyFileCount"] = tinyFileCount ? boost::any(tinyFileCount->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tinyFileCountDayGrowthRatio) {
      res["TinyFileCountDayGrowthRatio"] = tinyFileCountDayGrowthRatio ? boost::any(tinyFileCountDayGrowthRatio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tinyFileDayGrowthCount) {
      res["TinyFileDayGrowthCount"] = tinyFileDayGrowthCount ? boost::any(tinyFileDayGrowthCount->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (totalDataDayGrowthSize) {
      res["TotalDataDayGrowthSize"] = totalDataDayGrowthSize ? boost::any(totalDataDayGrowthSize->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (totalDataSize) {
      res["TotalDataSize"] = totalDataSize ? boost::any(totalDataSize->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (totalDataSizeDayGrowthRatio) {
      res["TotalDataSizeDayGrowthRatio"] = totalDataSizeDayGrowthRatio ? boost::any(totalDataSizeDayGrowthRatio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (totalFileCount) {
      res["TotalFileCount"] = totalFileCount ? boost::any(totalFileCount->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (totalFileCountDayGrowthRatio) {
      res["TotalFileCountDayGrowthRatio"] = totalFileCountDayGrowthRatio ? boost::any(totalFileCountDayGrowthRatio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (totalFileDayGrowthCount) {
      res["TotalFileDayGrowthCount"] = totalFileDayGrowthCount ? boost::any(totalFileDayGrowthCount->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (warmDataDayGrowthSize) {
      res["WarmDataDayGrowthSize"] = warmDataDayGrowthSize ? boost::any(warmDataDayGrowthSize->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (warmDataSize) {
      res["WarmDataSize"] = warmDataSize ? boost::any(warmDataSize->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (warmDataSizeDayGrowthRatio) {
      res["WarmDataSizeDayGrowthRatio"] = warmDataSizeDayGrowthRatio ? boost::any(warmDataSizeDayGrowthRatio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ColdDataDayGrowthSize") != m.end() && !m["ColdDataDayGrowthSize"].empty()) {
      if (typeid(map<string, boost::any>) == m["ColdDataDayGrowthSize"].type()) {
        ListDoctorHDFSDirectoriesResponseBodyDataMetricsColdDataDayGrowthSize model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ColdDataDayGrowthSize"]));
        coldDataDayGrowthSize = make_shared<ListDoctorHDFSDirectoriesResponseBodyDataMetricsColdDataDayGrowthSize>(model1);
      }
    }
    if (m.find("ColdDataSize") != m.end() && !m["ColdDataSize"].empty()) {
      if (typeid(map<string, boost::any>) == m["ColdDataSize"].type()) {
        ListDoctorHDFSDirectoriesResponseBodyDataMetricsColdDataSize model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ColdDataSize"]));
        coldDataSize = make_shared<ListDoctorHDFSDirectoriesResponseBodyDataMetricsColdDataSize>(model1);
      }
    }
    if (m.find("ColdDataSizeDayGrowthRatio") != m.end() && !m["ColdDataSizeDayGrowthRatio"].empty()) {
      if (typeid(map<string, boost::any>) == m["ColdDataSizeDayGrowthRatio"].type()) {
        ListDoctorHDFSDirectoriesResponseBodyDataMetricsColdDataSizeDayGrowthRatio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ColdDataSizeDayGrowthRatio"]));
        coldDataSizeDayGrowthRatio = make_shared<ListDoctorHDFSDirectoriesResponseBodyDataMetricsColdDataSizeDayGrowthRatio>(model1);
      }
    }
    if (m.find("EmptyFileCount") != m.end() && !m["EmptyFileCount"].empty()) {
      if (typeid(map<string, boost::any>) == m["EmptyFileCount"].type()) {
        ListDoctorHDFSDirectoriesResponseBodyDataMetricsEmptyFileCount model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EmptyFileCount"]));
        emptyFileCount = make_shared<ListDoctorHDFSDirectoriesResponseBodyDataMetricsEmptyFileCount>(model1);
      }
    }
    if (m.find("EmptyFileCountDayGrowthRatio") != m.end() && !m["EmptyFileCountDayGrowthRatio"].empty()) {
      if (typeid(map<string, boost::any>) == m["EmptyFileCountDayGrowthRatio"].type()) {
        ListDoctorHDFSDirectoriesResponseBodyDataMetricsEmptyFileCountDayGrowthRatio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EmptyFileCountDayGrowthRatio"]));
        emptyFileCountDayGrowthRatio = make_shared<ListDoctorHDFSDirectoriesResponseBodyDataMetricsEmptyFileCountDayGrowthRatio>(model1);
      }
    }
    if (m.find("EmptyFileDayGrowthCount") != m.end() && !m["EmptyFileDayGrowthCount"].empty()) {
      if (typeid(map<string, boost::any>) == m["EmptyFileDayGrowthCount"].type()) {
        ListDoctorHDFSDirectoriesResponseBodyDataMetricsEmptyFileDayGrowthCount model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EmptyFileDayGrowthCount"]));
        emptyFileDayGrowthCount = make_shared<ListDoctorHDFSDirectoriesResponseBodyDataMetricsEmptyFileDayGrowthCount>(model1);
      }
    }
    if (m.find("FreezeDataDayGrowthSize") != m.end() && !m["FreezeDataDayGrowthSize"].empty()) {
      if (typeid(map<string, boost::any>) == m["FreezeDataDayGrowthSize"].type()) {
        ListDoctorHDFSDirectoriesResponseBodyDataMetricsFreezeDataDayGrowthSize model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FreezeDataDayGrowthSize"]));
        freezeDataDayGrowthSize = make_shared<ListDoctorHDFSDirectoriesResponseBodyDataMetricsFreezeDataDayGrowthSize>(model1);
      }
    }
    if (m.find("FreezeDataSize") != m.end() && !m["FreezeDataSize"].empty()) {
      if (typeid(map<string, boost::any>) == m["FreezeDataSize"].type()) {
        ListDoctorHDFSDirectoriesResponseBodyDataMetricsFreezeDataSize model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FreezeDataSize"]));
        freezeDataSize = make_shared<ListDoctorHDFSDirectoriesResponseBodyDataMetricsFreezeDataSize>(model1);
      }
    }
    if (m.find("FreezeDataSizeDayGrowthRatio") != m.end() && !m["FreezeDataSizeDayGrowthRatio"].empty()) {
      if (typeid(map<string, boost::any>) == m["FreezeDataSizeDayGrowthRatio"].type()) {
        ListDoctorHDFSDirectoriesResponseBodyDataMetricsFreezeDataSizeDayGrowthRatio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FreezeDataSizeDayGrowthRatio"]));
        freezeDataSizeDayGrowthRatio = make_shared<ListDoctorHDFSDirectoriesResponseBodyDataMetricsFreezeDataSizeDayGrowthRatio>(model1);
      }
    }
    if (m.find("HotDataDayGrowthSize") != m.end() && !m["HotDataDayGrowthSize"].empty()) {
      if (typeid(map<string, boost::any>) == m["HotDataDayGrowthSize"].type()) {
        ListDoctorHDFSDirectoriesResponseBodyDataMetricsHotDataDayGrowthSize model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["HotDataDayGrowthSize"]));
        hotDataDayGrowthSize = make_shared<ListDoctorHDFSDirectoriesResponseBodyDataMetricsHotDataDayGrowthSize>(model1);
      }
    }
    if (m.find("HotDataSize") != m.end() && !m["HotDataSize"].empty()) {
      if (typeid(map<string, boost::any>) == m["HotDataSize"].type()) {
        ListDoctorHDFSDirectoriesResponseBodyDataMetricsHotDataSize model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["HotDataSize"]));
        hotDataSize = make_shared<ListDoctorHDFSDirectoriesResponseBodyDataMetricsHotDataSize>(model1);
      }
    }
    if (m.find("HotDataSizeDayGrowthRatio") != m.end() && !m["HotDataSizeDayGrowthRatio"].empty()) {
      if (typeid(map<string, boost::any>) == m["HotDataSizeDayGrowthRatio"].type()) {
        ListDoctorHDFSDirectoriesResponseBodyDataMetricsHotDataSizeDayGrowthRatio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["HotDataSizeDayGrowthRatio"]));
        hotDataSizeDayGrowthRatio = make_shared<ListDoctorHDFSDirectoriesResponseBodyDataMetricsHotDataSizeDayGrowthRatio>(model1);
      }
    }
    if (m.find("LargeFileCount") != m.end() && !m["LargeFileCount"].empty()) {
      if (typeid(map<string, boost::any>) == m["LargeFileCount"].type()) {
        ListDoctorHDFSDirectoriesResponseBodyDataMetricsLargeFileCount model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LargeFileCount"]));
        largeFileCount = make_shared<ListDoctorHDFSDirectoriesResponseBodyDataMetricsLargeFileCount>(model1);
      }
    }
    if (m.find("LargeFileCountDayGrowthRatio") != m.end() && !m["LargeFileCountDayGrowthRatio"].empty()) {
      if (typeid(map<string, boost::any>) == m["LargeFileCountDayGrowthRatio"].type()) {
        ListDoctorHDFSDirectoriesResponseBodyDataMetricsLargeFileCountDayGrowthRatio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LargeFileCountDayGrowthRatio"]));
        largeFileCountDayGrowthRatio = make_shared<ListDoctorHDFSDirectoriesResponseBodyDataMetricsLargeFileCountDayGrowthRatio>(model1);
      }
    }
    if (m.find("LargeFileDayGrowthCount") != m.end() && !m["LargeFileDayGrowthCount"].empty()) {
      if (typeid(map<string, boost::any>) == m["LargeFileDayGrowthCount"].type()) {
        ListDoctorHDFSDirectoriesResponseBodyDataMetricsLargeFileDayGrowthCount model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LargeFileDayGrowthCount"]));
        largeFileDayGrowthCount = make_shared<ListDoctorHDFSDirectoriesResponseBodyDataMetricsLargeFileDayGrowthCount>(model1);
      }
    }
    if (m.find("MediumFileCount") != m.end() && !m["MediumFileCount"].empty()) {
      if (typeid(map<string, boost::any>) == m["MediumFileCount"].type()) {
        ListDoctorHDFSDirectoriesResponseBodyDataMetricsMediumFileCount model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MediumFileCount"]));
        mediumFileCount = make_shared<ListDoctorHDFSDirectoriesResponseBodyDataMetricsMediumFileCount>(model1);
      }
    }
    if (m.find("MediumFileCountDayGrowthRatio") != m.end() && !m["MediumFileCountDayGrowthRatio"].empty()) {
      if (typeid(map<string, boost::any>) == m["MediumFileCountDayGrowthRatio"].type()) {
        ListDoctorHDFSDirectoriesResponseBodyDataMetricsMediumFileCountDayGrowthRatio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MediumFileCountDayGrowthRatio"]));
        mediumFileCountDayGrowthRatio = make_shared<ListDoctorHDFSDirectoriesResponseBodyDataMetricsMediumFileCountDayGrowthRatio>(model1);
      }
    }
    if (m.find("MediumFileDayGrowthCount") != m.end() && !m["MediumFileDayGrowthCount"].empty()) {
      if (typeid(map<string, boost::any>) == m["MediumFileDayGrowthCount"].type()) {
        ListDoctorHDFSDirectoriesResponseBodyDataMetricsMediumFileDayGrowthCount model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MediumFileDayGrowthCount"]));
        mediumFileDayGrowthCount = make_shared<ListDoctorHDFSDirectoriesResponseBodyDataMetricsMediumFileDayGrowthCount>(model1);
      }
    }
    if (m.find("SmallFileCount") != m.end() && !m["SmallFileCount"].empty()) {
      if (typeid(map<string, boost::any>) == m["SmallFileCount"].type()) {
        ListDoctorHDFSDirectoriesResponseBodyDataMetricsSmallFileCount model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SmallFileCount"]));
        smallFileCount = make_shared<ListDoctorHDFSDirectoriesResponseBodyDataMetricsSmallFileCount>(model1);
      }
    }
    if (m.find("SmallFileCountDayGrowthRatio") != m.end() && !m["SmallFileCountDayGrowthRatio"].empty()) {
      if (typeid(map<string, boost::any>) == m["SmallFileCountDayGrowthRatio"].type()) {
        ListDoctorHDFSDirectoriesResponseBodyDataMetricsSmallFileCountDayGrowthRatio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SmallFileCountDayGrowthRatio"]));
        smallFileCountDayGrowthRatio = make_shared<ListDoctorHDFSDirectoriesResponseBodyDataMetricsSmallFileCountDayGrowthRatio>(model1);
      }
    }
    if (m.find("SmallFileDayGrowthCount") != m.end() && !m["SmallFileDayGrowthCount"].empty()) {
      if (typeid(map<string, boost::any>) == m["SmallFileDayGrowthCount"].type()) {
        ListDoctorHDFSDirectoriesResponseBodyDataMetricsSmallFileDayGrowthCount model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SmallFileDayGrowthCount"]));
        smallFileDayGrowthCount = make_shared<ListDoctorHDFSDirectoriesResponseBodyDataMetricsSmallFileDayGrowthCount>(model1);
      }
    }
    if (m.find("TinyFileCount") != m.end() && !m["TinyFileCount"].empty()) {
      if (typeid(map<string, boost::any>) == m["TinyFileCount"].type()) {
        ListDoctorHDFSDirectoriesResponseBodyDataMetricsTinyFileCount model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TinyFileCount"]));
        tinyFileCount = make_shared<ListDoctorHDFSDirectoriesResponseBodyDataMetricsTinyFileCount>(model1);
      }
    }
    if (m.find("TinyFileCountDayGrowthRatio") != m.end() && !m["TinyFileCountDayGrowthRatio"].empty()) {
      if (typeid(map<string, boost::any>) == m["TinyFileCountDayGrowthRatio"].type()) {
        ListDoctorHDFSDirectoriesResponseBodyDataMetricsTinyFileCountDayGrowthRatio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TinyFileCountDayGrowthRatio"]));
        tinyFileCountDayGrowthRatio = make_shared<ListDoctorHDFSDirectoriesResponseBodyDataMetricsTinyFileCountDayGrowthRatio>(model1);
      }
    }
    if (m.find("TinyFileDayGrowthCount") != m.end() && !m["TinyFileDayGrowthCount"].empty()) {
      if (typeid(map<string, boost::any>) == m["TinyFileDayGrowthCount"].type()) {
        ListDoctorHDFSDirectoriesResponseBodyDataMetricsTinyFileDayGrowthCount model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TinyFileDayGrowthCount"]));
        tinyFileDayGrowthCount = make_shared<ListDoctorHDFSDirectoriesResponseBodyDataMetricsTinyFileDayGrowthCount>(model1);
      }
    }
    if (m.find("TotalDataDayGrowthSize") != m.end() && !m["TotalDataDayGrowthSize"].empty()) {
      if (typeid(map<string, boost::any>) == m["TotalDataDayGrowthSize"].type()) {
        ListDoctorHDFSDirectoriesResponseBodyDataMetricsTotalDataDayGrowthSize model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TotalDataDayGrowthSize"]));
        totalDataDayGrowthSize = make_shared<ListDoctorHDFSDirectoriesResponseBodyDataMetricsTotalDataDayGrowthSize>(model1);
      }
    }
    if (m.find("TotalDataSize") != m.end() && !m["TotalDataSize"].empty()) {
      if (typeid(map<string, boost::any>) == m["TotalDataSize"].type()) {
        ListDoctorHDFSDirectoriesResponseBodyDataMetricsTotalDataSize model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TotalDataSize"]));
        totalDataSize = make_shared<ListDoctorHDFSDirectoriesResponseBodyDataMetricsTotalDataSize>(model1);
      }
    }
    if (m.find("TotalDataSizeDayGrowthRatio") != m.end() && !m["TotalDataSizeDayGrowthRatio"].empty()) {
      if (typeid(map<string, boost::any>) == m["TotalDataSizeDayGrowthRatio"].type()) {
        ListDoctorHDFSDirectoriesResponseBodyDataMetricsTotalDataSizeDayGrowthRatio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TotalDataSizeDayGrowthRatio"]));
        totalDataSizeDayGrowthRatio = make_shared<ListDoctorHDFSDirectoriesResponseBodyDataMetricsTotalDataSizeDayGrowthRatio>(model1);
      }
    }
    if (m.find("TotalFileCount") != m.end() && !m["TotalFileCount"].empty()) {
      if (typeid(map<string, boost::any>) == m["TotalFileCount"].type()) {
        ListDoctorHDFSDirectoriesResponseBodyDataMetricsTotalFileCount model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TotalFileCount"]));
        totalFileCount = make_shared<ListDoctorHDFSDirectoriesResponseBodyDataMetricsTotalFileCount>(model1);
      }
    }
    if (m.find("TotalFileCountDayGrowthRatio") != m.end() && !m["TotalFileCountDayGrowthRatio"].empty()) {
      if (typeid(map<string, boost::any>) == m["TotalFileCountDayGrowthRatio"].type()) {
        ListDoctorHDFSDirectoriesResponseBodyDataMetricsTotalFileCountDayGrowthRatio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TotalFileCountDayGrowthRatio"]));
        totalFileCountDayGrowthRatio = make_shared<ListDoctorHDFSDirectoriesResponseBodyDataMetricsTotalFileCountDayGrowthRatio>(model1);
      }
    }
    if (m.find("TotalFileDayGrowthCount") != m.end() && !m["TotalFileDayGrowthCount"].empty()) {
      if (typeid(map<string, boost::any>) == m["TotalFileDayGrowthCount"].type()) {
        ListDoctorHDFSDirectoriesResponseBodyDataMetricsTotalFileDayGrowthCount model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TotalFileDayGrowthCount"]));
        totalFileDayGrowthCount = make_shared<ListDoctorHDFSDirectoriesResponseBodyDataMetricsTotalFileDayGrowthCount>(model1);
      }
    }
    if (m.find("WarmDataDayGrowthSize") != m.end() && !m["WarmDataDayGrowthSize"].empty()) {
      if (typeid(map<string, boost::any>) == m["WarmDataDayGrowthSize"].type()) {
        ListDoctorHDFSDirectoriesResponseBodyDataMetricsWarmDataDayGrowthSize model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["WarmDataDayGrowthSize"]));
        warmDataDayGrowthSize = make_shared<ListDoctorHDFSDirectoriesResponseBodyDataMetricsWarmDataDayGrowthSize>(model1);
      }
    }
    if (m.find("WarmDataSize") != m.end() && !m["WarmDataSize"].empty()) {
      if (typeid(map<string, boost::any>) == m["WarmDataSize"].type()) {
        ListDoctorHDFSDirectoriesResponseBodyDataMetricsWarmDataSize model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["WarmDataSize"]));
        warmDataSize = make_shared<ListDoctorHDFSDirectoriesResponseBodyDataMetricsWarmDataSize>(model1);
      }
    }
    if (m.find("WarmDataSizeDayGrowthRatio") != m.end() && !m["WarmDataSizeDayGrowthRatio"].empty()) {
      if (typeid(map<string, boost::any>) == m["WarmDataSizeDayGrowthRatio"].type()) {
        ListDoctorHDFSDirectoriesResponseBodyDataMetricsWarmDataSizeDayGrowthRatio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["WarmDataSizeDayGrowthRatio"]));
        warmDataSizeDayGrowthRatio = make_shared<ListDoctorHDFSDirectoriesResponseBodyDataMetricsWarmDataSizeDayGrowthRatio>(model1);
      }
    }
  }


  virtual ~ListDoctorHDFSDirectoriesResponseBodyDataMetrics() = default;
};
class ListDoctorHDFSDirectoriesResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> depth{};
  shared_ptr<string> dirPath{};
  shared_ptr<string> group{};
  shared_ptr<ListDoctorHDFSDirectoriesResponseBodyDataMetrics> metrics{};
  shared_ptr<string> user{};

  ListDoctorHDFSDirectoriesResponseBodyData() {}

  explicit ListDoctorHDFSDirectoriesResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (depth) {
      res["Depth"] = boost::any(*depth);
    }
    if (dirPath) {
      res["DirPath"] = boost::any(*dirPath);
    }
    if (group) {
      res["Group"] = boost::any(*group);
    }
    if (metrics) {
      res["Metrics"] = metrics ? boost::any(metrics->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (user) {
      res["User"] = boost::any(*user);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Depth") != m.end() && !m["Depth"].empty()) {
      depth = make_shared<long>(boost::any_cast<long>(m["Depth"]));
    }
    if (m.find("DirPath") != m.end() && !m["DirPath"].empty()) {
      dirPath = make_shared<string>(boost::any_cast<string>(m["DirPath"]));
    }
    if (m.find("Group") != m.end() && !m["Group"].empty()) {
      group = make_shared<string>(boost::any_cast<string>(m["Group"]));
    }
    if (m.find("Metrics") != m.end() && !m["Metrics"].empty()) {
      if (typeid(map<string, boost::any>) == m["Metrics"].type()) {
        ListDoctorHDFSDirectoriesResponseBodyDataMetrics model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Metrics"]));
        metrics = make_shared<ListDoctorHDFSDirectoriesResponseBodyDataMetrics>(model1);
      }
    }
    if (m.find("User") != m.end() && !m["User"].empty()) {
      user = make_shared<string>(boost::any_cast<string>(m["User"]));
    }
  }


  virtual ~ListDoctorHDFSDirectoriesResponseBodyData() = default;
};
class ListDoctorHDFSDirectoriesResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListDoctorHDFSDirectoriesResponseBodyData>> data{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ListDoctorHDFSDirectoriesResponseBody() {}

  explicit ListDoctorHDFSDirectoriesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<ListDoctorHDFSDirectoriesResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDoctorHDFSDirectoriesResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListDoctorHDFSDirectoriesResponseBodyData>>(expect1);
      }
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListDoctorHDFSDirectoriesResponseBody() = default;
};
class ListDoctorHDFSDirectoriesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListDoctorHDFSDirectoriesResponseBody> body{};

  ListDoctorHDFSDirectoriesResponse() {}

  explicit ListDoctorHDFSDirectoriesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListDoctorHDFSDirectoriesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListDoctorHDFSDirectoriesResponseBody>(model1);
      }
    }
  }


  virtual ~ListDoctorHDFSDirectoriesResponse() = default;
};
class ListDoctorHDFSUGIRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> dateTime{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> orderBy{};
  shared_ptr<string> orderType{};
  shared_ptr<string> regionId{};
  shared_ptr<string> type{};

  ListDoctorHDFSUGIRequest() {}

  explicit ListDoctorHDFSUGIRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (dateTime) {
      res["DateTime"] = boost::any(*dateTime);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (orderBy) {
      res["OrderBy"] = boost::any(*orderBy);
    }
    if (orderType) {
      res["OrderType"] = boost::any(*orderType);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("DateTime") != m.end() && !m["DateTime"].empty()) {
      dateTime = make_shared<string>(boost::any_cast<string>(m["DateTime"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("OrderBy") != m.end() && !m["OrderBy"].empty()) {
      orderBy = make_shared<string>(boost::any_cast<string>(m["OrderBy"]));
    }
    if (m.find("OrderType") != m.end() && !m["OrderType"].empty()) {
      orderType = make_shared<string>(boost::any_cast<string>(m["OrderType"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListDoctorHDFSUGIRequest() = default;
};
class ListDoctorHDFSUGIResponseBodyDataMetricsTotalDataSize : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  ListDoctorHDFSUGIResponseBodyDataMetricsTotalDataSize() {}

  explicit ListDoctorHDFSUGIResponseBodyDataMetricsTotalDataSize(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~ListDoctorHDFSUGIResponseBodyDataMetricsTotalDataSize() = default;
};
class ListDoctorHDFSUGIResponseBodyDataMetricsTotalDirCount : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  ListDoctorHDFSUGIResponseBodyDataMetricsTotalDirCount() {}

  explicit ListDoctorHDFSUGIResponseBodyDataMetricsTotalDirCount(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~ListDoctorHDFSUGIResponseBodyDataMetricsTotalDirCount() = default;
};
class ListDoctorHDFSUGIResponseBodyDataMetricsTotalFileCount : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  ListDoctorHDFSUGIResponseBodyDataMetricsTotalFileCount() {}

  explicit ListDoctorHDFSUGIResponseBodyDataMetricsTotalFileCount(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~ListDoctorHDFSUGIResponseBodyDataMetricsTotalFileCount() = default;
};
class ListDoctorHDFSUGIResponseBodyDataMetrics : public Darabonba::Model {
public:
  shared_ptr<ListDoctorHDFSUGIResponseBodyDataMetricsTotalDataSize> totalDataSize{};
  shared_ptr<ListDoctorHDFSUGIResponseBodyDataMetricsTotalDirCount> totalDirCount{};
  shared_ptr<ListDoctorHDFSUGIResponseBodyDataMetricsTotalFileCount> totalFileCount{};

  ListDoctorHDFSUGIResponseBodyDataMetrics() {}

  explicit ListDoctorHDFSUGIResponseBodyDataMetrics(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (totalDataSize) {
      res["TotalDataSize"] = totalDataSize ? boost::any(totalDataSize->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (totalDirCount) {
      res["TotalDirCount"] = totalDirCount ? boost::any(totalDirCount->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (totalFileCount) {
      res["TotalFileCount"] = totalFileCount ? boost::any(totalFileCount->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TotalDataSize") != m.end() && !m["TotalDataSize"].empty()) {
      if (typeid(map<string, boost::any>) == m["TotalDataSize"].type()) {
        ListDoctorHDFSUGIResponseBodyDataMetricsTotalDataSize model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TotalDataSize"]));
        totalDataSize = make_shared<ListDoctorHDFSUGIResponseBodyDataMetricsTotalDataSize>(model1);
      }
    }
    if (m.find("TotalDirCount") != m.end() && !m["TotalDirCount"].empty()) {
      if (typeid(map<string, boost::any>) == m["TotalDirCount"].type()) {
        ListDoctorHDFSUGIResponseBodyDataMetricsTotalDirCount model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TotalDirCount"]));
        totalDirCount = make_shared<ListDoctorHDFSUGIResponseBodyDataMetricsTotalDirCount>(model1);
      }
    }
    if (m.find("TotalFileCount") != m.end() && !m["TotalFileCount"].empty()) {
      if (typeid(map<string, boost::any>) == m["TotalFileCount"].type()) {
        ListDoctorHDFSUGIResponseBodyDataMetricsTotalFileCount model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TotalFileCount"]));
        totalFileCount = make_shared<ListDoctorHDFSUGIResponseBodyDataMetricsTotalFileCount>(model1);
      }
    }
  }


  virtual ~ListDoctorHDFSUGIResponseBodyDataMetrics() = default;
};
class ListDoctorHDFSUGIResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<ListDoctorHDFSUGIResponseBodyDataMetrics> metrics{};
  shared_ptr<string> name{};

  ListDoctorHDFSUGIResponseBodyData() {}

  explicit ListDoctorHDFSUGIResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (metrics) {
      res["Metrics"] = metrics ? boost::any(metrics->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Metrics") != m.end() && !m["Metrics"].empty()) {
      if (typeid(map<string, boost::any>) == m["Metrics"].type()) {
        ListDoctorHDFSUGIResponseBodyDataMetrics model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Metrics"]));
        metrics = make_shared<ListDoctorHDFSUGIResponseBodyDataMetrics>(model1);
      }
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~ListDoctorHDFSUGIResponseBodyData() = default;
};
class ListDoctorHDFSUGIResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListDoctorHDFSUGIResponseBodyData>> data{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ListDoctorHDFSUGIResponseBody() {}

  explicit ListDoctorHDFSUGIResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<ListDoctorHDFSUGIResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDoctorHDFSUGIResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListDoctorHDFSUGIResponseBodyData>>(expect1);
      }
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListDoctorHDFSUGIResponseBody() = default;
};
class ListDoctorHDFSUGIResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListDoctorHDFSUGIResponseBody> body{};

  ListDoctorHDFSUGIResponse() {}

  explicit ListDoctorHDFSUGIResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListDoctorHDFSUGIResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListDoctorHDFSUGIResponseBody>(model1);
      }
    }
  }


  virtual ~ListDoctorHDFSUGIResponse() = default;
};
class ListDoctorHiveDatabasesRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<vector<string>> databaseNames{};
  shared_ptr<string> dateTime{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> orderBy{};
  shared_ptr<string> orderType{};
  shared_ptr<string> regionId{};

  ListDoctorHiveDatabasesRequest() {}

  explicit ListDoctorHiveDatabasesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (databaseNames) {
      res["DatabaseNames"] = boost::any(*databaseNames);
    }
    if (dateTime) {
      res["DateTime"] = boost::any(*dateTime);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (orderBy) {
      res["OrderBy"] = boost::any(*orderBy);
    }
    if (orderType) {
      res["OrderType"] = boost::any(*orderType);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("DatabaseNames") != m.end() && !m["DatabaseNames"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DatabaseNames"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DatabaseNames"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      databaseNames = make_shared<vector<string>>(toVec1);
    }
    if (m.find("DateTime") != m.end() && !m["DateTime"].empty()) {
      dateTime = make_shared<string>(boost::any_cast<string>(m["DateTime"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("OrderBy") != m.end() && !m["OrderBy"].empty()) {
      orderBy = make_shared<string>(boost::any_cast<string>(m["OrderBy"]));
    }
    if (m.find("OrderType") != m.end() && !m["OrderType"].empty()) {
      orderType = make_shared<string>(boost::any_cast<string>(m["OrderType"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~ListDoctorHiveDatabasesRequest() = default;
};
class ListDoctorHiveDatabasesResponseBodyDataAnalysis : public Darabonba::Model {
public:
  shared_ptr<long> hiveDistributionScore{};
  shared_ptr<long> hiveFormatScore{};
  shared_ptr<long> hiveFrequencyScore{};
  shared_ptr<long> hiveScore{};

  ListDoctorHiveDatabasesResponseBodyDataAnalysis() {}

  explicit ListDoctorHiveDatabasesResponseBodyDataAnalysis(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hiveDistributionScore) {
      res["HiveDistributionScore"] = boost::any(*hiveDistributionScore);
    }
    if (hiveFormatScore) {
      res["HiveFormatScore"] = boost::any(*hiveFormatScore);
    }
    if (hiveFrequencyScore) {
      res["HiveFrequencyScore"] = boost::any(*hiveFrequencyScore);
    }
    if (hiveScore) {
      res["HiveScore"] = boost::any(*hiveScore);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HiveDistributionScore") != m.end() && !m["HiveDistributionScore"].empty()) {
      hiveDistributionScore = make_shared<long>(boost::any_cast<long>(m["HiveDistributionScore"]));
    }
    if (m.find("HiveFormatScore") != m.end() && !m["HiveFormatScore"].empty()) {
      hiveFormatScore = make_shared<long>(boost::any_cast<long>(m["HiveFormatScore"]));
    }
    if (m.find("HiveFrequencyScore") != m.end() && !m["HiveFrequencyScore"].empty()) {
      hiveFrequencyScore = make_shared<long>(boost::any_cast<long>(m["HiveFrequencyScore"]));
    }
    if (m.find("HiveScore") != m.end() && !m["HiveScore"].empty()) {
      hiveScore = make_shared<long>(boost::any_cast<long>(m["HiveScore"]));
    }
  }


  virtual ~ListDoctorHiveDatabasesResponseBodyDataAnalysis() = default;
};
class ListDoctorHiveDatabasesResponseBodyDataFormats : public Darabonba::Model {
public:
  shared_ptr<long> formatDayGrowthSize{};
  shared_ptr<string> formatName{};
  shared_ptr<double> formatRatio{};
  shared_ptr<long> formatSize{};
  shared_ptr<double> formatSizeDayGrowthRatio{};
  shared_ptr<string> formatSizeUnit{};

  ListDoctorHiveDatabasesResponseBodyDataFormats() {}

  explicit ListDoctorHiveDatabasesResponseBodyDataFormats(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (formatDayGrowthSize) {
      res["FormatDayGrowthSize"] = boost::any(*formatDayGrowthSize);
    }
    if (formatName) {
      res["FormatName"] = boost::any(*formatName);
    }
    if (formatRatio) {
      res["FormatRatio"] = boost::any(*formatRatio);
    }
    if (formatSize) {
      res["FormatSize"] = boost::any(*formatSize);
    }
    if (formatSizeDayGrowthRatio) {
      res["FormatSizeDayGrowthRatio"] = boost::any(*formatSizeDayGrowthRatio);
    }
    if (formatSizeUnit) {
      res["FormatSizeUnit"] = boost::any(*formatSizeUnit);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FormatDayGrowthSize") != m.end() && !m["FormatDayGrowthSize"].empty()) {
      formatDayGrowthSize = make_shared<long>(boost::any_cast<long>(m["FormatDayGrowthSize"]));
    }
    if (m.find("FormatName") != m.end() && !m["FormatName"].empty()) {
      formatName = make_shared<string>(boost::any_cast<string>(m["FormatName"]));
    }
    if (m.find("FormatRatio") != m.end() && !m["FormatRatio"].empty()) {
      formatRatio = make_shared<double>(boost::any_cast<double>(m["FormatRatio"]));
    }
    if (m.find("FormatSize") != m.end() && !m["FormatSize"].empty()) {
      formatSize = make_shared<long>(boost::any_cast<long>(m["FormatSize"]));
    }
    if (m.find("FormatSizeDayGrowthRatio") != m.end() && !m["FormatSizeDayGrowthRatio"].empty()) {
      formatSizeDayGrowthRatio = make_shared<double>(boost::any_cast<double>(m["FormatSizeDayGrowthRatio"]));
    }
    if (m.find("FormatSizeUnit") != m.end() && !m["FormatSizeUnit"].empty()) {
      formatSizeUnit = make_shared<string>(boost::any_cast<string>(m["FormatSizeUnit"]));
    }
  }


  virtual ~ListDoctorHiveDatabasesResponseBodyDataFormats() = default;
};
class ListDoctorHiveDatabasesResponseBodyDataMetricsColdDataDayGrowthSize : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  ListDoctorHiveDatabasesResponseBodyDataMetricsColdDataDayGrowthSize() {}

  explicit ListDoctorHiveDatabasesResponseBodyDataMetricsColdDataDayGrowthSize(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~ListDoctorHiveDatabasesResponseBodyDataMetricsColdDataDayGrowthSize() = default;
};
class ListDoctorHiveDatabasesResponseBodyDataMetricsColdDataRatio : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  ListDoctorHiveDatabasesResponseBodyDataMetricsColdDataRatio() {}

  explicit ListDoctorHiveDatabasesResponseBodyDataMetricsColdDataRatio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~ListDoctorHiveDatabasesResponseBodyDataMetricsColdDataRatio() = default;
};
class ListDoctorHiveDatabasesResponseBodyDataMetricsColdDataSize : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  ListDoctorHiveDatabasesResponseBodyDataMetricsColdDataSize() {}

  explicit ListDoctorHiveDatabasesResponseBodyDataMetricsColdDataSize(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~ListDoctorHiveDatabasesResponseBodyDataMetricsColdDataSize() = default;
};
class ListDoctorHiveDatabasesResponseBodyDataMetricsColdDataSizeDayGrowthRatio : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  ListDoctorHiveDatabasesResponseBodyDataMetricsColdDataSizeDayGrowthRatio() {}

  explicit ListDoctorHiveDatabasesResponseBodyDataMetricsColdDataSizeDayGrowthRatio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~ListDoctorHiveDatabasesResponseBodyDataMetricsColdDataSizeDayGrowthRatio() = default;
};
class ListDoctorHiveDatabasesResponseBodyDataMetricsEmptyFileCount : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  ListDoctorHiveDatabasesResponseBodyDataMetricsEmptyFileCount() {}

  explicit ListDoctorHiveDatabasesResponseBodyDataMetricsEmptyFileCount(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~ListDoctorHiveDatabasesResponseBodyDataMetricsEmptyFileCount() = default;
};
class ListDoctorHiveDatabasesResponseBodyDataMetricsEmptyFileCountDayGrowthRatio : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  ListDoctorHiveDatabasesResponseBodyDataMetricsEmptyFileCountDayGrowthRatio() {}

  explicit ListDoctorHiveDatabasesResponseBodyDataMetricsEmptyFileCountDayGrowthRatio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~ListDoctorHiveDatabasesResponseBodyDataMetricsEmptyFileCountDayGrowthRatio() = default;
};
class ListDoctorHiveDatabasesResponseBodyDataMetricsEmptyFileDayGrowthCount : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  ListDoctorHiveDatabasesResponseBodyDataMetricsEmptyFileDayGrowthCount() {}

  explicit ListDoctorHiveDatabasesResponseBodyDataMetricsEmptyFileDayGrowthCount(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~ListDoctorHiveDatabasesResponseBodyDataMetricsEmptyFileDayGrowthCount() = default;
};
class ListDoctorHiveDatabasesResponseBodyDataMetricsEmptyFileRatio : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  ListDoctorHiveDatabasesResponseBodyDataMetricsEmptyFileRatio() {}

  explicit ListDoctorHiveDatabasesResponseBodyDataMetricsEmptyFileRatio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~ListDoctorHiveDatabasesResponseBodyDataMetricsEmptyFileRatio() = default;
};
class ListDoctorHiveDatabasesResponseBodyDataMetricsFreezeDataDayGrowthSize : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  ListDoctorHiveDatabasesResponseBodyDataMetricsFreezeDataDayGrowthSize() {}

  explicit ListDoctorHiveDatabasesResponseBodyDataMetricsFreezeDataDayGrowthSize(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~ListDoctorHiveDatabasesResponseBodyDataMetricsFreezeDataDayGrowthSize() = default;
};
class ListDoctorHiveDatabasesResponseBodyDataMetricsFreezeDataRatio : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  ListDoctorHiveDatabasesResponseBodyDataMetricsFreezeDataRatio() {}

  explicit ListDoctorHiveDatabasesResponseBodyDataMetricsFreezeDataRatio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~ListDoctorHiveDatabasesResponseBodyDataMetricsFreezeDataRatio() = default;
};
class ListDoctorHiveDatabasesResponseBodyDataMetricsFreezeDataSize : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  ListDoctorHiveDatabasesResponseBodyDataMetricsFreezeDataSize() {}

  explicit ListDoctorHiveDatabasesResponseBodyDataMetricsFreezeDataSize(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~ListDoctorHiveDatabasesResponseBodyDataMetricsFreezeDataSize() = default;
};
class ListDoctorHiveDatabasesResponseBodyDataMetricsFreezeDataSizeDayGrowthRatio : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  ListDoctorHiveDatabasesResponseBodyDataMetricsFreezeDataSizeDayGrowthRatio() {}

  explicit ListDoctorHiveDatabasesResponseBodyDataMetricsFreezeDataSizeDayGrowthRatio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~ListDoctorHiveDatabasesResponseBodyDataMetricsFreezeDataSizeDayGrowthRatio() = default;
};
class ListDoctorHiveDatabasesResponseBodyDataMetricsHotDataDayGrowthSize : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  ListDoctorHiveDatabasesResponseBodyDataMetricsHotDataDayGrowthSize() {}

  explicit ListDoctorHiveDatabasesResponseBodyDataMetricsHotDataDayGrowthSize(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~ListDoctorHiveDatabasesResponseBodyDataMetricsHotDataDayGrowthSize() = default;
};
class ListDoctorHiveDatabasesResponseBodyDataMetricsHotDataRatio : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  ListDoctorHiveDatabasesResponseBodyDataMetricsHotDataRatio() {}

  explicit ListDoctorHiveDatabasesResponseBodyDataMetricsHotDataRatio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~ListDoctorHiveDatabasesResponseBodyDataMetricsHotDataRatio() = default;
};
class ListDoctorHiveDatabasesResponseBodyDataMetricsHotDataSize : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  ListDoctorHiveDatabasesResponseBodyDataMetricsHotDataSize() {}

  explicit ListDoctorHiveDatabasesResponseBodyDataMetricsHotDataSize(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~ListDoctorHiveDatabasesResponseBodyDataMetricsHotDataSize() = default;
};
class ListDoctorHiveDatabasesResponseBodyDataMetricsHotDataSizeDayGrowthRatio : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  ListDoctorHiveDatabasesResponseBodyDataMetricsHotDataSizeDayGrowthRatio() {}

  explicit ListDoctorHiveDatabasesResponseBodyDataMetricsHotDataSizeDayGrowthRatio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~ListDoctorHiveDatabasesResponseBodyDataMetricsHotDataSizeDayGrowthRatio() = default;
};
class ListDoctorHiveDatabasesResponseBodyDataMetricsLargeFileCount : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  ListDoctorHiveDatabasesResponseBodyDataMetricsLargeFileCount() {}

  explicit ListDoctorHiveDatabasesResponseBodyDataMetricsLargeFileCount(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~ListDoctorHiveDatabasesResponseBodyDataMetricsLargeFileCount() = default;
};
class ListDoctorHiveDatabasesResponseBodyDataMetricsLargeFileCountDayGrowthRatio : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  ListDoctorHiveDatabasesResponseBodyDataMetricsLargeFileCountDayGrowthRatio() {}

  explicit ListDoctorHiveDatabasesResponseBodyDataMetricsLargeFileCountDayGrowthRatio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~ListDoctorHiveDatabasesResponseBodyDataMetricsLargeFileCountDayGrowthRatio() = default;
};
class ListDoctorHiveDatabasesResponseBodyDataMetricsLargeFileDayGrowthCount : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  ListDoctorHiveDatabasesResponseBodyDataMetricsLargeFileDayGrowthCount() {}

  explicit ListDoctorHiveDatabasesResponseBodyDataMetricsLargeFileDayGrowthCount(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~ListDoctorHiveDatabasesResponseBodyDataMetricsLargeFileDayGrowthCount() = default;
};
class ListDoctorHiveDatabasesResponseBodyDataMetricsLargeFileRatio : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  ListDoctorHiveDatabasesResponseBodyDataMetricsLargeFileRatio() {}

  explicit ListDoctorHiveDatabasesResponseBodyDataMetricsLargeFileRatio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~ListDoctorHiveDatabasesResponseBodyDataMetricsLargeFileRatio() = default;
};
class ListDoctorHiveDatabasesResponseBodyDataMetricsMediumFileCount : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  ListDoctorHiveDatabasesResponseBodyDataMetricsMediumFileCount() {}

  explicit ListDoctorHiveDatabasesResponseBodyDataMetricsMediumFileCount(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~ListDoctorHiveDatabasesResponseBodyDataMetricsMediumFileCount() = default;
};
class ListDoctorHiveDatabasesResponseBodyDataMetricsMediumFileCountDayGrowthRatio : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  ListDoctorHiveDatabasesResponseBodyDataMetricsMediumFileCountDayGrowthRatio() {}

  explicit ListDoctorHiveDatabasesResponseBodyDataMetricsMediumFileCountDayGrowthRatio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~ListDoctorHiveDatabasesResponseBodyDataMetricsMediumFileCountDayGrowthRatio() = default;
};
class ListDoctorHiveDatabasesResponseBodyDataMetricsMediumFileDayGrowthCount : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  ListDoctorHiveDatabasesResponseBodyDataMetricsMediumFileDayGrowthCount() {}

  explicit ListDoctorHiveDatabasesResponseBodyDataMetricsMediumFileDayGrowthCount(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~ListDoctorHiveDatabasesResponseBodyDataMetricsMediumFileDayGrowthCount() = default;
};
class ListDoctorHiveDatabasesResponseBodyDataMetricsMediumFileRatio : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  ListDoctorHiveDatabasesResponseBodyDataMetricsMediumFileRatio() {}

  explicit ListDoctorHiveDatabasesResponseBodyDataMetricsMediumFileRatio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~ListDoctorHiveDatabasesResponseBodyDataMetricsMediumFileRatio() = default;
};
class ListDoctorHiveDatabasesResponseBodyDataMetricsPartitionNum : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  ListDoctorHiveDatabasesResponseBodyDataMetricsPartitionNum() {}

  explicit ListDoctorHiveDatabasesResponseBodyDataMetricsPartitionNum(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~ListDoctorHiveDatabasesResponseBodyDataMetricsPartitionNum() = default;
};
class ListDoctorHiveDatabasesResponseBodyDataMetricsSmallFileCount : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  ListDoctorHiveDatabasesResponseBodyDataMetricsSmallFileCount() {}

  explicit ListDoctorHiveDatabasesResponseBodyDataMetricsSmallFileCount(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~ListDoctorHiveDatabasesResponseBodyDataMetricsSmallFileCount() = default;
};
class ListDoctorHiveDatabasesResponseBodyDataMetricsSmallFileCountDayGrowthRatio : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  ListDoctorHiveDatabasesResponseBodyDataMetricsSmallFileCountDayGrowthRatio() {}

  explicit ListDoctorHiveDatabasesResponseBodyDataMetricsSmallFileCountDayGrowthRatio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~ListDoctorHiveDatabasesResponseBodyDataMetricsSmallFileCountDayGrowthRatio() = default;
};
class ListDoctorHiveDatabasesResponseBodyDataMetricsSmallFileDayGrowthCount : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  ListDoctorHiveDatabasesResponseBodyDataMetricsSmallFileDayGrowthCount() {}

  explicit ListDoctorHiveDatabasesResponseBodyDataMetricsSmallFileDayGrowthCount(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~ListDoctorHiveDatabasesResponseBodyDataMetricsSmallFileDayGrowthCount() = default;
};
class ListDoctorHiveDatabasesResponseBodyDataMetricsSmallFileRatio : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  ListDoctorHiveDatabasesResponseBodyDataMetricsSmallFileRatio() {}

  explicit ListDoctorHiveDatabasesResponseBodyDataMetricsSmallFileRatio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~ListDoctorHiveDatabasesResponseBodyDataMetricsSmallFileRatio() = default;
};
class ListDoctorHiveDatabasesResponseBodyDataMetricsTableCount : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  ListDoctorHiveDatabasesResponseBodyDataMetricsTableCount() {}

  explicit ListDoctorHiveDatabasesResponseBodyDataMetricsTableCount(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~ListDoctorHiveDatabasesResponseBodyDataMetricsTableCount() = default;
};
class ListDoctorHiveDatabasesResponseBodyDataMetricsTinyFileCount : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  ListDoctorHiveDatabasesResponseBodyDataMetricsTinyFileCount() {}

  explicit ListDoctorHiveDatabasesResponseBodyDataMetricsTinyFileCount(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~ListDoctorHiveDatabasesResponseBodyDataMetricsTinyFileCount() = default;
};
class ListDoctorHiveDatabasesResponseBodyDataMetricsTinyFileCountDayGrowthRatio : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  ListDoctorHiveDatabasesResponseBodyDataMetricsTinyFileCountDayGrowthRatio() {}

  explicit ListDoctorHiveDatabasesResponseBodyDataMetricsTinyFileCountDayGrowthRatio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~ListDoctorHiveDatabasesResponseBodyDataMetricsTinyFileCountDayGrowthRatio() = default;
};
class ListDoctorHiveDatabasesResponseBodyDataMetricsTinyFileDayGrowthCount : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  ListDoctorHiveDatabasesResponseBodyDataMetricsTinyFileDayGrowthCount() {}

  explicit ListDoctorHiveDatabasesResponseBodyDataMetricsTinyFileDayGrowthCount(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~ListDoctorHiveDatabasesResponseBodyDataMetricsTinyFileDayGrowthCount() = default;
};
class ListDoctorHiveDatabasesResponseBodyDataMetricsTinyFileRatio : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  ListDoctorHiveDatabasesResponseBodyDataMetricsTinyFileRatio() {}

  explicit ListDoctorHiveDatabasesResponseBodyDataMetricsTinyFileRatio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~ListDoctorHiveDatabasesResponseBodyDataMetricsTinyFileRatio() = default;
};
class ListDoctorHiveDatabasesResponseBodyDataMetricsTotalDataDayGrowthSize : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  ListDoctorHiveDatabasesResponseBodyDataMetricsTotalDataDayGrowthSize() {}

  explicit ListDoctorHiveDatabasesResponseBodyDataMetricsTotalDataDayGrowthSize(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~ListDoctorHiveDatabasesResponseBodyDataMetricsTotalDataDayGrowthSize() = default;
};
class ListDoctorHiveDatabasesResponseBodyDataMetricsTotalDataSize : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  ListDoctorHiveDatabasesResponseBodyDataMetricsTotalDataSize() {}

  explicit ListDoctorHiveDatabasesResponseBodyDataMetricsTotalDataSize(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~ListDoctorHiveDatabasesResponseBodyDataMetricsTotalDataSize() = default;
};
class ListDoctorHiveDatabasesResponseBodyDataMetricsTotalDataSizeDayGrowthRatio : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  ListDoctorHiveDatabasesResponseBodyDataMetricsTotalDataSizeDayGrowthRatio() {}

  explicit ListDoctorHiveDatabasesResponseBodyDataMetricsTotalDataSizeDayGrowthRatio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~ListDoctorHiveDatabasesResponseBodyDataMetricsTotalDataSizeDayGrowthRatio() = default;
};
class ListDoctorHiveDatabasesResponseBodyDataMetricsTotalFileCount : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  ListDoctorHiveDatabasesResponseBodyDataMetricsTotalFileCount() {}

  explicit ListDoctorHiveDatabasesResponseBodyDataMetricsTotalFileCount(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~ListDoctorHiveDatabasesResponseBodyDataMetricsTotalFileCount() = default;
};
class ListDoctorHiveDatabasesResponseBodyDataMetricsTotalFileCountDayGrowthRatio : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  ListDoctorHiveDatabasesResponseBodyDataMetricsTotalFileCountDayGrowthRatio() {}

  explicit ListDoctorHiveDatabasesResponseBodyDataMetricsTotalFileCountDayGrowthRatio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~ListDoctorHiveDatabasesResponseBodyDataMetricsTotalFileCountDayGrowthRatio() = default;
};
class ListDoctorHiveDatabasesResponseBodyDataMetricsTotalFileDayGrowthCount : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  ListDoctorHiveDatabasesResponseBodyDataMetricsTotalFileDayGrowthCount() {}

  explicit ListDoctorHiveDatabasesResponseBodyDataMetricsTotalFileDayGrowthCount(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~ListDoctorHiveDatabasesResponseBodyDataMetricsTotalFileDayGrowthCount() = default;
};
class ListDoctorHiveDatabasesResponseBodyDataMetricsWarmDataDayGrowthSize : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  ListDoctorHiveDatabasesResponseBodyDataMetricsWarmDataDayGrowthSize() {}

  explicit ListDoctorHiveDatabasesResponseBodyDataMetricsWarmDataDayGrowthSize(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~ListDoctorHiveDatabasesResponseBodyDataMetricsWarmDataDayGrowthSize() = default;
};
class ListDoctorHiveDatabasesResponseBodyDataMetricsWarmDataRatio : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  ListDoctorHiveDatabasesResponseBodyDataMetricsWarmDataRatio() {}

  explicit ListDoctorHiveDatabasesResponseBodyDataMetricsWarmDataRatio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~ListDoctorHiveDatabasesResponseBodyDataMetricsWarmDataRatio() = default;
};
class ListDoctorHiveDatabasesResponseBodyDataMetricsWarmDataSize : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  ListDoctorHiveDatabasesResponseBodyDataMetricsWarmDataSize() {}

  explicit ListDoctorHiveDatabasesResponseBodyDataMetricsWarmDataSize(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~ListDoctorHiveDatabasesResponseBodyDataMetricsWarmDataSize() = default;
};
class ListDoctorHiveDatabasesResponseBodyDataMetricsWarmDataSizeDayGrowthRatio : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  ListDoctorHiveDatabasesResponseBodyDataMetricsWarmDataSizeDayGrowthRatio() {}

  explicit ListDoctorHiveDatabasesResponseBodyDataMetricsWarmDataSizeDayGrowthRatio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~ListDoctorHiveDatabasesResponseBodyDataMetricsWarmDataSizeDayGrowthRatio() = default;
};
class ListDoctorHiveDatabasesResponseBodyDataMetrics : public Darabonba::Model {
public:
  shared_ptr<ListDoctorHiveDatabasesResponseBodyDataMetricsColdDataDayGrowthSize> coldDataDayGrowthSize{};
  shared_ptr<ListDoctorHiveDatabasesResponseBodyDataMetricsColdDataRatio> coldDataRatio{};
  shared_ptr<ListDoctorHiveDatabasesResponseBodyDataMetricsColdDataSize> coldDataSize{};
  shared_ptr<ListDoctorHiveDatabasesResponseBodyDataMetricsColdDataSizeDayGrowthRatio> coldDataSizeDayGrowthRatio{};
  shared_ptr<ListDoctorHiveDatabasesResponseBodyDataMetricsEmptyFileCount> emptyFileCount{};
  shared_ptr<ListDoctorHiveDatabasesResponseBodyDataMetricsEmptyFileCountDayGrowthRatio> emptyFileCountDayGrowthRatio{};
  shared_ptr<ListDoctorHiveDatabasesResponseBodyDataMetricsEmptyFileDayGrowthCount> emptyFileDayGrowthCount{};
  shared_ptr<ListDoctorHiveDatabasesResponseBodyDataMetricsEmptyFileRatio> emptyFileRatio{};
  shared_ptr<ListDoctorHiveDatabasesResponseBodyDataMetricsFreezeDataDayGrowthSize> freezeDataDayGrowthSize{};
  shared_ptr<ListDoctorHiveDatabasesResponseBodyDataMetricsFreezeDataRatio> freezeDataRatio{};
  shared_ptr<ListDoctorHiveDatabasesResponseBodyDataMetricsFreezeDataSize> freezeDataSize{};
  shared_ptr<ListDoctorHiveDatabasesResponseBodyDataMetricsFreezeDataSizeDayGrowthRatio> freezeDataSizeDayGrowthRatio{};
  shared_ptr<ListDoctorHiveDatabasesResponseBodyDataMetricsHotDataDayGrowthSize> hotDataDayGrowthSize{};
  shared_ptr<ListDoctorHiveDatabasesResponseBodyDataMetricsHotDataRatio> hotDataRatio{};
  shared_ptr<ListDoctorHiveDatabasesResponseBodyDataMetricsHotDataSize> hotDataSize{};
  shared_ptr<ListDoctorHiveDatabasesResponseBodyDataMetricsHotDataSizeDayGrowthRatio> hotDataSizeDayGrowthRatio{};
  shared_ptr<ListDoctorHiveDatabasesResponseBodyDataMetricsLargeFileCount> largeFileCount{};
  shared_ptr<ListDoctorHiveDatabasesResponseBodyDataMetricsLargeFileCountDayGrowthRatio> largeFileCountDayGrowthRatio{};
  shared_ptr<ListDoctorHiveDatabasesResponseBodyDataMetricsLargeFileDayGrowthCount> largeFileDayGrowthCount{};
  shared_ptr<ListDoctorHiveDatabasesResponseBodyDataMetricsLargeFileRatio> largeFileRatio{};
  shared_ptr<ListDoctorHiveDatabasesResponseBodyDataMetricsMediumFileCount> mediumFileCount{};
  shared_ptr<ListDoctorHiveDatabasesResponseBodyDataMetricsMediumFileCountDayGrowthRatio> mediumFileCountDayGrowthRatio{};
  shared_ptr<ListDoctorHiveDatabasesResponseBodyDataMetricsMediumFileDayGrowthCount> mediumFileDayGrowthCount{};
  shared_ptr<ListDoctorHiveDatabasesResponseBodyDataMetricsMediumFileRatio> mediumFileRatio{};
  shared_ptr<ListDoctorHiveDatabasesResponseBodyDataMetricsPartitionNum> partitionNum{};
  shared_ptr<ListDoctorHiveDatabasesResponseBodyDataMetricsSmallFileCount> smallFileCount{};
  shared_ptr<ListDoctorHiveDatabasesResponseBodyDataMetricsSmallFileCountDayGrowthRatio> smallFileCountDayGrowthRatio{};
  shared_ptr<ListDoctorHiveDatabasesResponseBodyDataMetricsSmallFileDayGrowthCount> smallFileDayGrowthCount{};
  shared_ptr<ListDoctorHiveDatabasesResponseBodyDataMetricsSmallFileRatio> smallFileRatio{};
  shared_ptr<ListDoctorHiveDatabasesResponseBodyDataMetricsTableCount> tableCount{};
  shared_ptr<ListDoctorHiveDatabasesResponseBodyDataMetricsTinyFileCount> tinyFileCount{};
  shared_ptr<ListDoctorHiveDatabasesResponseBodyDataMetricsTinyFileCountDayGrowthRatio> tinyFileCountDayGrowthRatio{};
  shared_ptr<ListDoctorHiveDatabasesResponseBodyDataMetricsTinyFileDayGrowthCount> tinyFileDayGrowthCount{};
  shared_ptr<ListDoctorHiveDatabasesResponseBodyDataMetricsTinyFileRatio> tinyFileRatio{};
  shared_ptr<ListDoctorHiveDatabasesResponseBodyDataMetricsTotalDataDayGrowthSize> totalDataDayGrowthSize{};
  shared_ptr<ListDoctorHiveDatabasesResponseBodyDataMetricsTotalDataSize> totalDataSize{};
  shared_ptr<ListDoctorHiveDatabasesResponseBodyDataMetricsTotalDataSizeDayGrowthRatio> totalDataSizeDayGrowthRatio{};
  shared_ptr<ListDoctorHiveDatabasesResponseBodyDataMetricsTotalFileCount> totalFileCount{};
  shared_ptr<ListDoctorHiveDatabasesResponseBodyDataMetricsTotalFileCountDayGrowthRatio> totalFileCountDayGrowthRatio{};
  shared_ptr<ListDoctorHiveDatabasesResponseBodyDataMetricsTotalFileDayGrowthCount> totalFileDayGrowthCount{};
  shared_ptr<ListDoctorHiveDatabasesResponseBodyDataMetricsWarmDataDayGrowthSize> warmDataDayGrowthSize{};
  shared_ptr<ListDoctorHiveDatabasesResponseBodyDataMetricsWarmDataRatio> warmDataRatio{};
  shared_ptr<ListDoctorHiveDatabasesResponseBodyDataMetricsWarmDataSize> warmDataSize{};
  shared_ptr<ListDoctorHiveDatabasesResponseBodyDataMetricsWarmDataSizeDayGrowthRatio> warmDataSizeDayGrowthRatio{};

  ListDoctorHiveDatabasesResponseBodyDataMetrics() {}

  explicit ListDoctorHiveDatabasesResponseBodyDataMetrics(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (coldDataDayGrowthSize) {
      res["ColdDataDayGrowthSize"] = coldDataDayGrowthSize ? boost::any(coldDataDayGrowthSize->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (coldDataRatio) {
      res["ColdDataRatio"] = coldDataRatio ? boost::any(coldDataRatio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (coldDataSize) {
      res["ColdDataSize"] = coldDataSize ? boost::any(coldDataSize->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (coldDataSizeDayGrowthRatio) {
      res["ColdDataSizeDayGrowthRatio"] = coldDataSizeDayGrowthRatio ? boost::any(coldDataSizeDayGrowthRatio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (emptyFileCount) {
      res["EmptyFileCount"] = emptyFileCount ? boost::any(emptyFileCount->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (emptyFileCountDayGrowthRatio) {
      res["EmptyFileCountDayGrowthRatio"] = emptyFileCountDayGrowthRatio ? boost::any(emptyFileCountDayGrowthRatio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (emptyFileDayGrowthCount) {
      res["EmptyFileDayGrowthCount"] = emptyFileDayGrowthCount ? boost::any(emptyFileDayGrowthCount->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (emptyFileRatio) {
      res["EmptyFileRatio"] = emptyFileRatio ? boost::any(emptyFileRatio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (freezeDataDayGrowthSize) {
      res["FreezeDataDayGrowthSize"] = freezeDataDayGrowthSize ? boost::any(freezeDataDayGrowthSize->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (freezeDataRatio) {
      res["FreezeDataRatio"] = freezeDataRatio ? boost::any(freezeDataRatio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (freezeDataSize) {
      res["FreezeDataSize"] = freezeDataSize ? boost::any(freezeDataSize->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (freezeDataSizeDayGrowthRatio) {
      res["FreezeDataSizeDayGrowthRatio"] = freezeDataSizeDayGrowthRatio ? boost::any(freezeDataSizeDayGrowthRatio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (hotDataDayGrowthSize) {
      res["HotDataDayGrowthSize"] = hotDataDayGrowthSize ? boost::any(hotDataDayGrowthSize->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (hotDataRatio) {
      res["HotDataRatio"] = hotDataRatio ? boost::any(hotDataRatio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (hotDataSize) {
      res["HotDataSize"] = hotDataSize ? boost::any(hotDataSize->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (hotDataSizeDayGrowthRatio) {
      res["HotDataSizeDayGrowthRatio"] = hotDataSizeDayGrowthRatio ? boost::any(hotDataSizeDayGrowthRatio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (largeFileCount) {
      res["LargeFileCount"] = largeFileCount ? boost::any(largeFileCount->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (largeFileCountDayGrowthRatio) {
      res["LargeFileCountDayGrowthRatio"] = largeFileCountDayGrowthRatio ? boost::any(largeFileCountDayGrowthRatio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (largeFileDayGrowthCount) {
      res["LargeFileDayGrowthCount"] = largeFileDayGrowthCount ? boost::any(largeFileDayGrowthCount->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (largeFileRatio) {
      res["LargeFileRatio"] = largeFileRatio ? boost::any(largeFileRatio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (mediumFileCount) {
      res["MediumFileCount"] = mediumFileCount ? boost::any(mediumFileCount->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (mediumFileCountDayGrowthRatio) {
      res["MediumFileCountDayGrowthRatio"] = mediumFileCountDayGrowthRatio ? boost::any(mediumFileCountDayGrowthRatio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (mediumFileDayGrowthCount) {
      res["MediumFileDayGrowthCount"] = mediumFileDayGrowthCount ? boost::any(mediumFileDayGrowthCount->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (mediumFileRatio) {
      res["MediumFileRatio"] = mediumFileRatio ? boost::any(mediumFileRatio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (partitionNum) {
      res["PartitionNum"] = partitionNum ? boost::any(partitionNum->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (smallFileCount) {
      res["SmallFileCount"] = smallFileCount ? boost::any(smallFileCount->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (smallFileCountDayGrowthRatio) {
      res["SmallFileCountDayGrowthRatio"] = smallFileCountDayGrowthRatio ? boost::any(smallFileCountDayGrowthRatio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (smallFileDayGrowthCount) {
      res["SmallFileDayGrowthCount"] = smallFileDayGrowthCount ? boost::any(smallFileDayGrowthCount->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (smallFileRatio) {
      res["SmallFileRatio"] = smallFileRatio ? boost::any(smallFileRatio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tableCount) {
      res["TableCount"] = tableCount ? boost::any(tableCount->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tinyFileCount) {
      res["TinyFileCount"] = tinyFileCount ? boost::any(tinyFileCount->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tinyFileCountDayGrowthRatio) {
      res["TinyFileCountDayGrowthRatio"] = tinyFileCountDayGrowthRatio ? boost::any(tinyFileCountDayGrowthRatio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tinyFileDayGrowthCount) {
      res["TinyFileDayGrowthCount"] = tinyFileDayGrowthCount ? boost::any(tinyFileDayGrowthCount->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tinyFileRatio) {
      res["TinyFileRatio"] = tinyFileRatio ? boost::any(tinyFileRatio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (totalDataDayGrowthSize) {
      res["TotalDataDayGrowthSize"] = totalDataDayGrowthSize ? boost::any(totalDataDayGrowthSize->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (totalDataSize) {
      res["TotalDataSize"] = totalDataSize ? boost::any(totalDataSize->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (totalDataSizeDayGrowthRatio) {
      res["TotalDataSizeDayGrowthRatio"] = totalDataSizeDayGrowthRatio ? boost::any(totalDataSizeDayGrowthRatio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (totalFileCount) {
      res["TotalFileCount"] = totalFileCount ? boost::any(totalFileCount->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (totalFileCountDayGrowthRatio) {
      res["TotalFileCountDayGrowthRatio"] = totalFileCountDayGrowthRatio ? boost::any(totalFileCountDayGrowthRatio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (totalFileDayGrowthCount) {
      res["TotalFileDayGrowthCount"] = totalFileDayGrowthCount ? boost::any(totalFileDayGrowthCount->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (warmDataDayGrowthSize) {
      res["WarmDataDayGrowthSize"] = warmDataDayGrowthSize ? boost::any(warmDataDayGrowthSize->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (warmDataRatio) {
      res["WarmDataRatio"] = warmDataRatio ? boost::any(warmDataRatio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (warmDataSize) {
      res["WarmDataSize"] = warmDataSize ? boost::any(warmDataSize->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (warmDataSizeDayGrowthRatio) {
      res["WarmDataSizeDayGrowthRatio"] = warmDataSizeDayGrowthRatio ? boost::any(warmDataSizeDayGrowthRatio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ColdDataDayGrowthSize") != m.end() && !m["ColdDataDayGrowthSize"].empty()) {
      if (typeid(map<string, boost::any>) == m["ColdDataDayGrowthSize"].type()) {
        ListDoctorHiveDatabasesResponseBodyDataMetricsColdDataDayGrowthSize model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ColdDataDayGrowthSize"]));
        coldDataDayGrowthSize = make_shared<ListDoctorHiveDatabasesResponseBodyDataMetricsColdDataDayGrowthSize>(model1);
      }
    }
    if (m.find("ColdDataRatio") != m.end() && !m["ColdDataRatio"].empty()) {
      if (typeid(map<string, boost::any>) == m["ColdDataRatio"].type()) {
        ListDoctorHiveDatabasesResponseBodyDataMetricsColdDataRatio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ColdDataRatio"]));
        coldDataRatio = make_shared<ListDoctorHiveDatabasesResponseBodyDataMetricsColdDataRatio>(model1);
      }
    }
    if (m.find("ColdDataSize") != m.end() && !m["ColdDataSize"].empty()) {
      if (typeid(map<string, boost::any>) == m["ColdDataSize"].type()) {
        ListDoctorHiveDatabasesResponseBodyDataMetricsColdDataSize model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ColdDataSize"]));
        coldDataSize = make_shared<ListDoctorHiveDatabasesResponseBodyDataMetricsColdDataSize>(model1);
      }
    }
    if (m.find("ColdDataSizeDayGrowthRatio") != m.end() && !m["ColdDataSizeDayGrowthRatio"].empty()) {
      if (typeid(map<string, boost::any>) == m["ColdDataSizeDayGrowthRatio"].type()) {
        ListDoctorHiveDatabasesResponseBodyDataMetricsColdDataSizeDayGrowthRatio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ColdDataSizeDayGrowthRatio"]));
        coldDataSizeDayGrowthRatio = make_shared<ListDoctorHiveDatabasesResponseBodyDataMetricsColdDataSizeDayGrowthRatio>(model1);
      }
    }
    if (m.find("EmptyFileCount") != m.end() && !m["EmptyFileCount"].empty()) {
      if (typeid(map<string, boost::any>) == m["EmptyFileCount"].type()) {
        ListDoctorHiveDatabasesResponseBodyDataMetricsEmptyFileCount model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EmptyFileCount"]));
        emptyFileCount = make_shared<ListDoctorHiveDatabasesResponseBodyDataMetricsEmptyFileCount>(model1);
      }
    }
    if (m.find("EmptyFileCountDayGrowthRatio") != m.end() && !m["EmptyFileCountDayGrowthRatio"].empty()) {
      if (typeid(map<string, boost::any>) == m["EmptyFileCountDayGrowthRatio"].type()) {
        ListDoctorHiveDatabasesResponseBodyDataMetricsEmptyFileCountDayGrowthRatio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EmptyFileCountDayGrowthRatio"]));
        emptyFileCountDayGrowthRatio = make_shared<ListDoctorHiveDatabasesResponseBodyDataMetricsEmptyFileCountDayGrowthRatio>(model1);
      }
    }
    if (m.find("EmptyFileDayGrowthCount") != m.end() && !m["EmptyFileDayGrowthCount"].empty()) {
      if (typeid(map<string, boost::any>) == m["EmptyFileDayGrowthCount"].type()) {
        ListDoctorHiveDatabasesResponseBodyDataMetricsEmptyFileDayGrowthCount model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EmptyFileDayGrowthCount"]));
        emptyFileDayGrowthCount = make_shared<ListDoctorHiveDatabasesResponseBodyDataMetricsEmptyFileDayGrowthCount>(model1);
      }
    }
    if (m.find("EmptyFileRatio") != m.end() && !m["EmptyFileRatio"].empty()) {
      if (typeid(map<string, boost::any>) == m["EmptyFileRatio"].type()) {
        ListDoctorHiveDatabasesResponseBodyDataMetricsEmptyFileRatio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EmptyFileRatio"]));
        emptyFileRatio = make_shared<ListDoctorHiveDatabasesResponseBodyDataMetricsEmptyFileRatio>(model1);
      }
    }
    if (m.find("FreezeDataDayGrowthSize") != m.end() && !m["FreezeDataDayGrowthSize"].empty()) {
      if (typeid(map<string, boost::any>) == m["FreezeDataDayGrowthSize"].type()) {
        ListDoctorHiveDatabasesResponseBodyDataMetricsFreezeDataDayGrowthSize model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FreezeDataDayGrowthSize"]));
        freezeDataDayGrowthSize = make_shared<ListDoctorHiveDatabasesResponseBodyDataMetricsFreezeDataDayGrowthSize>(model1);
      }
    }
    if (m.find("FreezeDataRatio") != m.end() && !m["FreezeDataRatio"].empty()) {
      if (typeid(map<string, boost::any>) == m["FreezeDataRatio"].type()) {
        ListDoctorHiveDatabasesResponseBodyDataMetricsFreezeDataRatio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FreezeDataRatio"]));
        freezeDataRatio = make_shared<ListDoctorHiveDatabasesResponseBodyDataMetricsFreezeDataRatio>(model1);
      }
    }
    if (m.find("FreezeDataSize") != m.end() && !m["FreezeDataSize"].empty()) {
      if (typeid(map<string, boost::any>) == m["FreezeDataSize"].type()) {
        ListDoctorHiveDatabasesResponseBodyDataMetricsFreezeDataSize model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FreezeDataSize"]));
        freezeDataSize = make_shared<ListDoctorHiveDatabasesResponseBodyDataMetricsFreezeDataSize>(model1);
      }
    }
    if (m.find("FreezeDataSizeDayGrowthRatio") != m.end() && !m["FreezeDataSizeDayGrowthRatio"].empty()) {
      if (typeid(map<string, boost::any>) == m["FreezeDataSizeDayGrowthRatio"].type()) {
        ListDoctorHiveDatabasesResponseBodyDataMetricsFreezeDataSizeDayGrowthRatio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FreezeDataSizeDayGrowthRatio"]));
        freezeDataSizeDayGrowthRatio = make_shared<ListDoctorHiveDatabasesResponseBodyDataMetricsFreezeDataSizeDayGrowthRatio>(model1);
      }
    }
    if (m.find("HotDataDayGrowthSize") != m.end() && !m["HotDataDayGrowthSize"].empty()) {
      if (typeid(map<string, boost::any>) == m["HotDataDayGrowthSize"].type()) {
        ListDoctorHiveDatabasesResponseBodyDataMetricsHotDataDayGrowthSize model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["HotDataDayGrowthSize"]));
        hotDataDayGrowthSize = make_shared<ListDoctorHiveDatabasesResponseBodyDataMetricsHotDataDayGrowthSize>(model1);
      }
    }
    if (m.find("HotDataRatio") != m.end() && !m["HotDataRatio"].empty()) {
      if (typeid(map<string, boost::any>) == m["HotDataRatio"].type()) {
        ListDoctorHiveDatabasesResponseBodyDataMetricsHotDataRatio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["HotDataRatio"]));
        hotDataRatio = make_shared<ListDoctorHiveDatabasesResponseBodyDataMetricsHotDataRatio>(model1);
      }
    }
    if (m.find("HotDataSize") != m.end() && !m["HotDataSize"].empty()) {
      if (typeid(map<string, boost::any>) == m["HotDataSize"].type()) {
        ListDoctorHiveDatabasesResponseBodyDataMetricsHotDataSize model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["HotDataSize"]));
        hotDataSize = make_shared<ListDoctorHiveDatabasesResponseBodyDataMetricsHotDataSize>(model1);
      }
    }
    if (m.find("HotDataSizeDayGrowthRatio") != m.end() && !m["HotDataSizeDayGrowthRatio"].empty()) {
      if (typeid(map<string, boost::any>) == m["HotDataSizeDayGrowthRatio"].type()) {
        ListDoctorHiveDatabasesResponseBodyDataMetricsHotDataSizeDayGrowthRatio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["HotDataSizeDayGrowthRatio"]));
        hotDataSizeDayGrowthRatio = make_shared<ListDoctorHiveDatabasesResponseBodyDataMetricsHotDataSizeDayGrowthRatio>(model1);
      }
    }
    if (m.find("LargeFileCount") != m.end() && !m["LargeFileCount"].empty()) {
      if (typeid(map<string, boost::any>) == m["LargeFileCount"].type()) {
        ListDoctorHiveDatabasesResponseBodyDataMetricsLargeFileCount model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LargeFileCount"]));
        largeFileCount = make_shared<ListDoctorHiveDatabasesResponseBodyDataMetricsLargeFileCount>(model1);
      }
    }
    if (m.find("LargeFileCountDayGrowthRatio") != m.end() && !m["LargeFileCountDayGrowthRatio"].empty()) {
      if (typeid(map<string, boost::any>) == m["LargeFileCountDayGrowthRatio"].type()) {
        ListDoctorHiveDatabasesResponseBodyDataMetricsLargeFileCountDayGrowthRatio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LargeFileCountDayGrowthRatio"]));
        largeFileCountDayGrowthRatio = make_shared<ListDoctorHiveDatabasesResponseBodyDataMetricsLargeFileCountDayGrowthRatio>(model1);
      }
    }
    if (m.find("LargeFileDayGrowthCount") != m.end() && !m["LargeFileDayGrowthCount"].empty()) {
      if (typeid(map<string, boost::any>) == m["LargeFileDayGrowthCount"].type()) {
        ListDoctorHiveDatabasesResponseBodyDataMetricsLargeFileDayGrowthCount model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LargeFileDayGrowthCount"]));
        largeFileDayGrowthCount = make_shared<ListDoctorHiveDatabasesResponseBodyDataMetricsLargeFileDayGrowthCount>(model1);
      }
    }
    if (m.find("LargeFileRatio") != m.end() && !m["LargeFileRatio"].empty()) {
      if (typeid(map<string, boost::any>) == m["LargeFileRatio"].type()) {
        ListDoctorHiveDatabasesResponseBodyDataMetricsLargeFileRatio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LargeFileRatio"]));
        largeFileRatio = make_shared<ListDoctorHiveDatabasesResponseBodyDataMetricsLargeFileRatio>(model1);
      }
    }
    if (m.find("MediumFileCount") != m.end() && !m["MediumFileCount"].empty()) {
      if (typeid(map<string, boost::any>) == m["MediumFileCount"].type()) {
        ListDoctorHiveDatabasesResponseBodyDataMetricsMediumFileCount model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MediumFileCount"]));
        mediumFileCount = make_shared<ListDoctorHiveDatabasesResponseBodyDataMetricsMediumFileCount>(model1);
      }
    }
    if (m.find("MediumFileCountDayGrowthRatio") != m.end() && !m["MediumFileCountDayGrowthRatio"].empty()) {
      if (typeid(map<string, boost::any>) == m["MediumFileCountDayGrowthRatio"].type()) {
        ListDoctorHiveDatabasesResponseBodyDataMetricsMediumFileCountDayGrowthRatio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MediumFileCountDayGrowthRatio"]));
        mediumFileCountDayGrowthRatio = make_shared<ListDoctorHiveDatabasesResponseBodyDataMetricsMediumFileCountDayGrowthRatio>(model1);
      }
    }
    if (m.find("MediumFileDayGrowthCount") != m.end() && !m["MediumFileDayGrowthCount"].empty()) {
      if (typeid(map<string, boost::any>) == m["MediumFileDayGrowthCount"].type()) {
        ListDoctorHiveDatabasesResponseBodyDataMetricsMediumFileDayGrowthCount model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MediumFileDayGrowthCount"]));
        mediumFileDayGrowthCount = make_shared<ListDoctorHiveDatabasesResponseBodyDataMetricsMediumFileDayGrowthCount>(model1);
      }
    }
    if (m.find("MediumFileRatio") != m.end() && !m["MediumFileRatio"].empty()) {
      if (typeid(map<string, boost::any>) == m["MediumFileRatio"].type()) {
        ListDoctorHiveDatabasesResponseBodyDataMetricsMediumFileRatio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MediumFileRatio"]));
        mediumFileRatio = make_shared<ListDoctorHiveDatabasesResponseBodyDataMetricsMediumFileRatio>(model1);
      }
    }
    if (m.find("PartitionNum") != m.end() && !m["PartitionNum"].empty()) {
      if (typeid(map<string, boost::any>) == m["PartitionNum"].type()) {
        ListDoctorHiveDatabasesResponseBodyDataMetricsPartitionNum model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PartitionNum"]));
        partitionNum = make_shared<ListDoctorHiveDatabasesResponseBodyDataMetricsPartitionNum>(model1);
      }
    }
    if (m.find("SmallFileCount") != m.end() && !m["SmallFileCount"].empty()) {
      if (typeid(map<string, boost::any>) == m["SmallFileCount"].type()) {
        ListDoctorHiveDatabasesResponseBodyDataMetricsSmallFileCount model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SmallFileCount"]));
        smallFileCount = make_shared<ListDoctorHiveDatabasesResponseBodyDataMetricsSmallFileCount>(model1);
      }
    }
    if (m.find("SmallFileCountDayGrowthRatio") != m.end() && !m["SmallFileCountDayGrowthRatio"].empty()) {
      if (typeid(map<string, boost::any>) == m["SmallFileCountDayGrowthRatio"].type()) {
        ListDoctorHiveDatabasesResponseBodyDataMetricsSmallFileCountDayGrowthRatio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SmallFileCountDayGrowthRatio"]));
        smallFileCountDayGrowthRatio = make_shared<ListDoctorHiveDatabasesResponseBodyDataMetricsSmallFileCountDayGrowthRatio>(model1);
      }
    }
    if (m.find("SmallFileDayGrowthCount") != m.end() && !m["SmallFileDayGrowthCount"].empty()) {
      if (typeid(map<string, boost::any>) == m["SmallFileDayGrowthCount"].type()) {
        ListDoctorHiveDatabasesResponseBodyDataMetricsSmallFileDayGrowthCount model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SmallFileDayGrowthCount"]));
        smallFileDayGrowthCount = make_shared<ListDoctorHiveDatabasesResponseBodyDataMetricsSmallFileDayGrowthCount>(model1);
      }
    }
    if (m.find("SmallFileRatio") != m.end() && !m["SmallFileRatio"].empty()) {
      if (typeid(map<string, boost::any>) == m["SmallFileRatio"].type()) {
        ListDoctorHiveDatabasesResponseBodyDataMetricsSmallFileRatio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SmallFileRatio"]));
        smallFileRatio = make_shared<ListDoctorHiveDatabasesResponseBodyDataMetricsSmallFileRatio>(model1);
      }
    }
    if (m.find("TableCount") != m.end() && !m["TableCount"].empty()) {
      if (typeid(map<string, boost::any>) == m["TableCount"].type()) {
        ListDoctorHiveDatabasesResponseBodyDataMetricsTableCount model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TableCount"]));
        tableCount = make_shared<ListDoctorHiveDatabasesResponseBodyDataMetricsTableCount>(model1);
      }
    }
    if (m.find("TinyFileCount") != m.end() && !m["TinyFileCount"].empty()) {
      if (typeid(map<string, boost::any>) == m["TinyFileCount"].type()) {
        ListDoctorHiveDatabasesResponseBodyDataMetricsTinyFileCount model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TinyFileCount"]));
        tinyFileCount = make_shared<ListDoctorHiveDatabasesResponseBodyDataMetricsTinyFileCount>(model1);
      }
    }
    if (m.find("TinyFileCountDayGrowthRatio") != m.end() && !m["TinyFileCountDayGrowthRatio"].empty()) {
      if (typeid(map<string, boost::any>) == m["TinyFileCountDayGrowthRatio"].type()) {
        ListDoctorHiveDatabasesResponseBodyDataMetricsTinyFileCountDayGrowthRatio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TinyFileCountDayGrowthRatio"]));
        tinyFileCountDayGrowthRatio = make_shared<ListDoctorHiveDatabasesResponseBodyDataMetricsTinyFileCountDayGrowthRatio>(model1);
      }
    }
    if (m.find("TinyFileDayGrowthCount") != m.end() && !m["TinyFileDayGrowthCount"].empty()) {
      if (typeid(map<string, boost::any>) == m["TinyFileDayGrowthCount"].type()) {
        ListDoctorHiveDatabasesResponseBodyDataMetricsTinyFileDayGrowthCount model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TinyFileDayGrowthCount"]));
        tinyFileDayGrowthCount = make_shared<ListDoctorHiveDatabasesResponseBodyDataMetricsTinyFileDayGrowthCount>(model1);
      }
    }
    if (m.find("TinyFileRatio") != m.end() && !m["TinyFileRatio"].empty()) {
      if (typeid(map<string, boost::any>) == m["TinyFileRatio"].type()) {
        ListDoctorHiveDatabasesResponseBodyDataMetricsTinyFileRatio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TinyFileRatio"]));
        tinyFileRatio = make_shared<ListDoctorHiveDatabasesResponseBodyDataMetricsTinyFileRatio>(model1);
      }
    }
    if (m.find("TotalDataDayGrowthSize") != m.end() && !m["TotalDataDayGrowthSize"].empty()) {
      if (typeid(map<string, boost::any>) == m["TotalDataDayGrowthSize"].type()) {
        ListDoctorHiveDatabasesResponseBodyDataMetricsTotalDataDayGrowthSize model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TotalDataDayGrowthSize"]));
        totalDataDayGrowthSize = make_shared<ListDoctorHiveDatabasesResponseBodyDataMetricsTotalDataDayGrowthSize>(model1);
      }
    }
    if (m.find("TotalDataSize") != m.end() && !m["TotalDataSize"].empty()) {
      if (typeid(map<string, boost::any>) == m["TotalDataSize"].type()) {
        ListDoctorHiveDatabasesResponseBodyDataMetricsTotalDataSize model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TotalDataSize"]));
        totalDataSize = make_shared<ListDoctorHiveDatabasesResponseBodyDataMetricsTotalDataSize>(model1);
      }
    }
    if (m.find("TotalDataSizeDayGrowthRatio") != m.end() && !m["TotalDataSizeDayGrowthRatio"].empty()) {
      if (typeid(map<string, boost::any>) == m["TotalDataSizeDayGrowthRatio"].type()) {
        ListDoctorHiveDatabasesResponseBodyDataMetricsTotalDataSizeDayGrowthRatio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TotalDataSizeDayGrowthRatio"]));
        totalDataSizeDayGrowthRatio = make_shared<ListDoctorHiveDatabasesResponseBodyDataMetricsTotalDataSizeDayGrowthRatio>(model1);
      }
    }
    if (m.find("TotalFileCount") != m.end() && !m["TotalFileCount"].empty()) {
      if (typeid(map<string, boost::any>) == m["TotalFileCount"].type()) {
        ListDoctorHiveDatabasesResponseBodyDataMetricsTotalFileCount model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TotalFileCount"]));
        totalFileCount = make_shared<ListDoctorHiveDatabasesResponseBodyDataMetricsTotalFileCount>(model1);
      }
    }
    if (m.find("TotalFileCountDayGrowthRatio") != m.end() && !m["TotalFileCountDayGrowthRatio"].empty()) {
      if (typeid(map<string, boost::any>) == m["TotalFileCountDayGrowthRatio"].type()) {
        ListDoctorHiveDatabasesResponseBodyDataMetricsTotalFileCountDayGrowthRatio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TotalFileCountDayGrowthRatio"]));
        totalFileCountDayGrowthRatio = make_shared<ListDoctorHiveDatabasesResponseBodyDataMetricsTotalFileCountDayGrowthRatio>(model1);
      }
    }
    if (m.find("TotalFileDayGrowthCount") != m.end() && !m["TotalFileDayGrowthCount"].empty()) {
      if (typeid(map<string, boost::any>) == m["TotalFileDayGrowthCount"].type()) {
        ListDoctorHiveDatabasesResponseBodyDataMetricsTotalFileDayGrowthCount model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TotalFileDayGrowthCount"]));
        totalFileDayGrowthCount = make_shared<ListDoctorHiveDatabasesResponseBodyDataMetricsTotalFileDayGrowthCount>(model1);
      }
    }
    if (m.find("WarmDataDayGrowthSize") != m.end() && !m["WarmDataDayGrowthSize"].empty()) {
      if (typeid(map<string, boost::any>) == m["WarmDataDayGrowthSize"].type()) {
        ListDoctorHiveDatabasesResponseBodyDataMetricsWarmDataDayGrowthSize model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["WarmDataDayGrowthSize"]));
        warmDataDayGrowthSize = make_shared<ListDoctorHiveDatabasesResponseBodyDataMetricsWarmDataDayGrowthSize>(model1);
      }
    }
    if (m.find("WarmDataRatio") != m.end() && !m["WarmDataRatio"].empty()) {
      if (typeid(map<string, boost::any>) == m["WarmDataRatio"].type()) {
        ListDoctorHiveDatabasesResponseBodyDataMetricsWarmDataRatio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["WarmDataRatio"]));
        warmDataRatio = make_shared<ListDoctorHiveDatabasesResponseBodyDataMetricsWarmDataRatio>(model1);
      }
    }
    if (m.find("WarmDataSize") != m.end() && !m["WarmDataSize"].empty()) {
      if (typeid(map<string, boost::any>) == m["WarmDataSize"].type()) {
        ListDoctorHiveDatabasesResponseBodyDataMetricsWarmDataSize model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["WarmDataSize"]));
        warmDataSize = make_shared<ListDoctorHiveDatabasesResponseBodyDataMetricsWarmDataSize>(model1);
      }
    }
    if (m.find("WarmDataSizeDayGrowthRatio") != m.end() && !m["WarmDataSizeDayGrowthRatio"].empty()) {
      if (typeid(map<string, boost::any>) == m["WarmDataSizeDayGrowthRatio"].type()) {
        ListDoctorHiveDatabasesResponseBodyDataMetricsWarmDataSizeDayGrowthRatio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["WarmDataSizeDayGrowthRatio"]));
        warmDataSizeDayGrowthRatio = make_shared<ListDoctorHiveDatabasesResponseBodyDataMetricsWarmDataSizeDayGrowthRatio>(model1);
      }
    }
  }


  virtual ~ListDoctorHiveDatabasesResponseBodyDataMetrics() = default;
};
class ListDoctorHiveDatabasesResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<ListDoctorHiveDatabasesResponseBodyDataAnalysis> analysis{};
  shared_ptr<string> databaseName{};
  shared_ptr<vector<ListDoctorHiveDatabasesResponseBodyDataFormats>> formats{};
  shared_ptr<ListDoctorHiveDatabasesResponseBodyDataMetrics> metrics{};

  ListDoctorHiveDatabasesResponseBodyData() {}

  explicit ListDoctorHiveDatabasesResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (analysis) {
      res["Analysis"] = analysis ? boost::any(analysis->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (databaseName) {
      res["DatabaseName"] = boost::any(*databaseName);
    }
    if (formats) {
      vector<boost::any> temp1;
      for(auto item1:*formats){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Formats"] = boost::any(temp1);
    }
    if (metrics) {
      res["Metrics"] = metrics ? boost::any(metrics->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Analysis") != m.end() && !m["Analysis"].empty()) {
      if (typeid(map<string, boost::any>) == m["Analysis"].type()) {
        ListDoctorHiveDatabasesResponseBodyDataAnalysis model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Analysis"]));
        analysis = make_shared<ListDoctorHiveDatabasesResponseBodyDataAnalysis>(model1);
      }
    }
    if (m.find("DatabaseName") != m.end() && !m["DatabaseName"].empty()) {
      databaseName = make_shared<string>(boost::any_cast<string>(m["DatabaseName"]));
    }
    if (m.find("Formats") != m.end() && !m["Formats"].empty()) {
      if (typeid(vector<boost::any>) == m["Formats"].type()) {
        vector<ListDoctorHiveDatabasesResponseBodyDataFormats> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Formats"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDoctorHiveDatabasesResponseBodyDataFormats model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        formats = make_shared<vector<ListDoctorHiveDatabasesResponseBodyDataFormats>>(expect1);
      }
    }
    if (m.find("Metrics") != m.end() && !m["Metrics"].empty()) {
      if (typeid(map<string, boost::any>) == m["Metrics"].type()) {
        ListDoctorHiveDatabasesResponseBodyDataMetrics model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Metrics"]));
        metrics = make_shared<ListDoctorHiveDatabasesResponseBodyDataMetrics>(model1);
      }
    }
  }


  virtual ~ListDoctorHiveDatabasesResponseBodyData() = default;
};
class ListDoctorHiveDatabasesResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListDoctorHiveDatabasesResponseBodyData>> data{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ListDoctorHiveDatabasesResponseBody() {}

  explicit ListDoctorHiveDatabasesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<ListDoctorHiveDatabasesResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDoctorHiveDatabasesResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListDoctorHiveDatabasesResponseBodyData>>(expect1);
      }
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListDoctorHiveDatabasesResponseBody() = default;
};
class ListDoctorHiveDatabasesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListDoctorHiveDatabasesResponseBody> body{};

  ListDoctorHiveDatabasesResponse() {}

  explicit ListDoctorHiveDatabasesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListDoctorHiveDatabasesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListDoctorHiveDatabasesResponseBody>(model1);
      }
    }
  }


  virtual ~ListDoctorHiveDatabasesResponse() = default;
};
class ListDoctorHiveTablesRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> dateTime{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> orderBy{};
  shared_ptr<string> orderType{};
  shared_ptr<string> regionId{};
  shared_ptr<vector<string>> tableNames{};

  ListDoctorHiveTablesRequest() {}

  explicit ListDoctorHiveTablesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (dateTime) {
      res["DateTime"] = boost::any(*dateTime);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (orderBy) {
      res["OrderBy"] = boost::any(*orderBy);
    }
    if (orderType) {
      res["OrderType"] = boost::any(*orderType);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (tableNames) {
      res["TableNames"] = boost::any(*tableNames);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("DateTime") != m.end() && !m["DateTime"].empty()) {
      dateTime = make_shared<string>(boost::any_cast<string>(m["DateTime"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("OrderBy") != m.end() && !m["OrderBy"].empty()) {
      orderBy = make_shared<string>(boost::any_cast<string>(m["OrderBy"]));
    }
    if (m.find("OrderType") != m.end() && !m["OrderType"].empty()) {
      orderType = make_shared<string>(boost::any_cast<string>(m["OrderType"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("TableNames") != m.end() && !m["TableNames"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["TableNames"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["TableNames"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      tableNames = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListDoctorHiveTablesRequest() = default;
};
class ListDoctorHiveTablesResponseBodyDataAnalysis : public Darabonba::Model {
public:
  shared_ptr<long> hiveDistributionScore{};
  shared_ptr<long> hiveFormatScore{};
  shared_ptr<long> hiveFrequencyScore{};
  shared_ptr<long> hiveScore{};

  ListDoctorHiveTablesResponseBodyDataAnalysis() {}

  explicit ListDoctorHiveTablesResponseBodyDataAnalysis(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hiveDistributionScore) {
      res["HiveDistributionScore"] = boost::any(*hiveDistributionScore);
    }
    if (hiveFormatScore) {
      res["HiveFormatScore"] = boost::any(*hiveFormatScore);
    }
    if (hiveFrequencyScore) {
      res["HiveFrequencyScore"] = boost::any(*hiveFrequencyScore);
    }
    if (hiveScore) {
      res["HiveScore"] = boost::any(*hiveScore);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HiveDistributionScore") != m.end() && !m["HiveDistributionScore"].empty()) {
      hiveDistributionScore = make_shared<long>(boost::any_cast<long>(m["HiveDistributionScore"]));
    }
    if (m.find("HiveFormatScore") != m.end() && !m["HiveFormatScore"].empty()) {
      hiveFormatScore = make_shared<long>(boost::any_cast<long>(m["HiveFormatScore"]));
    }
    if (m.find("HiveFrequencyScore") != m.end() && !m["HiveFrequencyScore"].empty()) {
      hiveFrequencyScore = make_shared<long>(boost::any_cast<long>(m["HiveFrequencyScore"]));
    }
    if (m.find("HiveScore") != m.end() && !m["HiveScore"].empty()) {
      hiveScore = make_shared<long>(boost::any_cast<long>(m["HiveScore"]));
    }
  }


  virtual ~ListDoctorHiveTablesResponseBodyDataAnalysis() = default;
};
class ListDoctorHiveTablesResponseBodyDataFormats : public Darabonba::Model {
public:
  shared_ptr<long> formatDayGrowthSize{};
  shared_ptr<string> formatName{};
  shared_ptr<double> formatRatio{};
  shared_ptr<long> formatSize{};
  shared_ptr<double> formatSizeDayGrowthRatio{};
  shared_ptr<string> formatSizeUnit{};

  ListDoctorHiveTablesResponseBodyDataFormats() {}

  explicit ListDoctorHiveTablesResponseBodyDataFormats(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (formatDayGrowthSize) {
      res["FormatDayGrowthSize"] = boost::any(*formatDayGrowthSize);
    }
    if (formatName) {
      res["FormatName"] = boost::any(*formatName);
    }
    if (formatRatio) {
      res["FormatRatio"] = boost::any(*formatRatio);
    }
    if (formatSize) {
      res["FormatSize"] = boost::any(*formatSize);
    }
    if (formatSizeDayGrowthRatio) {
      res["FormatSizeDayGrowthRatio"] = boost::any(*formatSizeDayGrowthRatio);
    }
    if (formatSizeUnit) {
      res["FormatSizeUnit"] = boost::any(*formatSizeUnit);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FormatDayGrowthSize") != m.end() && !m["FormatDayGrowthSize"].empty()) {
      formatDayGrowthSize = make_shared<long>(boost::any_cast<long>(m["FormatDayGrowthSize"]));
    }
    if (m.find("FormatName") != m.end() && !m["FormatName"].empty()) {
      formatName = make_shared<string>(boost::any_cast<string>(m["FormatName"]));
    }
    if (m.find("FormatRatio") != m.end() && !m["FormatRatio"].empty()) {
      formatRatio = make_shared<double>(boost::any_cast<double>(m["FormatRatio"]));
    }
    if (m.find("FormatSize") != m.end() && !m["FormatSize"].empty()) {
      formatSize = make_shared<long>(boost::any_cast<long>(m["FormatSize"]));
    }
    if (m.find("FormatSizeDayGrowthRatio") != m.end() && !m["FormatSizeDayGrowthRatio"].empty()) {
      formatSizeDayGrowthRatio = make_shared<double>(boost::any_cast<double>(m["FormatSizeDayGrowthRatio"]));
    }
    if (m.find("FormatSizeUnit") != m.end() && !m["FormatSizeUnit"].empty()) {
      formatSizeUnit = make_shared<string>(boost::any_cast<string>(m["FormatSizeUnit"]));
    }
  }


  virtual ~ListDoctorHiveTablesResponseBodyDataFormats() = default;
};
class ListDoctorHiveTablesResponseBodyDataMetricsColdDataDayGrowthSize : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  ListDoctorHiveTablesResponseBodyDataMetricsColdDataDayGrowthSize() {}

  explicit ListDoctorHiveTablesResponseBodyDataMetricsColdDataDayGrowthSize(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~ListDoctorHiveTablesResponseBodyDataMetricsColdDataDayGrowthSize() = default;
};
class ListDoctorHiveTablesResponseBodyDataMetricsColdDataRatio : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  ListDoctorHiveTablesResponseBodyDataMetricsColdDataRatio() {}

  explicit ListDoctorHiveTablesResponseBodyDataMetricsColdDataRatio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~ListDoctorHiveTablesResponseBodyDataMetricsColdDataRatio() = default;
};
class ListDoctorHiveTablesResponseBodyDataMetricsColdDataSize : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  ListDoctorHiveTablesResponseBodyDataMetricsColdDataSize() {}

  explicit ListDoctorHiveTablesResponseBodyDataMetricsColdDataSize(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~ListDoctorHiveTablesResponseBodyDataMetricsColdDataSize() = default;
};
class ListDoctorHiveTablesResponseBodyDataMetricsColdDataSizeDayGrowthRatio : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  ListDoctorHiveTablesResponseBodyDataMetricsColdDataSizeDayGrowthRatio() {}

  explicit ListDoctorHiveTablesResponseBodyDataMetricsColdDataSizeDayGrowthRatio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~ListDoctorHiveTablesResponseBodyDataMetricsColdDataSizeDayGrowthRatio() = default;
};
class ListDoctorHiveTablesResponseBodyDataMetricsEmptyFileCount : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  ListDoctorHiveTablesResponseBodyDataMetricsEmptyFileCount() {}

  explicit ListDoctorHiveTablesResponseBodyDataMetricsEmptyFileCount(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~ListDoctorHiveTablesResponseBodyDataMetricsEmptyFileCount() = default;
};
class ListDoctorHiveTablesResponseBodyDataMetricsEmptyFileCountDayGrowthRatio : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  ListDoctorHiveTablesResponseBodyDataMetricsEmptyFileCountDayGrowthRatio() {}

  explicit ListDoctorHiveTablesResponseBodyDataMetricsEmptyFileCountDayGrowthRatio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~ListDoctorHiveTablesResponseBodyDataMetricsEmptyFileCountDayGrowthRatio() = default;
};
class ListDoctorHiveTablesResponseBodyDataMetricsEmptyFileDayGrowthCount : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  ListDoctorHiveTablesResponseBodyDataMetricsEmptyFileDayGrowthCount() {}

  explicit ListDoctorHiveTablesResponseBodyDataMetricsEmptyFileDayGrowthCount(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~ListDoctorHiveTablesResponseBodyDataMetricsEmptyFileDayGrowthCount() = default;
};
class ListDoctorHiveTablesResponseBodyDataMetricsEmptyFileRatio : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  ListDoctorHiveTablesResponseBodyDataMetricsEmptyFileRatio() {}

  explicit ListDoctorHiveTablesResponseBodyDataMetricsEmptyFileRatio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~ListDoctorHiveTablesResponseBodyDataMetricsEmptyFileRatio() = default;
};
class ListDoctorHiveTablesResponseBodyDataMetricsFreezeDataDayGrowthSize : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  ListDoctorHiveTablesResponseBodyDataMetricsFreezeDataDayGrowthSize() {}

  explicit ListDoctorHiveTablesResponseBodyDataMetricsFreezeDataDayGrowthSize(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~ListDoctorHiveTablesResponseBodyDataMetricsFreezeDataDayGrowthSize() = default;
};
class ListDoctorHiveTablesResponseBodyDataMetricsFreezeDataRatio : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  ListDoctorHiveTablesResponseBodyDataMetricsFreezeDataRatio() {}

  explicit ListDoctorHiveTablesResponseBodyDataMetricsFreezeDataRatio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~ListDoctorHiveTablesResponseBodyDataMetricsFreezeDataRatio() = default;
};
class ListDoctorHiveTablesResponseBodyDataMetricsFreezeDataSize : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  ListDoctorHiveTablesResponseBodyDataMetricsFreezeDataSize() {}

  explicit ListDoctorHiveTablesResponseBodyDataMetricsFreezeDataSize(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~ListDoctorHiveTablesResponseBodyDataMetricsFreezeDataSize() = default;
};
class ListDoctorHiveTablesResponseBodyDataMetricsFreezeDataSizeDayGrowthRatio : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  ListDoctorHiveTablesResponseBodyDataMetricsFreezeDataSizeDayGrowthRatio() {}

  explicit ListDoctorHiveTablesResponseBodyDataMetricsFreezeDataSizeDayGrowthRatio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~ListDoctorHiveTablesResponseBodyDataMetricsFreezeDataSizeDayGrowthRatio() = default;
};
class ListDoctorHiveTablesResponseBodyDataMetricsHotDataDayGrowthSize : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  ListDoctorHiveTablesResponseBodyDataMetricsHotDataDayGrowthSize() {}

  explicit ListDoctorHiveTablesResponseBodyDataMetricsHotDataDayGrowthSize(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~ListDoctorHiveTablesResponseBodyDataMetricsHotDataDayGrowthSize() = default;
};
class ListDoctorHiveTablesResponseBodyDataMetricsHotDataRatio : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  ListDoctorHiveTablesResponseBodyDataMetricsHotDataRatio() {}

  explicit ListDoctorHiveTablesResponseBodyDataMetricsHotDataRatio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~ListDoctorHiveTablesResponseBodyDataMetricsHotDataRatio() = default;
};
class ListDoctorHiveTablesResponseBodyDataMetricsHotDataSize : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  ListDoctorHiveTablesResponseBodyDataMetricsHotDataSize() {}

  explicit ListDoctorHiveTablesResponseBodyDataMetricsHotDataSize(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~ListDoctorHiveTablesResponseBodyDataMetricsHotDataSize() = default;
};
class ListDoctorHiveTablesResponseBodyDataMetricsHotDataSizeDayGrowthRatio : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  ListDoctorHiveTablesResponseBodyDataMetricsHotDataSizeDayGrowthRatio() {}

  explicit ListDoctorHiveTablesResponseBodyDataMetricsHotDataSizeDayGrowthRatio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~ListDoctorHiveTablesResponseBodyDataMetricsHotDataSizeDayGrowthRatio() = default;
};
class ListDoctorHiveTablesResponseBodyDataMetricsLargeFileCount : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  ListDoctorHiveTablesResponseBodyDataMetricsLargeFileCount() {}

  explicit ListDoctorHiveTablesResponseBodyDataMetricsLargeFileCount(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~ListDoctorHiveTablesResponseBodyDataMetricsLargeFileCount() = default;
};
class ListDoctorHiveTablesResponseBodyDataMetricsLargeFileCountDayGrowthRatio : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  ListDoctorHiveTablesResponseBodyDataMetricsLargeFileCountDayGrowthRatio() {}

  explicit ListDoctorHiveTablesResponseBodyDataMetricsLargeFileCountDayGrowthRatio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~ListDoctorHiveTablesResponseBodyDataMetricsLargeFileCountDayGrowthRatio() = default;
};
class ListDoctorHiveTablesResponseBodyDataMetricsLargeFileDayGrowthCount : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  ListDoctorHiveTablesResponseBodyDataMetricsLargeFileDayGrowthCount() {}

  explicit ListDoctorHiveTablesResponseBodyDataMetricsLargeFileDayGrowthCount(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~ListDoctorHiveTablesResponseBodyDataMetricsLargeFileDayGrowthCount() = default;
};
class ListDoctorHiveTablesResponseBodyDataMetricsLargeFileRatio : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  ListDoctorHiveTablesResponseBodyDataMetricsLargeFileRatio() {}

  explicit ListDoctorHiveTablesResponseBodyDataMetricsLargeFileRatio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~ListDoctorHiveTablesResponseBodyDataMetricsLargeFileRatio() = default;
};
class ListDoctorHiveTablesResponseBodyDataMetricsMediumFileCount : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  ListDoctorHiveTablesResponseBodyDataMetricsMediumFileCount() {}

  explicit ListDoctorHiveTablesResponseBodyDataMetricsMediumFileCount(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~ListDoctorHiveTablesResponseBodyDataMetricsMediumFileCount() = default;
};
class ListDoctorHiveTablesResponseBodyDataMetricsMediumFileCountDayGrowthRatio : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  ListDoctorHiveTablesResponseBodyDataMetricsMediumFileCountDayGrowthRatio() {}

  explicit ListDoctorHiveTablesResponseBodyDataMetricsMediumFileCountDayGrowthRatio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~ListDoctorHiveTablesResponseBodyDataMetricsMediumFileCountDayGrowthRatio() = default;
};
class ListDoctorHiveTablesResponseBodyDataMetricsMediumFileDayGrowthCount : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  ListDoctorHiveTablesResponseBodyDataMetricsMediumFileDayGrowthCount() {}

  explicit ListDoctorHiveTablesResponseBodyDataMetricsMediumFileDayGrowthCount(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~ListDoctorHiveTablesResponseBodyDataMetricsMediumFileDayGrowthCount() = default;
};
class ListDoctorHiveTablesResponseBodyDataMetricsMediumFileRatio : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  ListDoctorHiveTablesResponseBodyDataMetricsMediumFileRatio() {}

  explicit ListDoctorHiveTablesResponseBodyDataMetricsMediumFileRatio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~ListDoctorHiveTablesResponseBodyDataMetricsMediumFileRatio() = default;
};
class ListDoctorHiveTablesResponseBodyDataMetricsPartitionNum : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  ListDoctorHiveTablesResponseBodyDataMetricsPartitionNum() {}

  explicit ListDoctorHiveTablesResponseBodyDataMetricsPartitionNum(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~ListDoctorHiveTablesResponseBodyDataMetricsPartitionNum() = default;
};
class ListDoctorHiveTablesResponseBodyDataMetricsSmallFileCount : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  ListDoctorHiveTablesResponseBodyDataMetricsSmallFileCount() {}

  explicit ListDoctorHiveTablesResponseBodyDataMetricsSmallFileCount(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~ListDoctorHiveTablesResponseBodyDataMetricsSmallFileCount() = default;
};
class ListDoctorHiveTablesResponseBodyDataMetricsSmallFileCountDayGrowthRatio : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  ListDoctorHiveTablesResponseBodyDataMetricsSmallFileCountDayGrowthRatio() {}

  explicit ListDoctorHiveTablesResponseBodyDataMetricsSmallFileCountDayGrowthRatio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~ListDoctorHiveTablesResponseBodyDataMetricsSmallFileCountDayGrowthRatio() = default;
};
class ListDoctorHiveTablesResponseBodyDataMetricsSmallFileDayGrowthCount : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  ListDoctorHiveTablesResponseBodyDataMetricsSmallFileDayGrowthCount() {}

  explicit ListDoctorHiveTablesResponseBodyDataMetricsSmallFileDayGrowthCount(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~ListDoctorHiveTablesResponseBodyDataMetricsSmallFileDayGrowthCount() = default;
};
class ListDoctorHiveTablesResponseBodyDataMetricsSmallFileRatio : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  ListDoctorHiveTablesResponseBodyDataMetricsSmallFileRatio() {}

  explicit ListDoctorHiveTablesResponseBodyDataMetricsSmallFileRatio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~ListDoctorHiveTablesResponseBodyDataMetricsSmallFileRatio() = default;
};
class ListDoctorHiveTablesResponseBodyDataMetricsTinyFileCount : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  ListDoctorHiveTablesResponseBodyDataMetricsTinyFileCount() {}

  explicit ListDoctorHiveTablesResponseBodyDataMetricsTinyFileCount(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~ListDoctorHiveTablesResponseBodyDataMetricsTinyFileCount() = default;
};
class ListDoctorHiveTablesResponseBodyDataMetricsTinyFileCountDayGrowthRatio : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  ListDoctorHiveTablesResponseBodyDataMetricsTinyFileCountDayGrowthRatio() {}

  explicit ListDoctorHiveTablesResponseBodyDataMetricsTinyFileCountDayGrowthRatio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~ListDoctorHiveTablesResponseBodyDataMetricsTinyFileCountDayGrowthRatio() = default;
};
class ListDoctorHiveTablesResponseBodyDataMetricsTinyFileDayGrowthCount : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  ListDoctorHiveTablesResponseBodyDataMetricsTinyFileDayGrowthCount() {}

  explicit ListDoctorHiveTablesResponseBodyDataMetricsTinyFileDayGrowthCount(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~ListDoctorHiveTablesResponseBodyDataMetricsTinyFileDayGrowthCount() = default;
};
class ListDoctorHiveTablesResponseBodyDataMetricsTinyFileRatio : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  ListDoctorHiveTablesResponseBodyDataMetricsTinyFileRatio() {}

  explicit ListDoctorHiveTablesResponseBodyDataMetricsTinyFileRatio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~ListDoctorHiveTablesResponseBodyDataMetricsTinyFileRatio() = default;
};
class ListDoctorHiveTablesResponseBodyDataMetricsTotalDataDayGrowthSize : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  ListDoctorHiveTablesResponseBodyDataMetricsTotalDataDayGrowthSize() {}

  explicit ListDoctorHiveTablesResponseBodyDataMetricsTotalDataDayGrowthSize(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~ListDoctorHiveTablesResponseBodyDataMetricsTotalDataDayGrowthSize() = default;
};
class ListDoctorHiveTablesResponseBodyDataMetricsTotalDataSize : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  ListDoctorHiveTablesResponseBodyDataMetricsTotalDataSize() {}

  explicit ListDoctorHiveTablesResponseBodyDataMetricsTotalDataSize(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~ListDoctorHiveTablesResponseBodyDataMetricsTotalDataSize() = default;
};
class ListDoctorHiveTablesResponseBodyDataMetricsTotalDataSizeDayGrowthRatio : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  ListDoctorHiveTablesResponseBodyDataMetricsTotalDataSizeDayGrowthRatio() {}

  explicit ListDoctorHiveTablesResponseBodyDataMetricsTotalDataSizeDayGrowthRatio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~ListDoctorHiveTablesResponseBodyDataMetricsTotalDataSizeDayGrowthRatio() = default;
};
class ListDoctorHiveTablesResponseBodyDataMetricsTotalFileCount : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  ListDoctorHiveTablesResponseBodyDataMetricsTotalFileCount() {}

  explicit ListDoctorHiveTablesResponseBodyDataMetricsTotalFileCount(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~ListDoctorHiveTablesResponseBodyDataMetricsTotalFileCount() = default;
};
class ListDoctorHiveTablesResponseBodyDataMetricsTotalFileCountDayGrowthRatio : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  ListDoctorHiveTablesResponseBodyDataMetricsTotalFileCountDayGrowthRatio() {}

  explicit ListDoctorHiveTablesResponseBodyDataMetricsTotalFileCountDayGrowthRatio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~ListDoctorHiveTablesResponseBodyDataMetricsTotalFileCountDayGrowthRatio() = default;
};
class ListDoctorHiveTablesResponseBodyDataMetricsTotalFileDayGrowthCount : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  ListDoctorHiveTablesResponseBodyDataMetricsTotalFileDayGrowthCount() {}

  explicit ListDoctorHiveTablesResponseBodyDataMetricsTotalFileDayGrowthCount(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~ListDoctorHiveTablesResponseBodyDataMetricsTotalFileDayGrowthCount() = default;
};
class ListDoctorHiveTablesResponseBodyDataMetricsWarmDataDayGrowthSize : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  ListDoctorHiveTablesResponseBodyDataMetricsWarmDataDayGrowthSize() {}

  explicit ListDoctorHiveTablesResponseBodyDataMetricsWarmDataDayGrowthSize(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~ListDoctorHiveTablesResponseBodyDataMetricsWarmDataDayGrowthSize() = default;
};
class ListDoctorHiveTablesResponseBodyDataMetricsWarmDataRatio : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  ListDoctorHiveTablesResponseBodyDataMetricsWarmDataRatio() {}

  explicit ListDoctorHiveTablesResponseBodyDataMetricsWarmDataRatio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~ListDoctorHiveTablesResponseBodyDataMetricsWarmDataRatio() = default;
};
class ListDoctorHiveTablesResponseBodyDataMetricsWarmDataSize : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  ListDoctorHiveTablesResponseBodyDataMetricsWarmDataSize() {}

  explicit ListDoctorHiveTablesResponseBodyDataMetricsWarmDataSize(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~ListDoctorHiveTablesResponseBodyDataMetricsWarmDataSize() = default;
};
class ListDoctorHiveTablesResponseBodyDataMetricsWarmDataSizeDayGrowthRatio : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<double> value{};

  ListDoctorHiveTablesResponseBodyDataMetricsWarmDataSizeDayGrowthRatio() {}

  explicit ListDoctorHiveTablesResponseBodyDataMetricsWarmDataSizeDayGrowthRatio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~ListDoctorHiveTablesResponseBodyDataMetricsWarmDataSizeDayGrowthRatio() = default;
};
class ListDoctorHiveTablesResponseBodyDataMetrics : public Darabonba::Model {
public:
  shared_ptr<ListDoctorHiveTablesResponseBodyDataMetricsColdDataDayGrowthSize> coldDataDayGrowthSize{};
  shared_ptr<ListDoctorHiveTablesResponseBodyDataMetricsColdDataRatio> coldDataRatio{};
  shared_ptr<ListDoctorHiveTablesResponseBodyDataMetricsColdDataSize> coldDataSize{};
  shared_ptr<ListDoctorHiveTablesResponseBodyDataMetricsColdDataSizeDayGrowthRatio> coldDataSizeDayGrowthRatio{};
  shared_ptr<ListDoctorHiveTablesResponseBodyDataMetricsEmptyFileCount> emptyFileCount{};
  shared_ptr<ListDoctorHiveTablesResponseBodyDataMetricsEmptyFileCountDayGrowthRatio> emptyFileCountDayGrowthRatio{};
  shared_ptr<ListDoctorHiveTablesResponseBodyDataMetricsEmptyFileDayGrowthCount> emptyFileDayGrowthCount{};
  shared_ptr<ListDoctorHiveTablesResponseBodyDataMetricsEmptyFileRatio> emptyFileRatio{};
  shared_ptr<ListDoctorHiveTablesResponseBodyDataMetricsFreezeDataDayGrowthSize> freezeDataDayGrowthSize{};
  shared_ptr<ListDoctorHiveTablesResponseBodyDataMetricsFreezeDataRatio> freezeDataRatio{};
  shared_ptr<ListDoctorHiveTablesResponseBodyDataMetricsFreezeDataSize> freezeDataSize{};
  shared_ptr<ListDoctorHiveTablesResponseBodyDataMetricsFreezeDataSizeDayGrowthRatio> freezeDataSizeDayGrowthRatio{};
  shared_ptr<ListDoctorHiveTablesResponseBodyDataMetricsHotDataDayGrowthSize> hotDataDayGrowthSize{};
  shared_ptr<ListDoctorHiveTablesResponseBodyDataMetricsHotDataRatio> hotDataRatio{};
  shared_ptr<ListDoctorHiveTablesResponseBodyDataMetricsHotDataSize> hotDataSize{};
  shared_ptr<ListDoctorHiveTablesResponseBodyDataMetricsHotDataSizeDayGrowthRatio> hotDataSizeDayGrowthRatio{};
  shared_ptr<ListDoctorHiveTablesResponseBodyDataMetricsLargeFileCount> largeFileCount{};
  shared_ptr<ListDoctorHiveTablesResponseBodyDataMetricsLargeFileCountDayGrowthRatio> largeFileCountDayGrowthRatio{};
  shared_ptr<ListDoctorHiveTablesResponseBodyDataMetricsLargeFileDayGrowthCount> largeFileDayGrowthCount{};
  shared_ptr<ListDoctorHiveTablesResponseBodyDataMetricsLargeFileRatio> largeFileRatio{};
  shared_ptr<ListDoctorHiveTablesResponseBodyDataMetricsMediumFileCount> mediumFileCount{};
  shared_ptr<ListDoctorHiveTablesResponseBodyDataMetricsMediumFileCountDayGrowthRatio> mediumFileCountDayGrowthRatio{};
  shared_ptr<ListDoctorHiveTablesResponseBodyDataMetricsMediumFileDayGrowthCount> mediumFileDayGrowthCount{};
  shared_ptr<ListDoctorHiveTablesResponseBodyDataMetricsMediumFileRatio> mediumFileRatio{};
  shared_ptr<ListDoctorHiveTablesResponseBodyDataMetricsPartitionNum> partitionNum{};
  shared_ptr<ListDoctorHiveTablesResponseBodyDataMetricsSmallFileCount> smallFileCount{};
  shared_ptr<ListDoctorHiveTablesResponseBodyDataMetricsSmallFileCountDayGrowthRatio> smallFileCountDayGrowthRatio{};
  shared_ptr<ListDoctorHiveTablesResponseBodyDataMetricsSmallFileDayGrowthCount> smallFileDayGrowthCount{};
  shared_ptr<ListDoctorHiveTablesResponseBodyDataMetricsSmallFileRatio> smallFileRatio{};
  shared_ptr<ListDoctorHiveTablesResponseBodyDataMetricsTinyFileCount> tinyFileCount{};
  shared_ptr<ListDoctorHiveTablesResponseBodyDataMetricsTinyFileCountDayGrowthRatio> tinyFileCountDayGrowthRatio{};
  shared_ptr<ListDoctorHiveTablesResponseBodyDataMetricsTinyFileDayGrowthCount> tinyFileDayGrowthCount{};
  shared_ptr<ListDoctorHiveTablesResponseBodyDataMetricsTinyFileRatio> tinyFileRatio{};
  shared_ptr<ListDoctorHiveTablesResponseBodyDataMetricsTotalDataDayGrowthSize> totalDataDayGrowthSize{};
  shared_ptr<ListDoctorHiveTablesResponseBodyDataMetricsTotalDataSize> totalDataSize{};
  shared_ptr<ListDoctorHiveTablesResponseBodyDataMetricsTotalDataSizeDayGrowthRatio> totalDataSizeDayGrowthRatio{};
  shared_ptr<ListDoctorHiveTablesResponseBodyDataMetricsTotalFileCount> totalFileCount{};
  shared_ptr<ListDoctorHiveTablesResponseBodyDataMetricsTotalFileCountDayGrowthRatio> totalFileCountDayGrowthRatio{};
  shared_ptr<ListDoctorHiveTablesResponseBodyDataMetricsTotalFileDayGrowthCount> totalFileDayGrowthCount{};
  shared_ptr<ListDoctorHiveTablesResponseBodyDataMetricsWarmDataDayGrowthSize> warmDataDayGrowthSize{};
  shared_ptr<ListDoctorHiveTablesResponseBodyDataMetricsWarmDataRatio> warmDataRatio{};
  shared_ptr<ListDoctorHiveTablesResponseBodyDataMetricsWarmDataSize> warmDataSize{};
  shared_ptr<ListDoctorHiveTablesResponseBodyDataMetricsWarmDataSizeDayGrowthRatio> warmDataSizeDayGrowthRatio{};

  ListDoctorHiveTablesResponseBodyDataMetrics() {}

  explicit ListDoctorHiveTablesResponseBodyDataMetrics(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (coldDataDayGrowthSize) {
      res["ColdDataDayGrowthSize"] = coldDataDayGrowthSize ? boost::any(coldDataDayGrowthSize->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (coldDataRatio) {
      res["ColdDataRatio"] = coldDataRatio ? boost::any(coldDataRatio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (coldDataSize) {
      res["ColdDataSize"] = coldDataSize ? boost::any(coldDataSize->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (coldDataSizeDayGrowthRatio) {
      res["ColdDataSizeDayGrowthRatio"] = coldDataSizeDayGrowthRatio ? boost::any(coldDataSizeDayGrowthRatio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (emptyFileCount) {
      res["EmptyFileCount"] = emptyFileCount ? boost::any(emptyFileCount->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (emptyFileCountDayGrowthRatio) {
      res["EmptyFileCountDayGrowthRatio"] = emptyFileCountDayGrowthRatio ? boost::any(emptyFileCountDayGrowthRatio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (emptyFileDayGrowthCount) {
      res["EmptyFileDayGrowthCount"] = emptyFileDayGrowthCount ? boost::any(emptyFileDayGrowthCount->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (emptyFileRatio) {
      res["EmptyFileRatio"] = emptyFileRatio ? boost::any(emptyFileRatio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (freezeDataDayGrowthSize) {
      res["FreezeDataDayGrowthSize"] = freezeDataDayGrowthSize ? boost::any(freezeDataDayGrowthSize->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (freezeDataRatio) {
      res["FreezeDataRatio"] = freezeDataRatio ? boost::any(freezeDataRatio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (freezeDataSize) {
      res["FreezeDataSize"] = freezeDataSize ? boost::any(freezeDataSize->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (freezeDataSizeDayGrowthRatio) {
      res["FreezeDataSizeDayGrowthRatio"] = freezeDataSizeDayGrowthRatio ? boost::any(freezeDataSizeDayGrowthRatio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (hotDataDayGrowthSize) {
      res["HotDataDayGrowthSize"] = hotDataDayGrowthSize ? boost::any(hotDataDayGrowthSize->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (hotDataRatio) {
      res["HotDataRatio"] = hotDataRatio ? boost::any(hotDataRatio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (hotDataSize) {
      res["HotDataSize"] = hotDataSize ? boost::any(hotDataSize->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (hotDataSizeDayGrowthRatio) {
      res["HotDataSizeDayGrowthRatio"] = hotDataSizeDayGrowthRatio ? boost::any(hotDataSizeDayGrowthRatio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (largeFileCount) {
      res["LargeFileCount"] = largeFileCount ? boost::any(largeFileCount->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (largeFileCountDayGrowthRatio) {
      res["LargeFileCountDayGrowthRatio"] = largeFileCountDayGrowthRatio ? boost::any(largeFileCountDayGrowthRatio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (largeFileDayGrowthCount) {
      res["LargeFileDayGrowthCount"] = largeFileDayGrowthCount ? boost::any(largeFileDayGrowthCount->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (largeFileRatio) {
      res["LargeFileRatio"] = largeFileRatio ? boost::any(largeFileRatio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (mediumFileCount) {
      res["MediumFileCount"] = mediumFileCount ? boost::any(mediumFileCount->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (mediumFileCountDayGrowthRatio) {
      res["MediumFileCountDayGrowthRatio"] = mediumFileCountDayGrowthRatio ? boost::any(mediumFileCountDayGrowthRatio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (mediumFileDayGrowthCount) {
      res["MediumFileDayGrowthCount"] = mediumFileDayGrowthCount ? boost::any(mediumFileDayGrowthCount->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (mediumFileRatio) {
      res["MediumFileRatio"] = mediumFileRatio ? boost::any(mediumFileRatio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (partitionNum) {
      res["PartitionNum"] = partitionNum ? boost::any(partitionNum->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (smallFileCount) {
      res["SmallFileCount"] = smallFileCount ? boost::any(smallFileCount->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (smallFileCountDayGrowthRatio) {
      res["SmallFileCountDayGrowthRatio"] = smallFileCountDayGrowthRatio ? boost::any(smallFileCountDayGrowthRatio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (smallFileDayGrowthCount) {
      res["SmallFileDayGrowthCount"] = smallFileDayGrowthCount ? boost::any(smallFileDayGrowthCount->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (smallFileRatio) {
      res["SmallFileRatio"] = smallFileRatio ? boost::any(smallFileRatio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tinyFileCount) {
      res["TinyFileCount"] = tinyFileCount ? boost::any(tinyFileCount->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tinyFileCountDayGrowthRatio) {
      res["TinyFileCountDayGrowthRatio"] = tinyFileCountDayGrowthRatio ? boost::any(tinyFileCountDayGrowthRatio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tinyFileDayGrowthCount) {
      res["TinyFileDayGrowthCount"] = tinyFileDayGrowthCount ? boost::any(tinyFileDayGrowthCount->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tinyFileRatio) {
      res["TinyFileRatio"] = tinyFileRatio ? boost::any(tinyFileRatio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (totalDataDayGrowthSize) {
      res["TotalDataDayGrowthSize"] = totalDataDayGrowthSize ? boost::any(totalDataDayGrowthSize->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (totalDataSize) {
      res["TotalDataSize"] = totalDataSize ? boost::any(totalDataSize->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (totalDataSizeDayGrowthRatio) {
      res["TotalDataSizeDayGrowthRatio"] = totalDataSizeDayGrowthRatio ? boost::any(totalDataSizeDayGrowthRatio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (totalFileCount) {
      res["TotalFileCount"] = totalFileCount ? boost::any(totalFileCount->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (totalFileCountDayGrowthRatio) {
      res["TotalFileCountDayGrowthRatio"] = totalFileCountDayGrowthRatio ? boost::any(totalFileCountDayGrowthRatio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (totalFileDayGrowthCount) {
      res["TotalFileDayGrowthCount"] = totalFileDayGrowthCount ? boost::any(totalFileDayGrowthCount->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (warmDataDayGrowthSize) {
      res["WarmDataDayGrowthSize"] = warmDataDayGrowthSize ? boost::any(warmDataDayGrowthSize->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (warmDataRatio) {
      res["WarmDataRatio"] = warmDataRatio ? boost::any(warmDataRatio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (warmDataSize) {
      res["WarmDataSize"] = warmDataSize ? boost::any(warmDataSize->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (warmDataSizeDayGrowthRatio) {
      res["WarmDataSizeDayGrowthRatio"] = warmDataSizeDayGrowthRatio ? boost::any(warmDataSizeDayGrowthRatio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ColdDataDayGrowthSize") != m.end() && !m["ColdDataDayGrowthSize"].empty()) {
      if (typeid(map<string, boost::any>) == m["ColdDataDayGrowthSize"].type()) {
        ListDoctorHiveTablesResponseBodyDataMetricsColdDataDayGrowthSize model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ColdDataDayGrowthSize"]));
        coldDataDayGrowthSize = make_shared<ListDoctorHiveTablesResponseBodyDataMetricsColdDataDayGrowthSize>(model1);
      }
    }
    if (m.find("ColdDataRatio") != m.end() && !m["ColdDataRatio"].empty()) {
      if (typeid(map<string, boost::any>) == m["ColdDataRatio"].type()) {
        ListDoctorHiveTablesResponseBodyDataMetricsColdDataRatio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ColdDataRatio"]));
        coldDataRatio = make_shared<ListDoctorHiveTablesResponseBodyDataMetricsColdDataRatio>(model1);
      }
    }
    if (m.find("ColdDataSize") != m.end() && !m["ColdDataSize"].empty()) {
      if (typeid(map<string, boost::any>) == m["ColdDataSize"].type()) {
        ListDoctorHiveTablesResponseBodyDataMetricsColdDataSize model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ColdDataSize"]));
        coldDataSize = make_shared<ListDoctorHiveTablesResponseBodyDataMetricsColdDataSize>(model1);
      }
    }
    if (m.find("ColdDataSizeDayGrowthRatio") != m.end() && !m["ColdDataSizeDayGrowthRatio"].empty()) {
      if (typeid(map<string, boost::any>) == m["ColdDataSizeDayGrowthRatio"].type()) {
        ListDoctorHiveTablesResponseBodyDataMetricsColdDataSizeDayGrowthRatio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ColdDataSizeDayGrowthRatio"]));
        coldDataSizeDayGrowthRatio = make_shared<ListDoctorHiveTablesResponseBodyDataMetricsColdDataSizeDayGrowthRatio>(model1);
      }
    }
    if (m.find("EmptyFileCount") != m.end() && !m["EmptyFileCount"].empty()) {
      if (typeid(map<string, boost::any>) == m["EmptyFileCount"].type()) {
        ListDoctorHiveTablesResponseBodyDataMetricsEmptyFileCount model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EmptyFileCount"]));
        emptyFileCount = make_shared<ListDoctorHiveTablesResponseBodyDataMetricsEmptyFileCount>(model1);
      }
    }
    if (m.find("EmptyFileCountDayGrowthRatio") != m.end() && !m["EmptyFileCountDayGrowthRatio"].empty()) {
      if (typeid(map<string, boost::any>) == m["EmptyFileCountDayGrowthRatio"].type()) {
        ListDoctorHiveTablesResponseBodyDataMetricsEmptyFileCountDayGrowthRatio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EmptyFileCountDayGrowthRatio"]));
        emptyFileCountDayGrowthRatio = make_shared<ListDoctorHiveTablesResponseBodyDataMetricsEmptyFileCountDayGrowthRatio>(model1);
      }
    }
    if (m.find("EmptyFileDayGrowthCount") != m.end() && !m["EmptyFileDayGrowthCount"].empty()) {
      if (typeid(map<string, boost::any>) == m["EmptyFileDayGrowthCount"].type()) {
        ListDoctorHiveTablesResponseBodyDataMetricsEmptyFileDayGrowthCount model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EmptyFileDayGrowthCount"]));
        emptyFileDayGrowthCount = make_shared<ListDoctorHiveTablesResponseBodyDataMetricsEmptyFileDayGrowthCount>(model1);
      }
    }
    if (m.find("EmptyFileRatio") != m.end() && !m["EmptyFileRatio"].empty()) {
      if (typeid(map<string, boost::any>) == m["EmptyFileRatio"].type()) {
        ListDoctorHiveTablesResponseBodyDataMetricsEmptyFileRatio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EmptyFileRatio"]));
        emptyFileRatio = make_shared<ListDoctorHiveTablesResponseBodyDataMetricsEmptyFileRatio>(model1);
      }
    }
    if (m.find("FreezeDataDayGrowthSize") != m.end() && !m["FreezeDataDayGrowthSize"].empty()) {
      if (typeid(map<string, boost::any>) == m["FreezeDataDayGrowthSize"].type()) {
        ListDoctorHiveTablesResponseBodyDataMetricsFreezeDataDayGrowthSize model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FreezeDataDayGrowthSize"]));
        freezeDataDayGrowthSize = make_shared<ListDoctorHiveTablesResponseBodyDataMetricsFreezeDataDayGrowthSize>(model1);
      }
    }
    if (m.find("FreezeDataRatio") != m.end() && !m["FreezeDataRatio"].empty()) {
      if (typeid(map<string, boost::any>) == m["FreezeDataRatio"].type()) {
        ListDoctorHiveTablesResponseBodyDataMetricsFreezeDataRatio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FreezeDataRatio"]));
        freezeDataRatio = make_shared<ListDoctorHiveTablesResponseBodyDataMetricsFreezeDataRatio>(model1);
      }
    }
    if (m.find("FreezeDataSize") != m.end() && !m["FreezeDataSize"].empty()) {
      if (typeid(map<string, boost::any>) == m["FreezeDataSize"].type()) {
        ListDoctorHiveTablesResponseBodyDataMetricsFreezeDataSize model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FreezeDataSize"]));
        freezeDataSize = make_shared<ListDoctorHiveTablesResponseBodyDataMetricsFreezeDataSize>(model1);
      }
    }
    if (m.find("FreezeDataSizeDayGrowthRatio") != m.end() && !m["FreezeDataSizeDayGrowthRatio"].empty()) {
      if (typeid(map<string, boost::any>) == m["FreezeDataSizeDayGrowthRatio"].type()) {
        ListDoctorHiveTablesResponseBodyDataMetricsFreezeDataSizeDayGrowthRatio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FreezeDataSizeDayGrowthRatio"]));
        freezeDataSizeDayGrowthRatio = make_shared<ListDoctorHiveTablesResponseBodyDataMetricsFreezeDataSizeDayGrowthRatio>(model1);
      }
    }
    if (m.find("HotDataDayGrowthSize") != m.end() && !m["HotDataDayGrowthSize"].empty()) {
      if (typeid(map<string, boost::any>) == m["HotDataDayGrowthSize"].type()) {
        ListDoctorHiveTablesResponseBodyDataMetricsHotDataDayGrowthSize model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["HotDataDayGrowthSize"]));
        hotDataDayGrowthSize = make_shared<ListDoctorHiveTablesResponseBodyDataMetricsHotDataDayGrowthSize>(model1);
      }
    }
    if (m.find("HotDataRatio") != m.end() && !m["HotDataRatio"].empty()) {
      if (typeid(map<string, boost::any>) == m["HotDataRatio"].type()) {
        ListDoctorHiveTablesResponseBodyDataMetricsHotDataRatio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["HotDataRatio"]));
        hotDataRatio = make_shared<ListDoctorHiveTablesResponseBodyDataMetricsHotDataRatio>(model1);
      }
    }
    if (m.find("HotDataSize") != m.end() && !m["HotDataSize"].empty()) {
      if (typeid(map<string, boost::any>) == m["HotDataSize"].type()) {
        ListDoctorHiveTablesResponseBodyDataMetricsHotDataSize model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["HotDataSize"]));
        hotDataSize = make_shared<ListDoctorHiveTablesResponseBodyDataMetricsHotDataSize>(model1);
      }
    }
    if (m.find("HotDataSizeDayGrowthRatio") != m.end() && !m["HotDataSizeDayGrowthRatio"].empty()) {
      if (typeid(map<string, boost::any>) == m["HotDataSizeDayGrowthRatio"].type()) {
        ListDoctorHiveTablesResponseBodyDataMetricsHotDataSizeDayGrowthRatio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["HotDataSizeDayGrowthRatio"]));
        hotDataSizeDayGrowthRatio = make_shared<ListDoctorHiveTablesResponseBodyDataMetricsHotDataSizeDayGrowthRatio>(model1);
      }
    }
    if (m.find("LargeFileCount") != m.end() && !m["LargeFileCount"].empty()) {
      if (typeid(map<string, boost::any>) == m["LargeFileCount"].type()) {
        ListDoctorHiveTablesResponseBodyDataMetricsLargeFileCount model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LargeFileCount"]));
        largeFileCount = make_shared<ListDoctorHiveTablesResponseBodyDataMetricsLargeFileCount>(model1);
      }
    }
    if (m.find("LargeFileCountDayGrowthRatio") != m.end() && !m["LargeFileCountDayGrowthRatio"].empty()) {
      if (typeid(map<string, boost::any>) == m["LargeFileCountDayGrowthRatio"].type()) {
        ListDoctorHiveTablesResponseBodyDataMetricsLargeFileCountDayGrowthRatio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LargeFileCountDayGrowthRatio"]));
        largeFileCountDayGrowthRatio = make_shared<ListDoctorHiveTablesResponseBodyDataMetricsLargeFileCountDayGrowthRatio>(model1);
      }
    }
    if (m.find("LargeFileDayGrowthCount") != m.end() && !m["LargeFileDayGrowthCount"].empty()) {
      if (typeid(map<string, boost::any>) == m["LargeFileDayGrowthCount"].type()) {
        ListDoctorHiveTablesResponseBodyDataMetricsLargeFileDayGrowthCount model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LargeFileDayGrowthCount"]));
        largeFileDayGrowthCount = make_shared<ListDoctorHiveTablesResponseBodyDataMetricsLargeFileDayGrowthCount>(model1);
      }
    }
    if (m.find("LargeFileRatio") != m.end() && !m["LargeFileRatio"].empty()) {
      if (typeid(map<string, boost::any>) == m["LargeFileRatio"].type()) {
        ListDoctorHiveTablesResponseBodyDataMetricsLargeFileRatio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LargeFileRatio"]));
        largeFileRatio = make_shared<ListDoctorHiveTablesResponseBodyDataMetricsLargeFileRatio>(model1);
      }
    }
    if (m.find("MediumFileCount") != m.end() && !m["MediumFileCount"].empty()) {
      if (typeid(map<string, boost::any>) == m["MediumFileCount"].type()) {
        ListDoctorHiveTablesResponseBodyDataMetricsMediumFileCount model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MediumFileCount"]));
        mediumFileCount = make_shared<ListDoctorHiveTablesResponseBodyDataMetricsMediumFileCount>(model1);
      }
    }
    if (m.find("MediumFileCountDayGrowthRatio") != m.end() && !m["MediumFileCountDayGrowthRatio"].empty()) {
      if (typeid(map<string, boost::any>) == m["MediumFileCountDayGrowthRatio"].type()) {
        ListDoctorHiveTablesResponseBodyDataMetricsMediumFileCountDayGrowthRatio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MediumFileCountDayGrowthRatio"]));
        mediumFileCountDayGrowthRatio = make_shared<ListDoctorHiveTablesResponseBodyDataMetricsMediumFileCountDayGrowthRatio>(model1);
      }
    }
    if (m.find("MediumFileDayGrowthCount") != m.end() && !m["MediumFileDayGrowthCount"].empty()) {
      if (typeid(map<string, boost::any>) == m["MediumFileDayGrowthCount"].type()) {
        ListDoctorHiveTablesResponseBodyDataMetricsMediumFileDayGrowthCount model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MediumFileDayGrowthCount"]));
        mediumFileDayGrowthCount = make_shared<ListDoctorHiveTablesResponseBodyDataMetricsMediumFileDayGrowthCount>(model1);
      }
    }
    if (m.find("MediumFileRatio") != m.end() && !m["MediumFileRatio"].empty()) {
      if (typeid(map<string, boost::any>) == m["MediumFileRatio"].type()) {
        ListDoctorHiveTablesResponseBodyDataMetricsMediumFileRatio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MediumFileRatio"]));
        mediumFileRatio = make_shared<ListDoctorHiveTablesResponseBodyDataMetricsMediumFileRatio>(model1);
      }
    }
    if (m.find("PartitionNum") != m.end() && !m["PartitionNum"].empty()) {
      if (typeid(map<string, boost::any>) == m["PartitionNum"].type()) {
        ListDoctorHiveTablesResponseBodyDataMetricsPartitionNum model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PartitionNum"]));
        partitionNum = make_shared<ListDoctorHiveTablesResponseBodyDataMetricsPartitionNum>(model1);
      }
    }
    if (m.find("SmallFileCount") != m.end() && !m["SmallFileCount"].empty()) {
      if (typeid(map<string, boost::any>) == m["SmallFileCount"].type()) {
        ListDoctorHiveTablesResponseBodyDataMetricsSmallFileCount model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SmallFileCount"]));
        smallFileCount = make_shared<ListDoctorHiveTablesResponseBodyDataMetricsSmallFileCount>(model1);
      }
    }
    if (m.find("SmallFileCountDayGrowthRatio") != m.end() && !m["SmallFileCountDayGrowthRatio"].empty()) {
      if (typeid(map<string, boost::any>) == m["SmallFileCountDayGrowthRatio"].type()) {
        ListDoctorHiveTablesResponseBodyDataMetricsSmallFileCountDayGrowthRatio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SmallFileCountDayGrowthRatio"]));
        smallFileCountDayGrowthRatio = make_shared<ListDoctorHiveTablesResponseBodyDataMetricsSmallFileCountDayGrowthRatio>(model1);
      }
    }
    if (m.find("SmallFileDayGrowthCount") != m.end() && !m["SmallFileDayGrowthCount"].empty()) {
      if (typeid(map<string, boost::any>) == m["SmallFileDayGrowthCount"].type()) {
        ListDoctorHiveTablesResponseBodyDataMetricsSmallFileDayGrowthCount model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SmallFileDayGrowthCount"]));
        smallFileDayGrowthCount = make_shared<ListDoctorHiveTablesResponseBodyDataMetricsSmallFileDayGrowthCount>(model1);
      }
    }
    if (m.find("SmallFileRatio") != m.end() && !m["SmallFileRatio"].empty()) {
      if (typeid(map<string, boost::any>) == m["SmallFileRatio"].type()) {
        ListDoctorHiveTablesResponseBodyDataMetricsSmallFileRatio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SmallFileRatio"]));
        smallFileRatio = make_shared<ListDoctorHiveTablesResponseBodyDataMetricsSmallFileRatio>(model1);
      }
    }
    if (m.find("TinyFileCount") != m.end() && !m["TinyFileCount"].empty()) {
      if (typeid(map<string, boost::any>) == m["TinyFileCount"].type()) {
        ListDoctorHiveTablesResponseBodyDataMetricsTinyFileCount model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TinyFileCount"]));
        tinyFileCount = make_shared<ListDoctorHiveTablesResponseBodyDataMetricsTinyFileCount>(model1);
      }
    }
    if (m.find("TinyFileCountDayGrowthRatio") != m.end() && !m["TinyFileCountDayGrowthRatio"].empty()) {
      if (typeid(map<string, boost::any>) == m["TinyFileCountDayGrowthRatio"].type()) {
        ListDoctorHiveTablesResponseBodyDataMetricsTinyFileCountDayGrowthRatio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TinyFileCountDayGrowthRatio"]));
        tinyFileCountDayGrowthRatio = make_shared<ListDoctorHiveTablesResponseBodyDataMetricsTinyFileCountDayGrowthRatio>(model1);
      }
    }
    if (m.find("TinyFileDayGrowthCount") != m.end() && !m["TinyFileDayGrowthCount"].empty()) {
      if (typeid(map<string, boost::any>) == m["TinyFileDayGrowthCount"].type()) {
        ListDoctorHiveTablesResponseBodyDataMetricsTinyFileDayGrowthCount model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TinyFileDayGrowthCount"]));
        tinyFileDayGrowthCount = make_shared<ListDoctorHiveTablesResponseBodyDataMetricsTinyFileDayGrowthCount>(model1);
      }
    }
    if (m.find("TinyFileRatio") != m.end() && !m["TinyFileRatio"].empty()) {
      if (typeid(map<string, boost::any>) == m["TinyFileRatio"].type()) {
        ListDoctorHiveTablesResponseBodyDataMetricsTinyFileRatio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TinyFileRatio"]));
        tinyFileRatio = make_shared<ListDoctorHiveTablesResponseBodyDataMetricsTinyFileRatio>(model1);
      }
    }
    if (m.find("TotalDataDayGrowthSize") != m.end() && !m["TotalDataDayGrowthSize"].empty()) {
      if (typeid(map<string, boost::any>) == m["TotalDataDayGrowthSize"].type()) {
        ListDoctorHiveTablesResponseBodyDataMetricsTotalDataDayGrowthSize model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TotalDataDayGrowthSize"]));
        totalDataDayGrowthSize = make_shared<ListDoctorHiveTablesResponseBodyDataMetricsTotalDataDayGrowthSize>(model1);
      }
    }
    if (m.find("TotalDataSize") != m.end() && !m["TotalDataSize"].empty()) {
      if (typeid(map<string, boost::any>) == m["TotalDataSize"].type()) {
        ListDoctorHiveTablesResponseBodyDataMetricsTotalDataSize model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TotalDataSize"]));
        totalDataSize = make_shared<ListDoctorHiveTablesResponseBodyDataMetricsTotalDataSize>(model1);
      }
    }
    if (m.find("TotalDataSizeDayGrowthRatio") != m.end() && !m["TotalDataSizeDayGrowthRatio"].empty()) {
      if (typeid(map<string, boost::any>) == m["TotalDataSizeDayGrowthRatio"].type()) {
        ListDoctorHiveTablesResponseBodyDataMetricsTotalDataSizeDayGrowthRatio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TotalDataSizeDayGrowthRatio"]));
        totalDataSizeDayGrowthRatio = make_shared<ListDoctorHiveTablesResponseBodyDataMetricsTotalDataSizeDayGrowthRatio>(model1);
      }
    }
    if (m.find("TotalFileCount") != m.end() && !m["TotalFileCount"].empty()) {
      if (typeid(map<string, boost::any>) == m["TotalFileCount"].type()) {
        ListDoctorHiveTablesResponseBodyDataMetricsTotalFileCount model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TotalFileCount"]));
        totalFileCount = make_shared<ListDoctorHiveTablesResponseBodyDataMetricsTotalFileCount>(model1);
      }
    }
    if (m.find("TotalFileCountDayGrowthRatio") != m.end() && !m["TotalFileCountDayGrowthRatio"].empty()) {
      if (typeid(map<string, boost::any>) == m["TotalFileCountDayGrowthRatio"].type()) {
        ListDoctorHiveTablesResponseBodyDataMetricsTotalFileCountDayGrowthRatio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TotalFileCountDayGrowthRatio"]));
        totalFileCountDayGrowthRatio = make_shared<ListDoctorHiveTablesResponseBodyDataMetricsTotalFileCountDayGrowthRatio>(model1);
      }
    }
    if (m.find("TotalFileDayGrowthCount") != m.end() && !m["TotalFileDayGrowthCount"].empty()) {
      if (typeid(map<string, boost::any>) == m["TotalFileDayGrowthCount"].type()) {
        ListDoctorHiveTablesResponseBodyDataMetricsTotalFileDayGrowthCount model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TotalFileDayGrowthCount"]));
        totalFileDayGrowthCount = make_shared<ListDoctorHiveTablesResponseBodyDataMetricsTotalFileDayGrowthCount>(model1);
      }
    }
    if (m.find("WarmDataDayGrowthSize") != m.end() && !m["WarmDataDayGrowthSize"].empty()) {
      if (typeid(map<string, boost::any>) == m["WarmDataDayGrowthSize"].type()) {
        ListDoctorHiveTablesResponseBodyDataMetricsWarmDataDayGrowthSize model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["WarmDataDayGrowthSize"]));
        warmDataDayGrowthSize = make_shared<ListDoctorHiveTablesResponseBodyDataMetricsWarmDataDayGrowthSize>(model1);
      }
    }
    if (m.find("WarmDataRatio") != m.end() && !m["WarmDataRatio"].empty()) {
      if (typeid(map<string, boost::any>) == m["WarmDataRatio"].type()) {
        ListDoctorHiveTablesResponseBodyDataMetricsWarmDataRatio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["WarmDataRatio"]));
        warmDataRatio = make_shared<ListDoctorHiveTablesResponseBodyDataMetricsWarmDataRatio>(model1);
      }
    }
    if (m.find("WarmDataSize") != m.end() && !m["WarmDataSize"].empty()) {
      if (typeid(map<string, boost::any>) == m["WarmDataSize"].type()) {
        ListDoctorHiveTablesResponseBodyDataMetricsWarmDataSize model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["WarmDataSize"]));
        warmDataSize = make_shared<ListDoctorHiveTablesResponseBodyDataMetricsWarmDataSize>(model1);
      }
    }
    if (m.find("WarmDataSizeDayGrowthRatio") != m.end() && !m["WarmDataSizeDayGrowthRatio"].empty()) {
      if (typeid(map<string, boost::any>) == m["WarmDataSizeDayGrowthRatio"].type()) {
        ListDoctorHiveTablesResponseBodyDataMetricsWarmDataSizeDayGrowthRatio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["WarmDataSizeDayGrowthRatio"]));
        warmDataSizeDayGrowthRatio = make_shared<ListDoctorHiveTablesResponseBodyDataMetricsWarmDataSizeDayGrowthRatio>(model1);
      }
    }
  }


  virtual ~ListDoctorHiveTablesResponseBodyDataMetrics() = default;
};
class ListDoctorHiveTablesResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<ListDoctorHiveTablesResponseBodyDataAnalysis> analysis{};
  shared_ptr<vector<ListDoctorHiveTablesResponseBodyDataFormats>> formats{};
  shared_ptr<ListDoctorHiveTablesResponseBodyDataMetrics> metrics{};
  shared_ptr<string> owner{};
  shared_ptr<string> tableName{};

  ListDoctorHiveTablesResponseBodyData() {}

  explicit ListDoctorHiveTablesResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (analysis) {
      res["Analysis"] = analysis ? boost::any(analysis->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (formats) {
      vector<boost::any> temp1;
      for(auto item1:*formats){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Formats"] = boost::any(temp1);
    }
    if (metrics) {
      res["Metrics"] = metrics ? boost::any(metrics->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (tableName) {
      res["TableName"] = boost::any(*tableName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Analysis") != m.end() && !m["Analysis"].empty()) {
      if (typeid(map<string, boost::any>) == m["Analysis"].type()) {
        ListDoctorHiveTablesResponseBodyDataAnalysis model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Analysis"]));
        analysis = make_shared<ListDoctorHiveTablesResponseBodyDataAnalysis>(model1);
      }
    }
    if (m.find("Formats") != m.end() && !m["Formats"].empty()) {
      if (typeid(vector<boost::any>) == m["Formats"].type()) {
        vector<ListDoctorHiveTablesResponseBodyDataFormats> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Formats"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDoctorHiveTablesResponseBodyDataFormats model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        formats = make_shared<vector<ListDoctorHiveTablesResponseBodyDataFormats>>(expect1);
      }
    }
    if (m.find("Metrics") != m.end() && !m["Metrics"].empty()) {
      if (typeid(map<string, boost::any>) == m["Metrics"].type()) {
        ListDoctorHiveTablesResponseBodyDataMetrics model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Metrics"]));
        metrics = make_shared<ListDoctorHiveTablesResponseBodyDataMetrics>(model1);
      }
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("TableName") != m.end() && !m["TableName"].empty()) {
      tableName = make_shared<string>(boost::any_cast<string>(m["TableName"]));
    }
  }


  virtual ~ListDoctorHiveTablesResponseBodyData() = default;
};
class ListDoctorHiveTablesResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListDoctorHiveTablesResponseBodyData>> data{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ListDoctorHiveTablesResponseBody() {}

  explicit ListDoctorHiveTablesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<ListDoctorHiveTablesResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDoctorHiveTablesResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListDoctorHiveTablesResponseBodyData>>(expect1);
      }
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListDoctorHiveTablesResponseBody() = default;
};
class ListDoctorHiveTablesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListDoctorHiveTablesResponseBody> body{};

  ListDoctorHiveTablesResponse() {}

  explicit ListDoctorHiveTablesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListDoctorHiveTablesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListDoctorHiveTablesResponseBody>(model1);
      }
    }
  }


  virtual ~ListDoctorHiveTablesResponse() = default;
};
class ListDoctorJobsRequestEndRange : public Darabonba::Model {
public:
  shared_ptr<long> endTime{};
  shared_ptr<long> startTime{};

  ListDoctorJobsRequestEndRange() {}

  explicit ListDoctorJobsRequestEndRange(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
  }


  virtual ~ListDoctorJobsRequestEndRange() = default;
};
class ListDoctorJobsRequestStartRange : public Darabonba::Model {
public:
  shared_ptr<long> endTime{};
  shared_ptr<long> startTime{};

  ListDoctorJobsRequestStartRange() {}

  explicit ListDoctorJobsRequestStartRange(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
  }


  virtual ~ListDoctorJobsRequestStartRange() = default;
};
class ListDoctorJobsRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> appIds{};
  shared_ptr<string> clusterId{};
  shared_ptr<ListDoctorJobsRequestEndRange> endRange{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> orderBy{};
  shared_ptr<string> orderType{};
  shared_ptr<vector<string>> queues{};
  shared_ptr<string> regionId{};
  shared_ptr<ListDoctorJobsRequestStartRange> startRange{};
  shared_ptr<vector<string>> types{};
  shared_ptr<vector<string>> users{};

  ListDoctorJobsRequest() {}

  explicit ListDoctorJobsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appIds) {
      res["AppIds"] = boost::any(*appIds);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (endRange) {
      res["EndRange"] = endRange ? boost::any(endRange->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (orderBy) {
      res["OrderBy"] = boost::any(*orderBy);
    }
    if (orderType) {
      res["OrderType"] = boost::any(*orderType);
    }
    if (queues) {
      res["Queues"] = boost::any(*queues);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (startRange) {
      res["StartRange"] = startRange ? boost::any(startRange->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (types) {
      res["Types"] = boost::any(*types);
    }
    if (users) {
      res["Users"] = boost::any(*users);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppIds") != m.end() && !m["AppIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["AppIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["AppIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      appIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("EndRange") != m.end() && !m["EndRange"].empty()) {
      if (typeid(map<string, boost::any>) == m["EndRange"].type()) {
        ListDoctorJobsRequestEndRange model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EndRange"]));
        endRange = make_shared<ListDoctorJobsRequestEndRange>(model1);
      }
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("OrderBy") != m.end() && !m["OrderBy"].empty()) {
      orderBy = make_shared<string>(boost::any_cast<string>(m["OrderBy"]));
    }
    if (m.find("OrderType") != m.end() && !m["OrderType"].empty()) {
      orderType = make_shared<string>(boost::any_cast<string>(m["OrderType"]));
    }
    if (m.find("Queues") != m.end() && !m["Queues"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Queues"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Queues"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      queues = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("StartRange") != m.end() && !m["StartRange"].empty()) {
      if (typeid(map<string, boost::any>) == m["StartRange"].type()) {
        ListDoctorJobsRequestStartRange model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["StartRange"]));
        startRange = make_shared<ListDoctorJobsRequestStartRange>(model1);
      }
    }
    if (m.find("Types") != m.end() && !m["Types"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Types"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Types"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      types = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Users") != m.end() && !m["Users"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Users"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Users"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      users = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListDoctorJobsRequest() = default;
};
class ListDoctorJobsResponseBodyDataMetricsMemSeconds : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  ListDoctorJobsResponseBodyDataMetricsMemSeconds() {}

  explicit ListDoctorJobsResponseBodyDataMetricsMemSeconds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~ListDoctorJobsResponseBodyDataMetricsMemSeconds() = default;
};
class ListDoctorJobsResponseBodyDataMetricsVcoreSeconds : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  ListDoctorJobsResponseBodyDataMetricsVcoreSeconds() {}

  explicit ListDoctorJobsResponseBodyDataMetricsVcoreSeconds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~ListDoctorJobsResponseBodyDataMetricsVcoreSeconds() = default;
};
class ListDoctorJobsResponseBodyDataMetrics : public Darabonba::Model {
public:
  shared_ptr<ListDoctorJobsResponseBodyDataMetricsMemSeconds> memSeconds{};
  shared_ptr<ListDoctorJobsResponseBodyDataMetricsVcoreSeconds> vcoreSeconds{};

  ListDoctorJobsResponseBodyDataMetrics() {}

  explicit ListDoctorJobsResponseBodyDataMetrics(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (memSeconds) {
      res["MemSeconds"] = memSeconds ? boost::any(memSeconds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (vcoreSeconds) {
      res["VcoreSeconds"] = vcoreSeconds ? boost::any(vcoreSeconds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MemSeconds") != m.end() && !m["MemSeconds"].empty()) {
      if (typeid(map<string, boost::any>) == m["MemSeconds"].type()) {
        ListDoctorJobsResponseBodyDataMetricsMemSeconds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MemSeconds"]));
        memSeconds = make_shared<ListDoctorJobsResponseBodyDataMetricsMemSeconds>(model1);
      }
    }
    if (m.find("VcoreSeconds") != m.end() && !m["VcoreSeconds"].empty()) {
      if (typeid(map<string, boost::any>) == m["VcoreSeconds"].type()) {
        ListDoctorJobsResponseBodyDataMetricsVcoreSeconds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VcoreSeconds"]));
        vcoreSeconds = make_shared<ListDoctorJobsResponseBodyDataMetricsVcoreSeconds>(model1);
      }
    }
  }


  virtual ~ListDoctorJobsResponseBodyDataMetrics() = default;
};
class ListDoctorJobsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> appName{};
  shared_ptr<long> elapsedTime{};
  shared_ptr<string> finalStatus{};
  shared_ptr<long> finishTime{};
  shared_ptr<long> launchTime{};
  shared_ptr<ListDoctorJobsResponseBodyDataMetrics> metrics{};
  shared_ptr<string> queue{};
  shared_ptr<long> startTime{};
  shared_ptr<string> state{};
  shared_ptr<string> type{};
  shared_ptr<string> user{};

  ListDoctorJobsResponseBodyData() {}

  explicit ListDoctorJobsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (elapsedTime) {
      res["ElapsedTime"] = boost::any(*elapsedTime);
    }
    if (finalStatus) {
      res["FinalStatus"] = boost::any(*finalStatus);
    }
    if (finishTime) {
      res["FinishTime"] = boost::any(*finishTime);
    }
    if (launchTime) {
      res["LaunchTime"] = boost::any(*launchTime);
    }
    if (metrics) {
      res["Metrics"] = metrics ? boost::any(metrics->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (queue) {
      res["Queue"] = boost::any(*queue);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (user) {
      res["User"] = boost::any(*user);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("ElapsedTime") != m.end() && !m["ElapsedTime"].empty()) {
      elapsedTime = make_shared<long>(boost::any_cast<long>(m["ElapsedTime"]));
    }
    if (m.find("FinalStatus") != m.end() && !m["FinalStatus"].empty()) {
      finalStatus = make_shared<string>(boost::any_cast<string>(m["FinalStatus"]));
    }
    if (m.find("FinishTime") != m.end() && !m["FinishTime"].empty()) {
      finishTime = make_shared<long>(boost::any_cast<long>(m["FinishTime"]));
    }
    if (m.find("LaunchTime") != m.end() && !m["LaunchTime"].empty()) {
      launchTime = make_shared<long>(boost::any_cast<long>(m["LaunchTime"]));
    }
    if (m.find("Metrics") != m.end() && !m["Metrics"].empty()) {
      if (typeid(map<string, boost::any>) == m["Metrics"].type()) {
        ListDoctorJobsResponseBodyDataMetrics model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Metrics"]));
        metrics = make_shared<ListDoctorJobsResponseBodyDataMetrics>(model1);
      }
    }
    if (m.find("Queue") != m.end() && !m["Queue"].empty()) {
      queue = make_shared<string>(boost::any_cast<string>(m["Queue"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("User") != m.end() && !m["User"].empty()) {
      user = make_shared<string>(boost::any_cast<string>(m["User"]));
    }
  }


  virtual ~ListDoctorJobsResponseBodyData() = default;
};
class ListDoctorJobsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListDoctorJobsResponseBodyData>> data{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ListDoctorJobsResponseBody() {}

  explicit ListDoctorJobsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<ListDoctorJobsResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDoctorJobsResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListDoctorJobsResponseBodyData>>(expect1);
      }
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListDoctorJobsResponseBody() = default;
};
class ListDoctorJobsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListDoctorJobsResponseBody> body{};

  ListDoctorJobsResponse() {}

  explicit ListDoctorJobsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListDoctorJobsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListDoctorJobsResponseBody>(model1);
      }
    }
  }


  virtual ~ListDoctorJobsResponse() = default;
};
class ListDoctorJobsStatsRequestEndRange : public Darabonba::Model {
public:
  shared_ptr<long> endTime{};
  shared_ptr<long> startTime{};

  ListDoctorJobsStatsRequestEndRange() {}

  explicit ListDoctorJobsStatsRequestEndRange(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
  }


  virtual ~ListDoctorJobsStatsRequestEndRange() = default;
};
class ListDoctorJobsStatsRequestStartRange : public Darabonba::Model {
public:
  shared_ptr<long> endTime{};
  shared_ptr<long> startTime{};

  ListDoctorJobsStatsRequestStartRange() {}

  explicit ListDoctorJobsStatsRequestStartRange(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
  }


  virtual ~ListDoctorJobsStatsRequestStartRange() = default;
};
class ListDoctorJobsStatsRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<ListDoctorJobsStatsRequestEndRange> endRange{};
  shared_ptr<vector<string>> groupBy{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> orderBy{};
  shared_ptr<string> orderType{};
  shared_ptr<string> regionId{};
  shared_ptr<ListDoctorJobsStatsRequestStartRange> startRange{};

  ListDoctorJobsStatsRequest() {}

  explicit ListDoctorJobsStatsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (endRange) {
      res["EndRange"] = endRange ? boost::any(endRange->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (groupBy) {
      res["GroupBy"] = boost::any(*groupBy);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (orderBy) {
      res["OrderBy"] = boost::any(*orderBy);
    }
    if (orderType) {
      res["OrderType"] = boost::any(*orderType);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (startRange) {
      res["StartRange"] = startRange ? boost::any(startRange->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("EndRange") != m.end() && !m["EndRange"].empty()) {
      if (typeid(map<string, boost::any>) == m["EndRange"].type()) {
        ListDoctorJobsStatsRequestEndRange model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EndRange"]));
        endRange = make_shared<ListDoctorJobsStatsRequestEndRange>(model1);
      }
    }
    if (m.find("GroupBy") != m.end() && !m["GroupBy"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["GroupBy"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["GroupBy"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      groupBy = make_shared<vector<string>>(toVec1);
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("OrderBy") != m.end() && !m["OrderBy"].empty()) {
      orderBy = make_shared<string>(boost::any_cast<string>(m["OrderBy"]));
    }
    if (m.find("OrderType") != m.end() && !m["OrderType"].empty()) {
      orderType = make_shared<string>(boost::any_cast<string>(m["OrderType"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("StartRange") != m.end() && !m["StartRange"].empty()) {
      if (typeid(map<string, boost::any>) == m["StartRange"].type()) {
        ListDoctorJobsStatsRequestStartRange model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["StartRange"]));
        startRange = make_shared<ListDoctorJobsStatsRequestStartRange>(model1);
      }
    }
  }


  virtual ~ListDoctorJobsStatsRequest() = default;
};
class ListDoctorJobsStatsResponseBodyDataAppsCount : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  ListDoctorJobsStatsResponseBodyDataAppsCount() {}

  explicit ListDoctorJobsStatsResponseBodyDataAppsCount(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~ListDoctorJobsStatsResponseBodyDataAppsCount() = default;
};
class ListDoctorJobsStatsResponseBodyDataMemSeconds : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  ListDoctorJobsStatsResponseBodyDataMemSeconds() {}

  explicit ListDoctorJobsStatsResponseBodyDataMemSeconds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~ListDoctorJobsStatsResponseBodyDataMemSeconds() = default;
};
class ListDoctorJobsStatsResponseBodyDataVcoreSeconds : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  ListDoctorJobsStatsResponseBodyDataVcoreSeconds() {}

  explicit ListDoctorJobsStatsResponseBodyDataVcoreSeconds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~ListDoctorJobsStatsResponseBodyDataVcoreSeconds() = default;
};
class ListDoctorJobsStatsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<ListDoctorJobsStatsResponseBodyDataAppsCount> appsCount{};
  shared_ptr<ListDoctorJobsStatsResponseBodyDataMemSeconds> memSeconds{};
  shared_ptr<string> queue{};
  shared_ptr<string> type{};
  shared_ptr<string> user{};
  shared_ptr<ListDoctorJobsStatsResponseBodyDataVcoreSeconds> vcoreSeconds{};

  ListDoctorJobsStatsResponseBodyData() {}

  explicit ListDoctorJobsStatsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appsCount) {
      res["AppsCount"] = appsCount ? boost::any(appsCount->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (memSeconds) {
      res["MemSeconds"] = memSeconds ? boost::any(memSeconds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (queue) {
      res["Queue"] = boost::any(*queue);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (user) {
      res["User"] = boost::any(*user);
    }
    if (vcoreSeconds) {
      res["VcoreSeconds"] = vcoreSeconds ? boost::any(vcoreSeconds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppsCount") != m.end() && !m["AppsCount"].empty()) {
      if (typeid(map<string, boost::any>) == m["AppsCount"].type()) {
        ListDoctorJobsStatsResponseBodyDataAppsCount model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AppsCount"]));
        appsCount = make_shared<ListDoctorJobsStatsResponseBodyDataAppsCount>(model1);
      }
    }
    if (m.find("MemSeconds") != m.end() && !m["MemSeconds"].empty()) {
      if (typeid(map<string, boost::any>) == m["MemSeconds"].type()) {
        ListDoctorJobsStatsResponseBodyDataMemSeconds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MemSeconds"]));
        memSeconds = make_shared<ListDoctorJobsStatsResponseBodyDataMemSeconds>(model1);
      }
    }
    if (m.find("Queue") != m.end() && !m["Queue"].empty()) {
      queue = make_shared<string>(boost::any_cast<string>(m["Queue"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("User") != m.end() && !m["User"].empty()) {
      user = make_shared<string>(boost::any_cast<string>(m["User"]));
    }
    if (m.find("VcoreSeconds") != m.end() && !m["VcoreSeconds"].empty()) {
      if (typeid(map<string, boost::any>) == m["VcoreSeconds"].type()) {
        ListDoctorJobsStatsResponseBodyDataVcoreSeconds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VcoreSeconds"]));
        vcoreSeconds = make_shared<ListDoctorJobsStatsResponseBodyDataVcoreSeconds>(model1);
      }
    }
  }


  virtual ~ListDoctorJobsStatsResponseBodyData() = default;
};
class ListDoctorJobsStatsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListDoctorJobsStatsResponseBodyData>> data{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ListDoctorJobsStatsResponseBody() {}

  explicit ListDoctorJobsStatsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<ListDoctorJobsStatsResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDoctorJobsStatsResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListDoctorJobsStatsResponseBodyData>>(expect1);
      }
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListDoctorJobsStatsResponseBody() = default;
};
class ListDoctorJobsStatsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListDoctorJobsStatsResponseBody> body{};

  ListDoctorJobsStatsResponse() {}

  explicit ListDoctorJobsStatsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListDoctorJobsStatsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListDoctorJobsStatsResponseBody>(model1);
      }
    }
  }


  virtual ~ListDoctorJobsStatsResponse() = default;
};
class ListDoctorReportsRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> regionId{};

  ListDoctorReportsRequest() {}

  explicit ListDoctorReportsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~ListDoctorReportsRequest() = default;
};
class ListDoctorReportsResponseBodyDataSummaryReport : public Darabonba::Model {
public:
  shared_ptr<long> score{};
  shared_ptr<string> suggestion{};
  shared_ptr<string> summary{};

  ListDoctorReportsResponseBodyDataSummaryReport() {}

  explicit ListDoctorReportsResponseBodyDataSummaryReport(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (score) {
      res["Score"] = boost::any(*score);
    }
    if (suggestion) {
      res["Suggestion"] = boost::any(*suggestion);
    }
    if (summary) {
      res["Summary"] = boost::any(*summary);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Score") != m.end() && !m["Score"].empty()) {
      score = make_shared<long>(boost::any_cast<long>(m["Score"]));
    }
    if (m.find("Suggestion") != m.end() && !m["Suggestion"].empty()) {
      suggestion = make_shared<string>(boost::any_cast<string>(m["Suggestion"]));
    }
    if (m.find("Summary") != m.end() && !m["Summary"].empty()) {
      summary = make_shared<string>(boost::any_cast<string>(m["Summary"]));
    }
  }


  virtual ~ListDoctorReportsResponseBodyDataSummaryReport() = default;
};
class ListDoctorReportsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<string>> componentTypes{};
  shared_ptr<string> dateTime{};
  shared_ptr<ListDoctorReportsResponseBodyDataSummaryReport> summaryReport{};

  ListDoctorReportsResponseBodyData() {}

  explicit ListDoctorReportsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (componentTypes) {
      res["ComponentTypes"] = boost::any(*componentTypes);
    }
    if (dateTime) {
      res["DateTime"] = boost::any(*dateTime);
    }
    if (summaryReport) {
      res["SummaryReport"] = summaryReport ? boost::any(summaryReport->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ComponentTypes") != m.end() && !m["ComponentTypes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ComponentTypes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ComponentTypes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      componentTypes = make_shared<vector<string>>(toVec1);
    }
    if (m.find("DateTime") != m.end() && !m["DateTime"].empty()) {
      dateTime = make_shared<string>(boost::any_cast<string>(m["DateTime"]));
    }
    if (m.find("SummaryReport") != m.end() && !m["SummaryReport"].empty()) {
      if (typeid(map<string, boost::any>) == m["SummaryReport"].type()) {
        ListDoctorReportsResponseBodyDataSummaryReport model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SummaryReport"]));
        summaryReport = make_shared<ListDoctorReportsResponseBodyDataSummaryReport>(model1);
      }
    }
  }


  virtual ~ListDoctorReportsResponseBodyData() = default;
};
class ListDoctorReportsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListDoctorReportsResponseBodyData>> data{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ListDoctorReportsResponseBody() {}

  explicit ListDoctorReportsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<ListDoctorReportsResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDoctorReportsResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListDoctorReportsResponseBodyData>>(expect1);
      }
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListDoctorReportsResponseBody() = default;
};
class ListDoctorReportsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListDoctorReportsResponseBody> body{};

  ListDoctorReportsResponse() {}

  explicit ListDoctorReportsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListDoctorReportsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListDoctorReportsResponseBody>(model1);
      }
    }
  }


  virtual ~ListDoctorReportsResponse() = default;
};
class ListInspectionHistoryRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> component{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> language{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> regionId{};
  shared_ptr<string> service{};
  shared_ptr<string> type{};

  ListInspectionHistoryRequest() {}

  explicit ListInspectionHistoryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (component) {
      res["Component"] = boost::any(*component);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (language) {
      res["Language"] = boost::any(*language);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (service) {
      res["Service"] = boost::any(*service);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("Component") != m.end() && !m["Component"].empty()) {
      component = make_shared<string>(boost::any_cast<string>(m["Component"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Language") != m.end() && !m["Language"].empty()) {
      language = make_shared<string>(boost::any_cast<string>(m["Language"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Service") != m.end() && !m["Service"].empty()) {
      service = make_shared<string>(boost::any_cast<string>(m["Service"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListInspectionHistoryRequest() = default;
};
class ListInspectionHistoryResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> changeMessage{};
  shared_ptr<string> healthStatus{};
  shared_ptr<vector<map<string, string>>> inspectionItems{};
  shared_ptr<string> reportTime{};

  ListInspectionHistoryResponseBodyData() {}

  explicit ListInspectionHistoryResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (changeMessage) {
      res["ChangeMessage"] = boost::any(*changeMessage);
    }
    if (healthStatus) {
      res["HealthStatus"] = boost::any(*healthStatus);
    }
    if (inspectionItems) {
      res["InspectionItems"] = boost::any(*inspectionItems);
    }
    if (reportTime) {
      res["ReportTime"] = boost::any(*reportTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChangeMessage") != m.end() && !m["ChangeMessage"].empty()) {
      changeMessage = make_shared<string>(boost::any_cast<string>(m["ChangeMessage"]));
    }
    if (m.find("HealthStatus") != m.end() && !m["HealthStatus"].empty()) {
      healthStatus = make_shared<string>(boost::any_cast<string>(m["HealthStatus"]));
    }
    if (m.find("InspectionItems") != m.end() && !m["InspectionItems"].empty()) {
      vector<map<string, string>> toVec1;
      if (typeid(vector<boost::any>) == m["InspectionItems"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InspectionItems"]);
        for (auto item:vec1) {
          map<string, string> map2 = boost::any_cast<map<string, string>>(item);
          map<string, string> toMap2;
          for (auto item:map2) {
             toMap2[item.first] = item.second;
          }
           toVec1.push_back(toMap2);
        }
      }
      inspectionItems = make_shared<vector<map<string, string>>>(toVec1);
    }
    if (m.find("ReportTime") != m.end() && !m["ReportTime"].empty()) {
      reportTime = make_shared<string>(boost::any_cast<string>(m["ReportTime"]));
    }
  }


  virtual ~ListInspectionHistoryResponseBodyData() = default;
};
class ListInspectionHistoryResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListInspectionHistoryResponseBodyData>> data{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ListInspectionHistoryResponseBody() {}

  explicit ListInspectionHistoryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<ListInspectionHistoryResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListInspectionHistoryResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListInspectionHistoryResponseBodyData>>(expect1);
      }
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListInspectionHistoryResponseBody() = default;
};
class ListInspectionHistoryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListInspectionHistoryResponseBody> body{};

  ListInspectionHistoryResponse() {}

  explicit ListInspectionHistoryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListInspectionHistoryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListInspectionHistoryResponseBody>(model1);
      }
    }
  }


  virtual ~ListInspectionHistoryResponse() = default;
};
class ListInstanceTypesRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> clusterType{};
  shared_ptr<string> deployMode{};
  shared_ptr<string> instanceType{};
  shared_ptr<bool> isModification{};
  shared_ptr<string> nodeGroupId{};
  shared_ptr<string> nodeGroupType{};
  shared_ptr<string> paymentType{};
  shared_ptr<string> regionId{};
  shared_ptr<string> releaseVersion{};
  shared_ptr<string> zoneId{};

  ListInstanceTypesRequest() {}

  explicit ListInstanceTypesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (clusterType) {
      res["ClusterType"] = boost::any(*clusterType);
    }
    if (deployMode) {
      res["DeployMode"] = boost::any(*deployMode);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (isModification) {
      res["IsModification"] = boost::any(*isModification);
    }
    if (nodeGroupId) {
      res["NodeGroupId"] = boost::any(*nodeGroupId);
    }
    if (nodeGroupType) {
      res["NodeGroupType"] = boost::any(*nodeGroupType);
    }
    if (paymentType) {
      res["PaymentType"] = boost::any(*paymentType);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (releaseVersion) {
      res["ReleaseVersion"] = boost::any(*releaseVersion);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("ClusterType") != m.end() && !m["ClusterType"].empty()) {
      clusterType = make_shared<string>(boost::any_cast<string>(m["ClusterType"]));
    }
    if (m.find("DeployMode") != m.end() && !m["DeployMode"].empty()) {
      deployMode = make_shared<string>(boost::any_cast<string>(m["DeployMode"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("IsModification") != m.end() && !m["IsModification"].empty()) {
      isModification = make_shared<bool>(boost::any_cast<bool>(m["IsModification"]));
    }
    if (m.find("NodeGroupId") != m.end() && !m["NodeGroupId"].empty()) {
      nodeGroupId = make_shared<string>(boost::any_cast<string>(m["NodeGroupId"]));
    }
    if (m.find("NodeGroupType") != m.end() && !m["NodeGroupType"].empty()) {
      nodeGroupType = make_shared<string>(boost::any_cast<string>(m["NodeGroupType"]));
    }
    if (m.find("PaymentType") != m.end() && !m["PaymentType"].empty()) {
      paymentType = make_shared<string>(boost::any_cast<string>(m["PaymentType"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ReleaseVersion") != m.end() && !m["ReleaseVersion"].empty()) {
      releaseVersion = make_shared<string>(boost::any_cast<string>(m["ReleaseVersion"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
  }


  virtual ~ListInstanceTypesRequest() = default;
};
class ListInstanceTypesResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<InstanceType>> instanceTypes{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ListInstanceTypesResponseBody() {}

  explicit ListInstanceTypesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceTypes) {
      vector<boost::any> temp1;
      for(auto item1:*instanceTypes){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InstanceTypes"] = boost::any(temp1);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceTypes") != m.end() && !m["InstanceTypes"].empty()) {
      if (typeid(vector<boost::any>) == m["InstanceTypes"].type()) {
        vector<InstanceType> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InstanceTypes"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            InstanceType model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        instanceTypes = make_shared<vector<InstanceType>>(expect1);
      }
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListInstanceTypesResponseBody() = default;
};
class ListInstanceTypesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListInstanceTypesResponseBody> body{};

  ListInstanceTypesResponse() {}

  explicit ListInstanceTypesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListInstanceTypesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListInstanceTypesResponseBody>(model1);
      }
    }
  }


  virtual ~ListInstanceTypesResponse() = default;
};
class ListNodeGroupsRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<vector<string>> nodeGroupIds{};
  shared_ptr<vector<string>> nodeGroupNames{};
  shared_ptr<vector<string>> nodeGroupStates{};
  shared_ptr<vector<string>> nodeGroupTypes{};
  shared_ptr<string> regionId{};

  ListNodeGroupsRequest() {}

  explicit ListNodeGroupsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (nodeGroupIds) {
      res["NodeGroupIds"] = boost::any(*nodeGroupIds);
    }
    if (nodeGroupNames) {
      res["NodeGroupNames"] = boost::any(*nodeGroupNames);
    }
    if (nodeGroupStates) {
      res["NodeGroupStates"] = boost::any(*nodeGroupStates);
    }
    if (nodeGroupTypes) {
      res["NodeGroupTypes"] = boost::any(*nodeGroupTypes);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("NodeGroupIds") != m.end() && !m["NodeGroupIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["NodeGroupIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["NodeGroupIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      nodeGroupIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("NodeGroupNames") != m.end() && !m["NodeGroupNames"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["NodeGroupNames"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["NodeGroupNames"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      nodeGroupNames = make_shared<vector<string>>(toVec1);
    }
    if (m.find("NodeGroupStates") != m.end() && !m["NodeGroupStates"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["NodeGroupStates"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["NodeGroupStates"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      nodeGroupStates = make_shared<vector<string>>(toVec1);
    }
    if (m.find("NodeGroupTypes") != m.end() && !m["NodeGroupTypes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["NodeGroupTypes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["NodeGroupTypes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      nodeGroupTypes = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~ListNodeGroupsRequest() = default;
};
class ListNodeGroupsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<vector<NodeGroup>> nodeGroups{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ListNodeGroupsResponseBody() {}

  explicit ListNodeGroupsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (nodeGroups) {
      vector<boost::any> temp1;
      for(auto item1:*nodeGroups){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NodeGroups"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("NodeGroups") != m.end() && !m["NodeGroups"].empty()) {
      if (typeid(vector<boost::any>) == m["NodeGroups"].type()) {
        vector<NodeGroup> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NodeGroups"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            NodeGroup model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        nodeGroups = make_shared<vector<NodeGroup>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListNodeGroupsResponseBody() = default;
};
class ListNodeGroupsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListNodeGroupsResponseBody> body{};

  ListNodeGroupsResponse() {}

  explicit ListNodeGroupsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListNodeGroupsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListNodeGroupsResponseBody>(model1);
      }
    }
  }


  virtual ~ListNodeGroupsResponse() = default;
};
class ListNodesRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<vector<string>> nodeGroupIds{};
  shared_ptr<vector<string>> nodeIds{};
  shared_ptr<vector<string>> nodeNames{};
  shared_ptr<vector<string>> nodeStates{};
  shared_ptr<vector<string>> privateIps{};
  shared_ptr<vector<string>> publicIps{};
  shared_ptr<string> regionId{};
  shared_ptr<vector<Tag>> tags{};

  ListNodesRequest() {}

  explicit ListNodesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (nodeGroupIds) {
      res["NodeGroupIds"] = boost::any(*nodeGroupIds);
    }
    if (nodeIds) {
      res["NodeIds"] = boost::any(*nodeIds);
    }
    if (nodeNames) {
      res["NodeNames"] = boost::any(*nodeNames);
    }
    if (nodeStates) {
      res["NodeStates"] = boost::any(*nodeStates);
    }
    if (privateIps) {
      res["PrivateIps"] = boost::any(*privateIps);
    }
    if (publicIps) {
      res["PublicIps"] = boost::any(*publicIps);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("NodeGroupIds") != m.end() && !m["NodeGroupIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["NodeGroupIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["NodeGroupIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      nodeGroupIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("NodeIds") != m.end() && !m["NodeIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["NodeIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["NodeIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      nodeIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("NodeNames") != m.end() && !m["NodeNames"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["NodeNames"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["NodeNames"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      nodeNames = make_shared<vector<string>>(toVec1);
    }
    if (m.find("NodeStates") != m.end() && !m["NodeStates"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["NodeStates"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["NodeStates"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      nodeStates = make_shared<vector<string>>(toVec1);
    }
    if (m.find("PrivateIps") != m.end() && !m["PrivateIps"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["PrivateIps"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["PrivateIps"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      privateIps = make_shared<vector<string>>(toVec1);
    }
    if (m.find("PublicIps") != m.end() && !m["PublicIps"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["PublicIps"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["PublicIps"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      publicIps = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<Tag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            Tag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<Tag>>(expect1);
      }
    }
  }


  virtual ~ListNodesRequest() = default;
};
class ListNodesResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<vector<Node>> nodes{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ListNodesResponseBody() {}

  explicit ListNodesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (nodes) {
      vector<boost::any> temp1;
      for(auto item1:*nodes){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Nodes"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("Nodes") != m.end() && !m["Nodes"].empty()) {
      if (typeid(vector<boost::any>) == m["Nodes"].type()) {
        vector<Node> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Nodes"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            Node model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        nodes = make_shared<vector<Node>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListNodesResponseBody() = default;
};
class ListNodesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListNodesResponseBody> body{};

  ListNodesResponse() {}

  explicit ListNodesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListNodesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListNodesResponseBody>(model1);
      }
    }
  }


  virtual ~ListNodesResponse() = default;
};
class ListReleaseVersionsRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterType{};
  shared_ptr<string> iaasType{};
  shared_ptr<string> regionId{};

  ListReleaseVersionsRequest() {}

  explicit ListReleaseVersionsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterType) {
      res["ClusterType"] = boost::any(*clusterType);
    }
    if (iaasType) {
      res["IaasType"] = boost::any(*iaasType);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterType") != m.end() && !m["ClusterType"].empty()) {
      clusterType = make_shared<string>(boost::any_cast<string>(m["ClusterType"]));
    }
    if (m.find("IaasType") != m.end() && !m["IaasType"].empty()) {
      iaasType = make_shared<string>(boost::any_cast<string>(m["IaasType"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~ListReleaseVersionsRequest() = default;
};
class ListReleaseVersionsResponseBodyReleaseVersions : public Darabonba::Model {
public:
  shared_ptr<string> iaasType{};
  shared_ptr<string> releaseVersion{};
  shared_ptr<string> series{};

  ListReleaseVersionsResponseBodyReleaseVersions() {}

  explicit ListReleaseVersionsResponseBodyReleaseVersions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iaasType) {
      res["IaasType"] = boost::any(*iaasType);
    }
    if (releaseVersion) {
      res["ReleaseVersion"] = boost::any(*releaseVersion);
    }
    if (series) {
      res["Series"] = boost::any(*series);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IaasType") != m.end() && !m["IaasType"].empty()) {
      iaasType = make_shared<string>(boost::any_cast<string>(m["IaasType"]));
    }
    if (m.find("ReleaseVersion") != m.end() && !m["ReleaseVersion"].empty()) {
      releaseVersion = make_shared<string>(boost::any_cast<string>(m["ReleaseVersion"]));
    }
    if (m.find("Series") != m.end() && !m["Series"].empty()) {
      series = make_shared<string>(boost::any_cast<string>(m["Series"]));
    }
  }


  virtual ~ListReleaseVersionsResponseBodyReleaseVersions() = default;
};
class ListReleaseVersionsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<vector<ListReleaseVersionsResponseBodyReleaseVersions>> releaseVersions{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ListReleaseVersionsResponseBody() {}

  explicit ListReleaseVersionsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (releaseVersions) {
      vector<boost::any> temp1;
      for(auto item1:*releaseVersions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ReleaseVersions"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("ReleaseVersions") != m.end() && !m["ReleaseVersions"].empty()) {
      if (typeid(vector<boost::any>) == m["ReleaseVersions"].type()) {
        vector<ListReleaseVersionsResponseBodyReleaseVersions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ReleaseVersions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListReleaseVersionsResponseBodyReleaseVersions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        releaseVersions = make_shared<vector<ListReleaseVersionsResponseBodyReleaseVersions>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListReleaseVersionsResponseBody() = default;
};
class ListReleaseVersionsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListReleaseVersionsResponseBody> body{};

  ListReleaseVersionsResponse() {}

  explicit ListReleaseVersionsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListReleaseVersionsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListReleaseVersionsResponseBody>(model1);
      }
    }
  }


  virtual ~ListReleaseVersionsResponse() = default;
};
class ListResourceHealthInspectionsRequest : public Darabonba::Model {
public:
  shared_ptr<string> applicationName{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> componentName{};
  shared_ptr<vector<string>> healthStatuses{};
  shared_ptr<string> language{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<vector<string>> nodeIds{};
  shared_ptr<vector<string>> nodeNames{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceType{};

  ListResourceHealthInspectionsRequest() {}

  explicit ListResourceHealthInspectionsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applicationName) {
      res["ApplicationName"] = boost::any(*applicationName);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (componentName) {
      res["ComponentName"] = boost::any(*componentName);
    }
    if (healthStatuses) {
      res["HealthStatuses"] = boost::any(*healthStatuses);
    }
    if (language) {
      res["Language"] = boost::any(*language);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (nodeIds) {
      res["NodeIds"] = boost::any(*nodeIds);
    }
    if (nodeNames) {
      res["NodeNames"] = boost::any(*nodeNames);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApplicationName") != m.end() && !m["ApplicationName"].empty()) {
      applicationName = make_shared<string>(boost::any_cast<string>(m["ApplicationName"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("ComponentName") != m.end() && !m["ComponentName"].empty()) {
      componentName = make_shared<string>(boost::any_cast<string>(m["ComponentName"]));
    }
    if (m.find("HealthStatuses") != m.end() && !m["HealthStatuses"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["HealthStatuses"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["HealthStatuses"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      healthStatuses = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Language") != m.end() && !m["Language"].empty()) {
      language = make_shared<string>(boost::any_cast<string>(m["Language"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("NodeIds") != m.end() && !m["NodeIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["NodeIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["NodeIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      nodeIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("NodeNames") != m.end() && !m["NodeNames"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["NodeNames"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["NodeNames"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      nodeNames = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
  }


  virtual ~ListResourceHealthInspectionsRequest() = default;
};
class ListResourceHealthInspectionsResponseBodyHealthInspections : public Darabonba::Model {
public:
  shared_ptr<string> applicationName{};
  shared_ptr<string> componentName{};
  shared_ptr<string> healthMessage{};
  shared_ptr<string> healthStatus{};
  shared_ptr<string> inspectionName{};
  shared_ptr<string> nodeId{};
  shared_ptr<string> nodeName{};
  shared_ptr<long> reportTime{};
  shared_ptr<string> ruleName{};

  ListResourceHealthInspectionsResponseBodyHealthInspections() {}

  explicit ListResourceHealthInspectionsResponseBodyHealthInspections(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applicationName) {
      res["ApplicationName"] = boost::any(*applicationName);
    }
    if (componentName) {
      res["ComponentName"] = boost::any(*componentName);
    }
    if (healthMessage) {
      res["HealthMessage"] = boost::any(*healthMessage);
    }
    if (healthStatus) {
      res["HealthStatus"] = boost::any(*healthStatus);
    }
    if (inspectionName) {
      res["InspectionName"] = boost::any(*inspectionName);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (nodeName) {
      res["NodeName"] = boost::any(*nodeName);
    }
    if (reportTime) {
      res["ReportTime"] = boost::any(*reportTime);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApplicationName") != m.end() && !m["ApplicationName"].empty()) {
      applicationName = make_shared<string>(boost::any_cast<string>(m["ApplicationName"]));
    }
    if (m.find("ComponentName") != m.end() && !m["ComponentName"].empty()) {
      componentName = make_shared<string>(boost::any_cast<string>(m["ComponentName"]));
    }
    if (m.find("HealthMessage") != m.end() && !m["HealthMessage"].empty()) {
      healthMessage = make_shared<string>(boost::any_cast<string>(m["HealthMessage"]));
    }
    if (m.find("HealthStatus") != m.end() && !m["HealthStatus"].empty()) {
      healthStatus = make_shared<string>(boost::any_cast<string>(m["HealthStatus"]));
    }
    if (m.find("InspectionName") != m.end() && !m["InspectionName"].empty()) {
      inspectionName = make_shared<string>(boost::any_cast<string>(m["InspectionName"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<string>(boost::any_cast<string>(m["NodeId"]));
    }
    if (m.find("NodeName") != m.end() && !m["NodeName"].empty()) {
      nodeName = make_shared<string>(boost::any_cast<string>(m["NodeName"]));
    }
    if (m.find("ReportTime") != m.end() && !m["ReportTime"].empty()) {
      reportTime = make_shared<long>(boost::any_cast<long>(m["ReportTime"]));
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
  }


  virtual ~ListResourceHealthInspectionsResponseBodyHealthInspections() = default;
};
class ListResourceHealthInspectionsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListResourceHealthInspectionsResponseBodyHealthInspections>> healthInspections{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ListResourceHealthInspectionsResponseBody() {}

  explicit ListResourceHealthInspectionsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (healthInspections) {
      vector<boost::any> temp1;
      for(auto item1:*healthInspections){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["HealthInspections"] = boost::any(temp1);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HealthInspections") != m.end() && !m["HealthInspections"].empty()) {
      if (typeid(vector<boost::any>) == m["HealthInspections"].type()) {
        vector<ListResourceHealthInspectionsResponseBodyHealthInspections> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["HealthInspections"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListResourceHealthInspectionsResponseBodyHealthInspections model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        healthInspections = make_shared<vector<ListResourceHealthInspectionsResponseBodyHealthInspections>>(expect1);
      }
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListResourceHealthInspectionsResponseBody() = default;
};
class ListResourceHealthInspectionsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListResourceHealthInspectionsResponseBody> body{};

  ListResourceHealthInspectionsResponse() {}

  explicit ListResourceHealthInspectionsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListResourceHealthInspectionsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListResourceHealthInspectionsResponseBody>(model1);
      }
    }
  }


  virtual ~ListResourceHealthInspectionsResponse() = default;
};
class ListScriptsRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> regionId{};
  shared_ptr<string> scriptType{};

  ListScriptsRequest() {}

  explicit ListScriptsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (scriptType) {
      res["ScriptType"] = boost::any(*scriptType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ScriptType") != m.end() && !m["ScriptType"].empty()) {
      scriptType = make_shared<string>(boost::any_cast<string>(m["ScriptType"]));
    }
  }


  virtual ~ListScriptsRequest() = default;
};
class ListScriptsResponseBodyScripts : public Darabonba::Model {
public:
  shared_ptr<string> action{};
  shared_ptr<long> endTime{};
  shared_ptr<string> executionFailStrategy{};
  shared_ptr<string> executionMoment{};
  shared_ptr<string> executionState{};
  shared_ptr<long> lastUpdateTime{};
  shared_ptr<NodeSelector> nodeSelector{};
  shared_ptr<string> regionId{};
  shared_ptr<string> scriptArgs{};
  shared_ptr<string> scriptId{};
  shared_ptr<string> scriptName{};
  shared_ptr<string> scriptPath{};
  shared_ptr<long> startTime{};

  ListScriptsResponseBodyScripts() {}

  explicit ListScriptsResponseBodyScripts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (action) {
      res["Action"] = boost::any(*action);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (executionFailStrategy) {
      res["ExecutionFailStrategy"] = boost::any(*executionFailStrategy);
    }
    if (executionMoment) {
      res["ExecutionMoment"] = boost::any(*executionMoment);
    }
    if (executionState) {
      res["ExecutionState"] = boost::any(*executionState);
    }
    if (lastUpdateTime) {
      res["LastUpdateTime"] = boost::any(*lastUpdateTime);
    }
    if (nodeSelector) {
      res["NodeSelector"] = nodeSelector ? boost::any(nodeSelector->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (scriptArgs) {
      res["ScriptArgs"] = boost::any(*scriptArgs);
    }
    if (scriptId) {
      res["ScriptId"] = boost::any(*scriptId);
    }
    if (scriptName) {
      res["ScriptName"] = boost::any(*scriptName);
    }
    if (scriptPath) {
      res["ScriptPath"] = boost::any(*scriptPath);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Action") != m.end() && !m["Action"].empty()) {
      action = make_shared<string>(boost::any_cast<string>(m["Action"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("ExecutionFailStrategy") != m.end() && !m["ExecutionFailStrategy"].empty()) {
      executionFailStrategy = make_shared<string>(boost::any_cast<string>(m["ExecutionFailStrategy"]));
    }
    if (m.find("ExecutionMoment") != m.end() && !m["ExecutionMoment"].empty()) {
      executionMoment = make_shared<string>(boost::any_cast<string>(m["ExecutionMoment"]));
    }
    if (m.find("ExecutionState") != m.end() && !m["ExecutionState"].empty()) {
      executionState = make_shared<string>(boost::any_cast<string>(m["ExecutionState"]));
    }
    if (m.find("LastUpdateTime") != m.end() && !m["LastUpdateTime"].empty()) {
      lastUpdateTime = make_shared<long>(boost::any_cast<long>(m["LastUpdateTime"]));
    }
    if (m.find("NodeSelector") != m.end() && !m["NodeSelector"].empty()) {
      if (typeid(map<string, boost::any>) == m["NodeSelector"].type()) {
        NodeSelector model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NodeSelector"]));
        nodeSelector = make_shared<NodeSelector>(model1);
      }
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ScriptArgs") != m.end() && !m["ScriptArgs"].empty()) {
      scriptArgs = make_shared<string>(boost::any_cast<string>(m["ScriptArgs"]));
    }
    if (m.find("ScriptId") != m.end() && !m["ScriptId"].empty()) {
      scriptId = make_shared<string>(boost::any_cast<string>(m["ScriptId"]));
    }
    if (m.find("ScriptName") != m.end() && !m["ScriptName"].empty()) {
      scriptName = make_shared<string>(boost::any_cast<string>(m["ScriptName"]));
    }
    if (m.find("ScriptPath") != m.end() && !m["ScriptPath"].empty()) {
      scriptPath = make_shared<string>(boost::any_cast<string>(m["ScriptPath"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
  }


  virtual ~ListScriptsResponseBodyScripts() = default;
};
class ListScriptsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListScriptsResponseBodyScripts>> scripts{};
  shared_ptr<long> totalCount{};

  ListScriptsResponseBody() {}

  explicit ListScriptsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (scripts) {
      vector<boost::any> temp1;
      for(auto item1:*scripts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Scripts"] = boost::any(temp1);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Scripts") != m.end() && !m["Scripts"].empty()) {
      if (typeid(vector<boost::any>) == m["Scripts"].type()) {
        vector<ListScriptsResponseBodyScripts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Scripts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListScriptsResponseBodyScripts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        scripts = make_shared<vector<ListScriptsResponseBodyScripts>>(expect1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListScriptsResponseBody() = default;
};
class ListScriptsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListScriptsResponseBody> body{};

  ListScriptsResponse() {}

  explicit ListScriptsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListScriptsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListScriptsResponseBody>(model1);
      }
    }
  }


  virtual ~ListScriptsResponse() = default;
};
class ListTagResourcesRequest : public Darabonba::Model {
public:
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> regionId{};
  shared_ptr<vector<string>> resourceIds{};
  shared_ptr<string> resourceType{};
  shared_ptr<vector<Tag>> tags{};

  ListTagResourcesRequest() {}

  explicit ListTagResourcesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceIds) {
      res["ResourceIds"] = boost::any(*resourceIds);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceIds") != m.end() && !m["ResourceIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ResourceIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ResourceIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      resourceIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<Tag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            Tag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<Tag>>(expect1);
      }
    }
  }


  virtual ~ListTagResourcesRequest() = default;
};
class ListTagResourcesResponseBodyTagResources : public Darabonba::Model {
public:
  shared_ptr<string> resourceId{};
  shared_ptr<string> resourceType{};
  shared_ptr<string> tagKey{};
  shared_ptr<string> tagValue{};

  ListTagResourcesResponseBodyTagResources() {}

  explicit ListTagResourcesResponseBodyTagResources(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    if (tagValue) {
      res["TagValue"] = boost::any(*tagValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["TagKey"]));
    }
    if (m.find("TagValue") != m.end() && !m["TagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["TagValue"]));
    }
  }


  virtual ~ListTagResourcesResponseBodyTagResources() = default;
};
class ListTagResourcesResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListTagResourcesResponseBodyTagResources>> tagResources{};
  shared_ptr<long> totalCount{};

  ListTagResourcesResponseBody() {}

  explicit ListTagResourcesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (tagResources) {
      vector<boost::any> temp1;
      for(auto item1:*tagResources){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TagResources"] = boost::any(temp1);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TagResources") != m.end() && !m["TagResources"].empty()) {
      if (typeid(vector<boost::any>) == m["TagResources"].type()) {
        vector<ListTagResourcesResponseBodyTagResources> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TagResources"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListTagResourcesResponseBodyTagResources model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tagResources = make_shared<vector<ListTagResourcesResponseBodyTagResources>>(expect1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListTagResourcesResponseBody() = default;
};
class ListTagResourcesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListTagResourcesResponseBody> body{};

  ListTagResourcesResponse() {}

  explicit ListTagResourcesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListTagResourcesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListTagResourcesResponseBody>(model1);
      }
    }
  }


  virtual ~ListTagResourcesResponse() = default;
};
class PutAutoScalingPolicyRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<ScalingConstraints> constraints{};
  shared_ptr<string> nodeGroupId{};
  shared_ptr<string> regionId{};
  shared_ptr<vector<ScalingRule>> scalingRules{};

  PutAutoScalingPolicyRequest() {}

  explicit PutAutoScalingPolicyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (constraints) {
      res["Constraints"] = constraints ? boost::any(constraints->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (nodeGroupId) {
      res["NodeGroupId"] = boost::any(*nodeGroupId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (scalingRules) {
      vector<boost::any> temp1;
      for(auto item1:*scalingRules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ScalingRules"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("Constraints") != m.end() && !m["Constraints"].empty()) {
      if (typeid(map<string, boost::any>) == m["Constraints"].type()) {
        ScalingConstraints model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Constraints"]));
        constraints = make_shared<ScalingConstraints>(model1);
      }
    }
    if (m.find("NodeGroupId") != m.end() && !m["NodeGroupId"].empty()) {
      nodeGroupId = make_shared<string>(boost::any_cast<string>(m["NodeGroupId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ScalingRules") != m.end() && !m["ScalingRules"].empty()) {
      if (typeid(vector<boost::any>) == m["ScalingRules"].type()) {
        vector<ScalingRule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ScalingRules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ScalingRule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        scalingRules = make_shared<vector<ScalingRule>>(expect1);
      }
    }
  }


  virtual ~PutAutoScalingPolicyRequest() = default;
};
class PutAutoScalingPolicyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  PutAutoScalingPolicyResponseBody() {}

  explicit PutAutoScalingPolicyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~PutAutoScalingPolicyResponseBody() = default;
};
class PutAutoScalingPolicyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<PutAutoScalingPolicyResponseBody> body{};

  PutAutoScalingPolicyResponse() {}

  explicit PutAutoScalingPolicyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        PutAutoScalingPolicyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<PutAutoScalingPolicyResponseBody>(model1);
      }
    }
  }


  virtual ~PutAutoScalingPolicyResponse() = default;
};
class RemoveAutoScalingPolicyRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> nodeGroupId{};
  shared_ptr<string> regionId{};

  RemoveAutoScalingPolicyRequest() {}

  explicit RemoveAutoScalingPolicyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (nodeGroupId) {
      res["NodeGroupId"] = boost::any(*nodeGroupId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("NodeGroupId") != m.end() && !m["NodeGroupId"].empty()) {
      nodeGroupId = make_shared<string>(boost::any_cast<string>(m["NodeGroupId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~RemoveAutoScalingPolicyRequest() = default;
};
class RemoveAutoScalingPolicyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  RemoveAutoScalingPolicyResponseBody() {}

  explicit RemoveAutoScalingPolicyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RemoveAutoScalingPolicyResponseBody() = default;
};
class RemoveAutoScalingPolicyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RemoveAutoScalingPolicyResponseBody> body{};

  RemoveAutoScalingPolicyResponse() {}

  explicit RemoveAutoScalingPolicyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RemoveAutoScalingPolicyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RemoveAutoScalingPolicyResponseBody>(model1);
      }
    }
  }


  virtual ~RemoveAutoScalingPolicyResponse() = default;
};
class RunApiTemplateRequest : public Darabonba::Model {
public:
  shared_ptr<string> apiName{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> regionId{};
  shared_ptr<string> templateId{};

  RunApiTemplateRequest() {}

  explicit RunApiTemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiName) {
      res["ApiName"] = boost::any(*apiName);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiName") != m.end() && !m["ApiName"].empty()) {
      apiName = make_shared<string>(boost::any_cast<string>(m["ApiName"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~RunApiTemplateRequest() = default;
};
class RunApiTemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> data{};
  shared_ptr<string> requestId{};

  RunApiTemplateResponseBody() {}

  explicit RunApiTemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RunApiTemplateResponseBody() = default;
};
class RunApiTemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RunApiTemplateResponseBody> body{};

  RunApiTemplateResponse() {}

  explicit RunApiTemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RunApiTemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RunApiTemplateResponseBody>(model1);
      }
    }
  }


  virtual ~RunApiTemplateResponse() = default;
};
class RunApplicationActionRequest : public Darabonba::Model {
public:
  shared_ptr<string> actionName{};
  shared_ptr<long> batchSize{};
  shared_ptr<string> clusterId{};
  shared_ptr<ComponentInstanceSelector> componentInstanceSelector{};
  shared_ptr<string> description{};
  shared_ptr<string> executeStrategy{};
  shared_ptr<long> interval{};
  shared_ptr<string> regionId{};
  shared_ptr<bool> rollingExecute{};

  RunApplicationActionRequest() {}

  explicit RunApplicationActionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (actionName) {
      res["ActionName"] = boost::any(*actionName);
    }
    if (batchSize) {
      res["BatchSize"] = boost::any(*batchSize);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (componentInstanceSelector) {
      res["ComponentInstanceSelector"] = componentInstanceSelector ? boost::any(componentInstanceSelector->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (executeStrategy) {
      res["ExecuteStrategy"] = boost::any(*executeStrategy);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (rollingExecute) {
      res["RollingExecute"] = boost::any(*rollingExecute);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActionName") != m.end() && !m["ActionName"].empty()) {
      actionName = make_shared<string>(boost::any_cast<string>(m["ActionName"]));
    }
    if (m.find("BatchSize") != m.end() && !m["BatchSize"].empty()) {
      batchSize = make_shared<long>(boost::any_cast<long>(m["BatchSize"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("ComponentInstanceSelector") != m.end() && !m["ComponentInstanceSelector"].empty()) {
      if (typeid(map<string, boost::any>) == m["ComponentInstanceSelector"].type()) {
        ComponentInstanceSelector model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ComponentInstanceSelector"]));
        componentInstanceSelector = make_shared<ComponentInstanceSelector>(model1);
      }
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ExecuteStrategy") != m.end() && !m["ExecuteStrategy"].empty()) {
      executeStrategy = make_shared<string>(boost::any_cast<string>(m["ExecuteStrategy"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<long>(boost::any_cast<long>(m["Interval"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RollingExecute") != m.end() && !m["RollingExecute"].empty()) {
      rollingExecute = make_shared<bool>(boost::any_cast<bool>(m["RollingExecute"]));
    }
  }


  virtual ~RunApplicationActionRequest() = default;
};
class RunApplicationActionResponseBodyAbnInstances : public Darabonba::Model {
public:
  shared_ptr<string> nodeId{};
  shared_ptr<string> nodeName{};

  RunApplicationActionResponseBodyAbnInstances() {}

  explicit RunApplicationActionResponseBodyAbnInstances(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (nodeName) {
      res["NodeName"] = boost::any(*nodeName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<string>(boost::any_cast<string>(m["NodeId"]));
    }
    if (m.find("NodeName") != m.end() && !m["NodeName"].empty()) {
      nodeName = make_shared<string>(boost::any_cast<string>(m["NodeName"]));
    }
  }


  virtual ~RunApplicationActionResponseBodyAbnInstances() = default;
};
class RunApplicationActionResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<RunApplicationActionResponseBodyAbnInstances>> abnInstances{};
  shared_ptr<string> operationId{};
  shared_ptr<string> requestId{};

  RunApplicationActionResponseBody() {}

  explicit RunApplicationActionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (abnInstances) {
      vector<boost::any> temp1;
      for(auto item1:*abnInstances){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AbnInstances"] = boost::any(temp1);
    }
    if (operationId) {
      res["OperationId"] = boost::any(*operationId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AbnInstances") != m.end() && !m["AbnInstances"].empty()) {
      if (typeid(vector<boost::any>) == m["AbnInstances"].type()) {
        vector<RunApplicationActionResponseBodyAbnInstances> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AbnInstances"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            RunApplicationActionResponseBodyAbnInstances model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        abnInstances = make_shared<vector<RunApplicationActionResponseBodyAbnInstances>>(expect1);
      }
    }
    if (m.find("OperationId") != m.end() && !m["OperationId"].empty()) {
      operationId = make_shared<string>(boost::any_cast<string>(m["OperationId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RunApplicationActionResponseBody() = default;
};
class RunApplicationActionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RunApplicationActionResponseBody> body{};

  RunApplicationActionResponse() {}

  explicit RunApplicationActionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RunApplicationActionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RunApplicationActionResponseBody>(model1);
      }
    }
  }


  virtual ~RunApplicationActionResponse() = default;
};
class TagResourcesRequest : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};
  shared_ptr<vector<string>> resourceIds{};
  shared_ptr<string> resourceType{};
  shared_ptr<vector<Tag>> tags{};

  TagResourcesRequest() {}

  explicit TagResourcesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceIds) {
      res["ResourceIds"] = boost::any(*resourceIds);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceIds") != m.end() && !m["ResourceIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ResourceIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ResourceIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      resourceIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<Tag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            Tag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<Tag>>(expect1);
      }
    }
  }


  virtual ~TagResourcesRequest() = default;
};
class TagResourcesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  TagResourcesResponseBody() {}

  explicit TagResourcesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~TagResourcesResponseBody() = default;
};
class TagResourcesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<TagResourcesResponseBody> body{};

  TagResourcesResponse() {}

  explicit TagResourcesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        TagResourcesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<TagResourcesResponseBody>(model1);
      }
    }
  }


  virtual ~TagResourcesResponse() = default;
};
class UntagResourcesRequest : public Darabonba::Model {
public:
  shared_ptr<bool> all{};
  shared_ptr<string> regionId{};
  shared_ptr<vector<string>> resourceIds{};
  shared_ptr<string> resourceType{};
  shared_ptr<vector<string>> tagKeys{};

  UntagResourcesRequest() {}

  explicit UntagResourcesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (all) {
      res["All"] = boost::any(*all);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceIds) {
      res["ResourceIds"] = boost::any(*resourceIds);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (tagKeys) {
      res["TagKeys"] = boost::any(*tagKeys);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("All") != m.end() && !m["All"].empty()) {
      all = make_shared<bool>(boost::any_cast<bool>(m["All"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceIds") != m.end() && !m["ResourceIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ResourceIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ResourceIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      resourceIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("TagKeys") != m.end() && !m["TagKeys"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["TagKeys"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["TagKeys"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      tagKeys = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~UntagResourcesRequest() = default;
};
class UntagResourcesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UntagResourcesResponseBody() {}

  explicit UntagResourcesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UntagResourcesResponseBody() = default;
};
class UntagResourcesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UntagResourcesResponseBody> body{};

  UntagResourcesResponse() {}

  explicit UntagResourcesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UntagResourcesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UntagResourcesResponseBody>(model1);
      }
    }
  }


  virtual ~UntagResourcesResponse() = default;
};
class UpdateApiTemplateRequest : public Darabonba::Model {
public:
  shared_ptr<string> apiName{};
  shared_ptr<string> content{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> templateId{};
  shared_ptr<string> templateName{};

  UpdateApiTemplateRequest() {}

  explicit UpdateApiTemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiName) {
      res["ApiName"] = boost::any(*apiName);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (templateName) {
      res["TemplateName"] = boost::any(*templateName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiName") != m.end() && !m["ApiName"].empty()) {
      apiName = make_shared<string>(boost::any_cast<string>(m["ApiName"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("TemplateName") != m.end() && !m["TemplateName"].empty()) {
      templateName = make_shared<string>(boost::any_cast<string>(m["TemplateName"]));
    }
  }


  virtual ~UpdateApiTemplateRequest() = default;
};
class UpdateApiTemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateApiTemplateResponseBody() {}

  explicit UpdateApiTemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateApiTemplateResponseBody() = default;
};
class UpdateApiTemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateApiTemplateResponseBody> body{};

  UpdateApiTemplateResponse() {}

  explicit UpdateApiTemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateApiTemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateApiTemplateResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateApiTemplateResponse() = default;
};
class UpdateApplicationConfigsRequest : public Darabonba::Model {
public:
  shared_ptr<vector<UpdateApplicationConfig>> applicationConfigs{};
  shared_ptr<string> applicationName{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> configAction{};
  shared_ptr<string> configScope{};
  shared_ptr<string> description{};
  shared_ptr<string> nodeGroupId{};
  shared_ptr<string> nodeId{};
  shared_ptr<bool> refreshConfig{};
  shared_ptr<string> regionId{};

  UpdateApplicationConfigsRequest() {}

  explicit UpdateApplicationConfigsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applicationConfigs) {
      vector<boost::any> temp1;
      for(auto item1:*applicationConfigs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ApplicationConfigs"] = boost::any(temp1);
    }
    if (applicationName) {
      res["ApplicationName"] = boost::any(*applicationName);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (configAction) {
      res["ConfigAction"] = boost::any(*configAction);
    }
    if (configScope) {
      res["ConfigScope"] = boost::any(*configScope);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (nodeGroupId) {
      res["NodeGroupId"] = boost::any(*nodeGroupId);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (refreshConfig) {
      res["RefreshConfig"] = boost::any(*refreshConfig);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApplicationConfigs") != m.end() && !m["ApplicationConfigs"].empty()) {
      if (typeid(vector<boost::any>) == m["ApplicationConfigs"].type()) {
        vector<UpdateApplicationConfig> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ApplicationConfigs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateApplicationConfig model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        applicationConfigs = make_shared<vector<UpdateApplicationConfig>>(expect1);
      }
    }
    if (m.find("ApplicationName") != m.end() && !m["ApplicationName"].empty()) {
      applicationName = make_shared<string>(boost::any_cast<string>(m["ApplicationName"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("ConfigAction") != m.end() && !m["ConfigAction"].empty()) {
      configAction = make_shared<string>(boost::any_cast<string>(m["ConfigAction"]));
    }
    if (m.find("ConfigScope") != m.end() && !m["ConfigScope"].empty()) {
      configScope = make_shared<string>(boost::any_cast<string>(m["ConfigScope"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("NodeGroupId") != m.end() && !m["NodeGroupId"].empty()) {
      nodeGroupId = make_shared<string>(boost::any_cast<string>(m["NodeGroupId"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<string>(boost::any_cast<string>(m["NodeId"]));
    }
    if (m.find("RefreshConfig") != m.end() && !m["RefreshConfig"].empty()) {
      refreshConfig = make_shared<bool>(boost::any_cast<bool>(m["RefreshConfig"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~UpdateApplicationConfigsRequest() = default;
};
class UpdateApplicationConfigsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> operationId{};
  shared_ptr<string> requestId{};

  UpdateApplicationConfigsResponseBody() {}

  explicit UpdateApplicationConfigsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (operationId) {
      res["OperationId"] = boost::any(*operationId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OperationId") != m.end() && !m["OperationId"].empty()) {
      operationId = make_shared<string>(boost::any_cast<string>(m["OperationId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateApplicationConfigsResponseBody() = default;
};
class UpdateApplicationConfigsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateApplicationConfigsResponseBody> body{};

  UpdateApplicationConfigsResponse() {}

  explicit UpdateApplicationConfigsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateApplicationConfigsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateApplicationConfigsResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateApplicationConfigsResponse() = default;
};
class UpdateScriptRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> regionId{};
  shared_ptr<Script> script{};
  shared_ptr<string> scriptId{};
  shared_ptr<string> scriptType{};

  UpdateScriptRequest() {}

  explicit UpdateScriptRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (script) {
      res["Script"] = script ? boost::any(script->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (scriptId) {
      res["ScriptId"] = boost::any(*scriptId);
    }
    if (scriptType) {
      res["ScriptType"] = boost::any(*scriptType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Script") != m.end() && !m["Script"].empty()) {
      if (typeid(map<string, boost::any>) == m["Script"].type()) {
        Script model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Script"]));
        script = make_shared<Script>(model1);
      }
    }
    if (m.find("ScriptId") != m.end() && !m["ScriptId"].empty()) {
      scriptId = make_shared<string>(boost::any_cast<string>(m["ScriptId"]));
    }
    if (m.find("ScriptType") != m.end() && !m["ScriptType"].empty()) {
      scriptType = make_shared<string>(boost::any_cast<string>(m["ScriptType"]));
    }
  }


  virtual ~UpdateScriptRequest() = default;
};
class UpdateScriptShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> scriptShrink{};
  shared_ptr<string> scriptId{};
  shared_ptr<string> scriptType{};

  UpdateScriptShrinkRequest() {}

  explicit UpdateScriptShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (scriptShrink) {
      res["Script"] = boost::any(*scriptShrink);
    }
    if (scriptId) {
      res["ScriptId"] = boost::any(*scriptId);
    }
    if (scriptType) {
      res["ScriptType"] = boost::any(*scriptType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Script") != m.end() && !m["Script"].empty()) {
      scriptShrink = make_shared<string>(boost::any_cast<string>(m["Script"]));
    }
    if (m.find("ScriptId") != m.end() && !m["ScriptId"].empty()) {
      scriptId = make_shared<string>(boost::any_cast<string>(m["ScriptId"]));
    }
    if (m.find("ScriptType") != m.end() && !m["ScriptType"].empty()) {
      scriptType = make_shared<string>(boost::any_cast<string>(m["ScriptType"]));
    }
  }


  virtual ~UpdateScriptShrinkRequest() = default;
};
class UpdateScriptResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateScriptResponseBody() {}

  explicit UpdateScriptResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateScriptResponseBody() = default;
};
class UpdateScriptResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateScriptResponseBody> body{};

  UpdateScriptResponse() {}

  explicit UpdateScriptResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateScriptResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateScriptResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateScriptResponse() = default;
};
class Client : Alibabacloud_OpenApi::Client {
public:
  explicit Client(const shared_ptr<Alibabacloud_OpenApi::Config>& config);
  string getEndpoint(shared_ptr<string> productId,
                     shared_ptr<string> regionId,
                     shared_ptr<string> endpointRule,
                     shared_ptr<string> network,
                     shared_ptr<string> suffix,
                     shared_ptr<map<string, string>> endpointMap,
                     shared_ptr<string> endpoint);
  CreateApiTemplateResponse createApiTemplateWithOptions(shared_ptr<CreateApiTemplateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateApiTemplateResponse createApiTemplate(shared_ptr<CreateApiTemplateRequest> request);
  CreateClusterResponse createClusterWithOptions(shared_ptr<CreateClusterRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateClusterResponse createCluster(shared_ptr<CreateClusterRequest> request);
  CreateNodeGroupResponse createNodeGroupWithOptions(shared_ptr<CreateNodeGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateNodeGroupResponse createNodeGroup(shared_ptr<CreateNodeGroupRequest> request);
  CreateScriptResponse createScriptWithOptions(shared_ptr<CreateScriptRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateScriptResponse createScript(shared_ptr<CreateScriptRequest> request);
  DecreaseNodesResponse decreaseNodesWithOptions(shared_ptr<DecreaseNodesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DecreaseNodesResponse decreaseNodes(shared_ptr<DecreaseNodesRequest> request);
  DeleteApiTemplateResponse deleteApiTemplateWithOptions(shared_ptr<DeleteApiTemplateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteApiTemplateResponse deleteApiTemplate(shared_ptr<DeleteApiTemplateRequest> request);
  DeleteClusterResponse deleteClusterWithOptions(shared_ptr<DeleteClusterRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteClusterResponse deleteCluster(shared_ptr<DeleteClusterRequest> request);
  DeleteScriptResponse deleteScriptWithOptions(shared_ptr<DeleteScriptRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteScriptResponse deleteScript(shared_ptr<DeleteScriptRequest> request);
  GetApiTemplateResponse getApiTemplateWithOptions(shared_ptr<GetApiTemplateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetApiTemplateResponse getApiTemplate(shared_ptr<GetApiTemplateRequest> request);
  GetApplicationResponse getApplicationWithOptions(shared_ptr<GetApplicationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetApplicationResponse getApplication(shared_ptr<GetApplicationRequest> request);
  GetAutoScalingActivityResponse getAutoScalingActivityWithOptions(shared_ptr<GetAutoScalingActivityRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetAutoScalingActivityResponse getAutoScalingActivity(shared_ptr<GetAutoScalingActivityRequest> request);
  GetAutoScalingPolicyResponse getAutoScalingPolicyWithOptions(shared_ptr<GetAutoScalingPolicyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetAutoScalingPolicyResponse getAutoScalingPolicy(shared_ptr<GetAutoScalingPolicyRequest> request);
  GetClusterResponse getClusterWithOptions(shared_ptr<GetClusterRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetClusterResponse getCluster(shared_ptr<GetClusterRequest> request);
  GetDoctorApplicationResponse getDoctorApplicationWithOptions(shared_ptr<GetDoctorApplicationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetDoctorApplicationResponse getDoctorApplication(shared_ptr<GetDoctorApplicationRequest> request);
  GetDoctorComputeSummaryResponse getDoctorComputeSummaryWithOptions(shared_ptr<GetDoctorComputeSummaryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetDoctorComputeSummaryResponse getDoctorComputeSummary(shared_ptr<GetDoctorComputeSummaryRequest> request);
  GetDoctorHBaseClusterResponse getDoctorHBaseClusterWithOptions(shared_ptr<GetDoctorHBaseClusterRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetDoctorHBaseClusterResponse getDoctorHBaseCluster(shared_ptr<GetDoctorHBaseClusterRequest> request);
  GetDoctorHBaseRegionResponse getDoctorHBaseRegionWithOptions(shared_ptr<GetDoctorHBaseRegionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetDoctorHBaseRegionResponse getDoctorHBaseRegion(shared_ptr<GetDoctorHBaseRegionRequest> request);
  GetDoctorHBaseRegionServerResponse getDoctorHBaseRegionServerWithOptions(shared_ptr<GetDoctorHBaseRegionServerRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetDoctorHBaseRegionServerResponse getDoctorHBaseRegionServer(shared_ptr<GetDoctorHBaseRegionServerRequest> request);
  GetDoctorHBaseTableResponse getDoctorHBaseTableWithOptions(shared_ptr<GetDoctorHBaseTableRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetDoctorHBaseTableResponse getDoctorHBaseTable(shared_ptr<GetDoctorHBaseTableRequest> request);
  GetDoctorHDFSClusterResponse getDoctorHDFSClusterWithOptions(shared_ptr<GetDoctorHDFSClusterRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetDoctorHDFSClusterResponse getDoctorHDFSCluster(shared_ptr<GetDoctorHDFSClusterRequest> request);
  GetDoctorHDFSDirectoryResponse getDoctorHDFSDirectoryWithOptions(shared_ptr<GetDoctorHDFSDirectoryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetDoctorHDFSDirectoryResponse getDoctorHDFSDirectory(shared_ptr<GetDoctorHDFSDirectoryRequest> request);
  GetDoctorHDFSUGIResponse getDoctorHDFSUGIWithOptions(shared_ptr<GetDoctorHDFSUGIRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetDoctorHDFSUGIResponse getDoctorHDFSUGI(shared_ptr<GetDoctorHDFSUGIRequest> request);
  GetDoctorHiveClusterResponse getDoctorHiveClusterWithOptions(shared_ptr<GetDoctorHiveClusterRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetDoctorHiveClusterResponse getDoctorHiveCluster(shared_ptr<GetDoctorHiveClusterRequest> request);
  GetDoctorHiveDatabaseResponse getDoctorHiveDatabaseWithOptions(shared_ptr<GetDoctorHiveDatabaseRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetDoctorHiveDatabaseResponse getDoctorHiveDatabase(shared_ptr<GetDoctorHiveDatabaseRequest> request);
  GetDoctorHiveTableResponse getDoctorHiveTableWithOptions(shared_ptr<GetDoctorHiveTableRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetDoctorHiveTableResponse getDoctorHiveTable(shared_ptr<GetDoctorHiveTableRequest> request);
  GetDoctorJobResponse getDoctorJobWithOptions(shared_ptr<GetDoctorJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetDoctorJobResponse getDoctorJob(shared_ptr<GetDoctorJobRequest> request);
  GetDoctorReportComponentSummaryResponse getDoctorReportComponentSummaryWithOptions(shared_ptr<GetDoctorReportComponentSummaryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetDoctorReportComponentSummaryResponse getDoctorReportComponentSummary(shared_ptr<GetDoctorReportComponentSummaryRequest> request);
  GetNodeGroupResponse getNodeGroupWithOptions(shared_ptr<GetNodeGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetNodeGroupResponse getNodeGroup(shared_ptr<GetNodeGroupRequest> request);
  GetOperationResponse getOperationWithOptions(shared_ptr<GetOperationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetOperationResponse getOperation(shared_ptr<GetOperationRequest> request);
  IncreaseNodesResponse increaseNodesWithOptions(shared_ptr<IncreaseNodesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  IncreaseNodesResponse increaseNodes(shared_ptr<IncreaseNodesRequest> request);
  JoinResourceGroupResponse joinResourceGroupWithOptions(shared_ptr<JoinResourceGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  JoinResourceGroupResponse joinResourceGroup(shared_ptr<JoinResourceGroupRequest> request);
  ListApiTemplatesResponse listApiTemplatesWithOptions(shared_ptr<ListApiTemplatesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListApiTemplatesResponse listApiTemplates(shared_ptr<ListApiTemplatesRequest> request);
  ListApplicationConfigsResponse listApplicationConfigsWithOptions(shared_ptr<ListApplicationConfigsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListApplicationConfigsResponse listApplicationConfigs(shared_ptr<ListApplicationConfigsRequest> request);
  ListApplicationsResponse listApplicationsWithOptions(shared_ptr<ListApplicationsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListApplicationsResponse listApplications(shared_ptr<ListApplicationsRequest> request);
  ListAutoScalingActivitiesResponse listAutoScalingActivitiesWithOptions(shared_ptr<ListAutoScalingActivitiesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListAutoScalingActivitiesResponse listAutoScalingActivities(shared_ptr<ListAutoScalingActivitiesRequest> request);
  ListClustersResponse listClustersWithOptions(shared_ptr<ListClustersRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListClustersResponse listClusters(shared_ptr<ListClustersRequest> request);
  ListComponentInstancesResponse listComponentInstancesWithOptions(shared_ptr<ListComponentInstancesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListComponentInstancesResponse listComponentInstances(shared_ptr<ListComponentInstancesRequest> request);
  ListComponentsResponse listComponentsWithOptions(shared_ptr<ListComponentsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListComponentsResponse listComponents(shared_ptr<ListComponentsRequest> request);
  ListDoctorApplicationsResponse listDoctorApplicationsWithOptions(shared_ptr<ListDoctorApplicationsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListDoctorApplicationsResponse listDoctorApplications(shared_ptr<ListDoctorApplicationsRequest> request);
  ListDoctorComputeSummaryResponse listDoctorComputeSummaryWithOptions(shared_ptr<ListDoctorComputeSummaryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListDoctorComputeSummaryResponse listDoctorComputeSummary(shared_ptr<ListDoctorComputeSummaryRequest> request);
  ListDoctorHBaseRegionServersResponse listDoctorHBaseRegionServersWithOptions(shared_ptr<ListDoctorHBaseRegionServersRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListDoctorHBaseRegionServersResponse listDoctorHBaseRegionServers(shared_ptr<ListDoctorHBaseRegionServersRequest> request);
  ListDoctorHBaseTablesResponse listDoctorHBaseTablesWithOptions(shared_ptr<ListDoctorHBaseTablesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListDoctorHBaseTablesResponse listDoctorHBaseTables(shared_ptr<ListDoctorHBaseTablesRequest> request);
  ListDoctorHDFSDirectoriesResponse listDoctorHDFSDirectoriesWithOptions(shared_ptr<ListDoctorHDFSDirectoriesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListDoctorHDFSDirectoriesResponse listDoctorHDFSDirectories(shared_ptr<ListDoctorHDFSDirectoriesRequest> request);
  ListDoctorHDFSUGIResponse listDoctorHDFSUGIWithOptions(shared_ptr<ListDoctorHDFSUGIRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListDoctorHDFSUGIResponse listDoctorHDFSUGI(shared_ptr<ListDoctorHDFSUGIRequest> request);
  ListDoctorHiveDatabasesResponse listDoctorHiveDatabasesWithOptions(shared_ptr<ListDoctorHiveDatabasesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListDoctorHiveDatabasesResponse listDoctorHiveDatabases(shared_ptr<ListDoctorHiveDatabasesRequest> request);
  ListDoctorHiveTablesResponse listDoctorHiveTablesWithOptions(shared_ptr<ListDoctorHiveTablesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListDoctorHiveTablesResponse listDoctorHiveTables(shared_ptr<ListDoctorHiveTablesRequest> request);
  ListDoctorJobsResponse listDoctorJobsWithOptions(shared_ptr<ListDoctorJobsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListDoctorJobsResponse listDoctorJobs(shared_ptr<ListDoctorJobsRequest> request);
  ListDoctorJobsStatsResponse listDoctorJobsStatsWithOptions(shared_ptr<ListDoctorJobsStatsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListDoctorJobsStatsResponse listDoctorJobsStats(shared_ptr<ListDoctorJobsStatsRequest> request);
  ListDoctorReportsResponse listDoctorReportsWithOptions(shared_ptr<ListDoctorReportsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListDoctorReportsResponse listDoctorReports(shared_ptr<ListDoctorReportsRequest> request);
  ListInspectionHistoryResponse listInspectionHistoryWithOptions(shared_ptr<ListInspectionHistoryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListInspectionHistoryResponse listInspectionHistory(shared_ptr<ListInspectionHistoryRequest> request);
  ListInstanceTypesResponse listInstanceTypesWithOptions(shared_ptr<ListInstanceTypesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListInstanceTypesResponse listInstanceTypes(shared_ptr<ListInstanceTypesRequest> request);
  ListNodeGroupsResponse listNodeGroupsWithOptions(shared_ptr<ListNodeGroupsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListNodeGroupsResponse listNodeGroups(shared_ptr<ListNodeGroupsRequest> request);
  ListNodesResponse listNodesWithOptions(shared_ptr<ListNodesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListNodesResponse listNodes(shared_ptr<ListNodesRequest> request);
  ListReleaseVersionsResponse listReleaseVersionsWithOptions(shared_ptr<ListReleaseVersionsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListReleaseVersionsResponse listReleaseVersions(shared_ptr<ListReleaseVersionsRequest> request);
  ListResourceHealthInspectionsResponse listResourceHealthInspectionsWithOptions(shared_ptr<ListResourceHealthInspectionsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListResourceHealthInspectionsResponse listResourceHealthInspections(shared_ptr<ListResourceHealthInspectionsRequest> request);
  ListScriptsResponse listScriptsWithOptions(shared_ptr<ListScriptsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListScriptsResponse listScripts(shared_ptr<ListScriptsRequest> request);
  ListTagResourcesResponse listTagResourcesWithOptions(shared_ptr<ListTagResourcesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListTagResourcesResponse listTagResources(shared_ptr<ListTagResourcesRequest> request);
  PutAutoScalingPolicyResponse putAutoScalingPolicyWithOptions(shared_ptr<PutAutoScalingPolicyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  PutAutoScalingPolicyResponse putAutoScalingPolicy(shared_ptr<PutAutoScalingPolicyRequest> request);
  RemoveAutoScalingPolicyResponse removeAutoScalingPolicyWithOptions(shared_ptr<RemoveAutoScalingPolicyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RemoveAutoScalingPolicyResponse removeAutoScalingPolicy(shared_ptr<RemoveAutoScalingPolicyRequest> request);
  RunApiTemplateResponse runApiTemplateWithOptions(shared_ptr<RunApiTemplateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RunApiTemplateResponse runApiTemplate(shared_ptr<RunApiTemplateRequest> request);
  RunApplicationActionResponse runApplicationActionWithOptions(shared_ptr<RunApplicationActionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RunApplicationActionResponse runApplicationAction(shared_ptr<RunApplicationActionRequest> request);
  TagResourcesResponse tagResourcesWithOptions(shared_ptr<TagResourcesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  TagResourcesResponse tagResources(shared_ptr<TagResourcesRequest> request);
  UntagResourcesResponse untagResourcesWithOptions(shared_ptr<UntagResourcesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UntagResourcesResponse untagResources(shared_ptr<UntagResourcesRequest> request);
  UpdateApiTemplateResponse updateApiTemplateWithOptions(shared_ptr<UpdateApiTemplateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateApiTemplateResponse updateApiTemplate(shared_ptr<UpdateApiTemplateRequest> request);
  UpdateApplicationConfigsResponse updateApplicationConfigsWithOptions(shared_ptr<UpdateApplicationConfigsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateApplicationConfigsResponse updateApplicationConfigs(shared_ptr<UpdateApplicationConfigsRequest> request);
  UpdateScriptResponse updateScriptWithOptions(shared_ptr<UpdateScriptRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateScriptResponse updateScript(shared_ptr<UpdateScriptRequest> request);

  virtual ~Client() = default;
};
} // namespace Alibabacloud_Emr20210320

#endif
